{"path":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","commits":[{"id":"7b13106276bb5ea342253dbf6aae7b675adb38d3","date":1428054414,"type":0,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location, \"snapshot.\" + snapshotName);\n    Path segmentFileName = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\").iterator().next();\n    Files.delete(segmentFileName);\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["28c977c4aef9be49834367cc544d77c28f8d2770"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location, \"snapshot.\" + snapshotName);\n    Path segmentFileName = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\").iterator().next();\n    Files.delete(segmentFileName);\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28c977c4aef9be49834367cc544d77c28f8d2770","date":1428417532,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location, \"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location, \"snapshot.\" + snapshotName);\n    Path segmentFileName = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\").iterator().next();\n    Files.delete(segmentFileName);\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","bugFix":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c42316df77794f7252857e7d5e9ce45ff1d65c61","date":1428666763,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location, \"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","date":1466705968,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    verifyDocs(nDocs);\n\n    //make sure we can write to the index again\n    nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n    verifyDocs(nDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec54bd926c45854b5a1599685b0f7d2bfbfe177f","date":1573838246,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String backupDirName = backupStatus.waitForBackupSuccess(snapshotName, 30);\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    final Path restoreIndexPath = Paths.get(location, backupDirName);\n    assertTrue(\"Does not exist: \" + restoreIndexPath, Files.exists(restoreIndexPath));\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    expectThrows(AssertionError.class, () -> {\n        for (int i = 0; i < 10; i++) {\n          // this will throw an assertion once we get what we expect\n          fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME);\n          Thread.sleep(50);\n        }\n        // if we never got an assertion let expectThrows complain\n      });\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    Path restoreIndexPath = Paths.get(location).resolve(\"snapshot.\" + snapshotName);\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    try {\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n      fail(\"Should have thrown an error because restore could not have been successful\");\n    } catch (AssertionError e) {\n      //supposed to happen\n    }\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6b17e67903ace8abb1d4d602bfc40d1994692ff","date":1593429504,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    masterJetty.getCoreContainer().getAllowPaths().add(Path.of(location));\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String backupDirName = backupStatus.waitForBackupSuccess(snapshotName, 30);\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    final Path restoreIndexPath = Paths.get(location, backupDirName);\n    assertTrue(\"Does not exist: \" + restoreIndexPath, Files.exists(restoreIndexPath));\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    expectThrows(AssertionError.class, () -> {\n        for (int i = 0; i < 10; i++) {\n          // this will throw an assertion once we get what we expect\n          fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME);\n          Thread.sleep(50);\n        }\n        // if we never got an assertion let expectThrows complain\n      });\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String backupDirName = backupStatus.waitForBackupSuccess(snapshotName, 30);\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    final Path restoreIndexPath = Paths.get(location, backupDirName);\n    assertTrue(\"Does not exist: \" + restoreIndexPath, Files.exists(restoreIndexPath));\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    expectThrows(AssertionError.class, () -> {\n        for (int i = 0; i < 10; i++) {\n          // this will throw an assertion once we get what we expect\n          fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME);\n          Thread.sleep(50);\n        }\n        // if we never got an assertion let expectThrows complain\n      });\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testFailedRestore().mjava","sourceNew":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(leaderClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    leaderJetty.getCoreContainer().getAllowPaths().add(Path.of(location));\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = leaderJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(leaderJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(leaderClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String backupDirName = backupStatus.waitForBackupSuccess(snapshotName, 30);\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    final Path restoreIndexPath = Paths.get(location, backupDirName);\n    assertTrue(\"Does not exist: \" + restoreIndexPath, Files.exists(restoreIndexPath));\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(leaderJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    expectThrows(AssertionError.class, () -> {\n        for (int i = 0; i < 10; i++) {\n          // this will throw an assertion once we get what we expect\n          fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME);\n          Thread.sleep(50);\n        }\n        // if we never got an assertion let expectThrows complain\n      });\n\n    BackupRestoreUtils.verifyDocs(nDocs, leaderClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(leaderClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, leaderClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","sourceOld":"  @Test\n  public void testFailedRestore() throws Exception {\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n\n    String location = createTempDir().toFile().getAbsolutePath();\n    masterJetty.getCoreContainer().getAllowPaths().add(Path.of(location));\n    String snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n    String params = \"&name=\" + snapshotName + \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String backupDirName = backupStatus.waitForBackupSuccess(snapshotName, 30);\n\n    //Remove the segments_n file so that the backup index is corrupted.\n    //Restore should fail and it should automatically rollback to the original index.\n    final Path restoreIndexPath = Paths.get(location, backupDirName);\n    assertTrue(\"Does not exist: \" + restoreIndexPath, Files.exists(restoreIndexPath));\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(restoreIndexPath, IndexFileNames.SEGMENTS + \"*\")) {\n      Path segmentFileName = stream.iterator().next();\n      Files.delete(segmentFileName);\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    expectThrows(AssertionError.class, () -> {\n        for (int i = 0; i < 10; i++) {\n          // this will throw an assertion once we get what we expect\n          fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME);\n          Thread.sleep(50);\n        }\n        // if we never got an assertion let expectThrows complain\n      });\n\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n    //make sure we can write to the index again\n    nDocs = BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["ec54bd926c45854b5a1599685b0f7d2bfbfe177f"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"28c977c4aef9be49834367cc544d77c28f8d2770":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["c42316df77794f7252857e7d5e9ce45ff1d65c61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"c42316df77794f7252857e7d5e9ce45ff1d65c61":["28c977c4aef9be49834367cc544d77c28f8d2770"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c42316df77794f7252857e7d5e9ce45ff1d65c61","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"28c977c4aef9be49834367cc544d77c28f8d2770":["c42316df77794f7252857e7d5e9ce45ff1d65c61"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["ec54bd926c45854b5a1599685b0f7d2bfbfe177f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"c42316df77794f7252857e7d5e9ce45ff1d65c61":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["28c977c4aef9be49834367cc544d77c28f8d2770","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}