{"path":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","commits":[{"id":"aa09157b213a620622ccae0ef62a1da45a683222","date":1359149228,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter _w = new IndexWriter(dir, iwc);\n    final TrackingIndexWriter w = new TrackingIndexWriter(_w);\n\n    final NRTManager mgr = new NRTManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<Integer> rt = new LiveFieldValues<Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    _w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter _w = new IndexWriter(dir, iwc);\n    final TrackingIndexWriter w = new TrackingIndexWriter(_w);\n\n    final NRTManager mgr = new NRTManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<Integer> rt = new LiveFieldValues<Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    _w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2045b132a2396bb23dff28d2d9f349a6907d36e","date":1367513076,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<Integer> rt = new LiveFieldValues<Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter _w = new IndexWriter(dir, iwc);\n    final TrackingIndexWriter w = new TrackingIndexWriter(_w);\n\n    final NRTManager mgr = new NRTManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<Integer> rt = new LiveFieldValues<Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    _w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a07fb647035facac4213bc05b893142a292a20cc","date":1367943764,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<Integer> rt = new LiveFieldValues<Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = _TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = _TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<Thread>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<String,Integer>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(TestUtil.getTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0dfae671422e7453a9199aa320f91427cd80d60","date":1427895926,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399d127639ae13222a8545b50e0ac545a6bcd2d7","date":1428704686,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(new StringField(\"id\", id, Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", randomID));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new IntField(\"field\", field.intValue(), Field.Store.YES));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            Document doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            StoredDocument doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            Document doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, true, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            Document doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLiveFieldValues#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits.value <= 1);\n          if (hits.totalHits.value == 0) {\n            return null;\n          } else {\n            Document doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Directory dir = newFSDirectory(createTempDir(\"livefieldupdates\"));\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final SearcherManager mgr = new SearcherManager(w, new SearcherFactory() {\n        @Override\n        public IndexSearcher newSearcher(IndexReader r, IndexReader previous) {\n          return new IndexSearcher(r);\n        }\n      });\n\n    final Integer missing = -1;\n\n    final LiveFieldValues<IndexSearcher,Integer> rt = new LiveFieldValues<IndexSearcher,Integer>(mgr, missing) {\n        @Override\n        protected Integer lookupFromSearcher(IndexSearcher s, String id) throws IOException {\n          TermQuery tq = new TermQuery(new Term(\"id\", id));\n          TopDocs hits = s.search(tq, 1);\n          assertTrue(hits.totalHits <= 1);\n          if (hits.totalHits == 0) {\n            return null;\n          } else {\n            Document doc = s.doc(hits.scoreDocs[0].doc);\n            return (Integer) doc.getField(\"field\").numericValue();\n          }\n        }\n    };\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n    if (VERBOSE) {\n      System.out.println(numThreads + \" threads\");\n    }\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<Thread> threads = new ArrayList<>();\n\n    final int iters = atLeast(1000);\n    final int idCount = TestUtil.nextInt(random(), 100, 10000);\n\n    final double reopenChance = random().nextDouble()*0.01;\n    final double deleteChance = random().nextDouble()*0.25;\n    final double addChance = random().nextDouble()*0.5;\n    \n    for(int t=0;t<numThreads;t++) {\n      final int threadID = t;\n      final Random threadRandom = new Random(random().nextLong());\n      Thread thread = new Thread() {\n\n          @Override\n          public void run() {\n            try {\n              Map<String,Integer> values = new HashMap<>();\n              List<String> allIDs = Collections.synchronizedList(new ArrayList<String>());\n\n              startingGun.await();\n              for(int iter=0; iter<iters;iter++) {\n                // Add/update a document\n                Document doc = new Document();\n                // Threads must not update the same id at the\n                // same time:\n                if (threadRandom.nextDouble() <= addChance) {\n                  String id = String.format(Locale.ROOT, \"%d_%04x\", threadID, threadRandom.nextInt(idCount));\n                  Integer field = threadRandom.nextInt(Integer.MAX_VALUE);\n                  doc.add(newStringField(\"id\", new BytesRef(id), Field.Store.YES));\n                  doc.add(new StoredField(\"field\", field.intValue()));\n                  w.updateDocument(new Term(\"id\", id), doc);\n                  rt.add(id, field);\n                  if (values.put(id, field) == null) {\n                    allIDs.add(id);\n                  }\n                }\n\n                if (allIDs.size() > 0 && threadRandom.nextDouble() <= deleteChance) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  w.deleteDocuments(new Term(\"id\", new BytesRef(randomID)));\n                  rt.delete(randomID);\n                  values.put(randomID, missing);\n                }\n\n                if (threadRandom.nextDouble() <= reopenChance || rt.size() > 10000) {\n                  //System.out.println(\"refresh @ \" + rt.size());\n                  mgr.maybeRefresh();\n                  if (VERBOSE) {\n                    IndexSearcher s = mgr.acquire();\n                    try {\n                      System.out.println(\"TEST: reopen \" + s);\n                    } finally {\n                      mgr.release(s);\n                    }\n                    System.out.println(\"TEST: \" + values.size() + \" values\");\n                  }\n                }\n\n                if (threadRandom.nextInt(10) == 7) {\n                  assertEquals(null, rt.get(\"foo\"));\n                }\n\n                if (allIDs.size() > 0) {\n                  String randomID = allIDs.get(threadRandom.nextInt(allIDs.size()));\n                  Integer expected = values.get(randomID);\n                  if (expected == missing) {\n                    expected = null;\n                  }\n                  assertEquals(\"id=\" + randomID, expected, rt.get(randomID));\n                }\n              }\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        };\n      threads.add(thread);\n      thread.start();\n    }\n\n    startingGun.countDown();\n\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    mgr.maybeRefresh();\n    assertEquals(0, rt.size());\n\n    rt.close();\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a07fb647035facac4213bc05b893142a292a20cc":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["aa09157b213a620622ccae0ef62a1da45a683222"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a07fb647035facac4213bc05b893142a292a20cc"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"399d127639ae13222a8545b50e0ac545a6bcd2d7":["e0dfae671422e7453a9199aa320f91427cd80d60"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","aa09157b213a620622ccae0ef62a1da45a683222"],"aa09157b213a620622ccae0ef62a1da45a683222":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0d579490a72f2e6297eaa648940611234c57cf1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"770342641f7b505eaa8dccdc666158bff2419109":["399d127639ae13222a8545b50e0ac545a6bcd2d7"],"0c924d4069ef5a5bc479a493befe0121aada6896":["d0ef034a4f10871667ae75181537775ddcf8ade4","e0dfae671422e7453a9199aa320f91427cd80d60"],"e0dfae671422e7453a9199aa320f91427cd80d60":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a07fb647035facac4213bc05b893142a292a20cc":["6613659748fe4411a7dcf85266e55db1f95f7315"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["a07fb647035facac4213bc05b893142a292a20cc"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"399d127639ae13222a8545b50e0ac545a6bcd2d7":["770342641f7b505eaa8dccdc666158bff2419109"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"aa09157b213a620622ccae0ef62a1da45a683222":["c2045b132a2396bb23dff28d2d9f349a6907d36e","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"770342641f7b505eaa8dccdc666158bff2419109":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"e0dfae671422e7453a9199aa320f91427cd80d60":["399d127639ae13222a8545b50e0ac545a6bcd2d7","0c924d4069ef5a5bc479a493befe0121aada6896"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd45d4a2ee01a1932d33eec42f5272c2402da679","aa09157b213a620622ccae0ef62a1da45a683222"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["0c924d4069ef5a5bc479a493befe0121aada6896","e0dfae671422e7453a9199aa320f91427cd80d60"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","0c924d4069ef5a5bc479a493befe0121aada6896","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}