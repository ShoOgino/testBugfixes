{"path":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","commits":[{"id":"18618b2abb825aeab9e0242fbbc3dd799da1739b","date":1346712364,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a56dc0645edef934cc1ce27e59c4c4aecc853f3","date":1441837162,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"038e032723ac44742041643ba792d5d2a592c4f7","date":1575646292,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(GRADLE_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cdec01452b1db9ca43a8369377730a2dcb63658","date":1575646335,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(GRADLE_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d","date":1577274305,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    if (StackWalker.getInstance().walk(s -> s\n        .dropWhile(Predicate.not(TestSecurityManager::isExitStackFrame)) // skip all internal stack frames\n        .dropWhile(TestSecurityManager::isExitStackFrame)                // skip all exit()/halt() stack frames\n        .limit(1)                                                        // only look at one more frame (caller of exit)\n        .map(StackFrame::getClassName)\n        .noneMatch(c -> c.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n            c.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n            c.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n            c.startsWith(GRADLE_TEST_RUNNER_PACKAGE)))) {\n      throw new SecurityException(String.format(Locale.ENGLISH,\n          \"System/Runtime.exit(%1$d) or halt(%1$d) calls are not allowed because they terminate the test runner's JVM.\",\n          status));\n    }\n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(GRADLE_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","date":1577276097,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestSecurityManager#checkExit(int).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    if (StackWalker.getInstance().walk(s -> s\n        .dropWhile(Predicate.not(TestSecurityManager::isExitStackFrame)) // skip all internal stack frames\n        .dropWhile(TestSecurityManager::isExitStackFrame)                // skip all exit()/halt() stack frames\n        .limit(1)                                                        // only look at one more frame (caller of exit)\n        .map(StackFrame::getClassName)\n        .noneMatch(c -> c.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n            c.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n            c.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n            c.startsWith(GRADLE_TEST_RUNNER_PACKAGE)))) {\n      throw new SecurityException(String.format(Locale.ENGLISH,\n          \"System/Runtime.exit(%1$d) or halt(%1$d) calls are not allowed because they terminate the test runner's JVM.\",\n          status));\n    }\n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   * <p>This method inspects the stack trace and checks who is calling\n   * {@link System#exit(int)} and similar methods\n   * @throws SecurityException if the caller of this method is not the test runner itself.\n   */\n  @Override\n  public void checkExit(final int status) {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n      @Override\n      public Void run() {\n        final String systemClassName = System.class.getName(),\n            runtimeClassName = Runtime.class.getName();\n        String exitMethodHit = null;\n        for (final StackTraceElement se : Thread.currentThread().getStackTrace()) {\n          final String className = se.getClassName(), methodName = se.getMethodName();\n          if (\n            (\"exit\".equals(methodName) || \"halt\".equals(methodName)) &&\n            (systemClassName.equals(className) || runtimeClassName.equals(className))\n          ) {\n            exitMethodHit = className + '#' + methodName + '(' + status + ')';\n            continue;\n          }\n          \n          if (exitMethodHit != null) {\n            if (className.startsWith(JUNIT4_TEST_RUNNER_PACKAGE) || \n                className.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(IDEA_TEST_RUNNER_PACKAGE) ||\n                className.startsWith(GRADLE_TEST_RUNNER_PACKAGE)) {\n              // this exit point is allowed, we return normally from closure:\n              return /*void*/ null;\n            } else {\n              // anything else in stack trace is not allowed, break and throw SecurityException below:\n              break;\n            }\n          }\n        }\n        \n        if (exitMethodHit == null) {\n          // should never happen, only if JVM hides stack trace - replace by generic:\n          exitMethodHit = \"JVM exit method\";\n        }\n        throw new SecurityException(exitMethodHit + \" calls are not allowed because they terminate the test runner's JVM.\");\n      }\n    });\n    \n    // we passed the stack check, delegate to super, so default policy can still deny permission:\n    super.checkExit(status);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":["7cdec01452b1db9ca43a8369377730a2dcb63658","05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d"],"4a56dc0645edef934cc1ce27e59c4c4aecc853f3":["18618b2abb825aeab9e0242fbbc3dd799da1739b"],"05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d":["038e032723ac44742041643ba792d5d2a592c4f7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"038e032723ac44742041643ba792d5d2a592c4f7":["4a56dc0645edef934cc1ce27e59c4c4aecc853f3"],"18618b2abb825aeab9e0242fbbc3dd799da1739b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7cdec01452b1db9ca43a8369377730a2dcb63658":["4a56dc0645edef934cc1ce27e59c4c4aecc853f3","038e032723ac44742041643ba792d5d2a592c4f7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d"]},"commit2Childs":{"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":[],"4a56dc0645edef934cc1ce27e59c4c4aecc853f3":["038e032723ac44742041643ba792d5d2a592c4f7","7cdec01452b1db9ca43a8369377730a2dcb63658"],"05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["18618b2abb825aeab9e0242fbbc3dd799da1739b"],"038e032723ac44742041643ba792d5d2a592c4f7":["05fd4b648a0bc8fd904b4e43914ae7cfa5f5226d","7cdec01452b1db9ca43a8369377730a2dcb63658"],"18618b2abb825aeab9e0242fbbc3dd799da1739b":["4a56dc0645edef934cc1ce27e59c4c4aecc853f3"],"7cdec01452b1db9ca43a8369377730a2dcb63658":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}