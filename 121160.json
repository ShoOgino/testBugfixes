{"path":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","commits":[{"id":"069d686c3ab4d51d0d217cff30aad53b2b70ece0","date":1484748426,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"/dev/null","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[0], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[0], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"/dev/null","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[0], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[0], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abaa6869d9a2c89d73cec577c32ad639b1cf194f","date":1484755166,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[dim], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[dim], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[0], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[0], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2a31e0fc759eb44faad7a1421dccebcfd10e391","date":1485162499,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (StringHelper.compare(3, uniquePointValue[dim], 0, maxPackedValue, dim * 3) > 0 ||\n                StringHelper.compare(3, uniquePointValue[dim], 0, minPackedValue, dim * 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[dim], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[dim], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (StringHelper.compare(3, uniquePointValue[dim], 0, maxPackedValue, dim * 3) > 0 ||\n                StringHelper.compare(3, uniquePointValue[dim], 0, minPackedValue, dim * 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    assertEquals((actualMaxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            for (int dim = 0; dim < 2; ++dim) {\n              if (StringHelper.compare(3, uniquePointValue[0], 0, maxPackedValue, dim * 3) > 0 ||\n                  StringHelper.compare(3, uniquePointValue[0], 0, minPackedValue, dim * 3) < 0) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              }\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (FutureArrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n                FutureArrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (StringHelper.compare(3, uniquePointValue[dim], 0, maxPackedValue, dim * 3) > 0 ||\n                StringHelper.compare(3, uniquePointValue[dim], 0, minPackedValue, dim * 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (FutureArrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n                FutureArrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","date":1570176835,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1;\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["069d686c3ab4d51d0d217cff30aad53b2b70ece0","d2a31e0fc759eb44faad7a1421dccebcfd10e391","b88a121b875f9ae2ac50f85cf46dcb680f126357"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1;\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue[0]);\n          random().nextBytes(pointValue[1]);\n        } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    int actualMaxPointsInLeafNode = numDocs;\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = Integer.highestOneBit((numDocs - 1) / actualMaxPointsInLeafNode) << 1;\n    assertEquals(numLeaves * actualMaxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {}\n        \n        @Override\n        public void visit(int docID) throws IOException {}\n        \n        @Override\n        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          for (int dim = 0; dim < 2; ++dim) {\n            if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n          }\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1;\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1;\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d1b1f6bc8b7827c951e135141bea776bf57ac7e","date":1580115145,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.max(Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1, 1);\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1;\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f1c6da9c5bfcffd31d9cf0653f0c4c358548b2","date":1586248875,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.max(Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1, 1);\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (actualMaxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.max(Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1, 1);\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n    // If only one point matches, then the point count is (actualMaxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (actualMaxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((actualMaxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7","date":1588412059,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (maxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // With >1 dims, the tree is balanced\n    long actualMaxPointsInLeafNode = points.size();\n    while (actualMaxPointsInLeafNode > maxPointsInLeafNode) {\n      actualMaxPointsInLeafNode = (actualMaxPointsInLeafNode + 1) / 2;\n    }\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.max(Long.highestOneBit( ((points.size() - 1) / actualMaxPointsInLeafNode)) << 1, 1);\n\n    assertEquals(numLeaves * actualMaxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (actualMaxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (maxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (maxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":6,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene86/TestLucene86PointsFormat#testEstimatePointCount2Dims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount2Dims().mjava","sourceNew":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (maxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // The tree is always balanced in the N dims case, and leaves are\n  // not all full so things are a bit different\n  public void testEstimatePointCount2Dims() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[][] pointValue = new byte[2][];\n    pointValue[0] = new byte[3];\n    pointValue[1] = new byte[3];\n    byte[][] uniquePointValue = new byte[2][];\n    uniquePointValue[0] = new byte[3];\n    uniquePointValue[1] = new byte[3];\n    random().nextBytes(uniquePointValue[0]);\n    random().nextBytes(uniquePointValue[1]);\n    final int numDocs = TEST_NIGHTLY? atLeast(10000) : atLeast(1000); // in nightly, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue[0]);\n            random().nextBytes(pointValue[1]);\n          } while (Arrays.equals(pointValue[0], uniquePointValue[0]) || Arrays.equals(pointValue[1], uniquePointValue[1]));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        for (int dim = 0; dim < 2; ++dim) {\n          if (Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, maxPackedValue, dim * 3, dim * 3 + 3) > 0 ||\n              Arrays.compareUnsigned(uniquePointValue[dim], 0, 3, minPackedValue, dim * 3, dim * 3 + 3) < 0) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    // The number of matches needs to be multiple of count per leaf\n    final long countPerLeaf = (maxPointsInLeafNode + 1) / 2;\n    assertTrue(\"\"+pointCount, pointCount % countPerLeaf == 0);\n    // in extreme cases, a point can be be shared by 4 leaves\n    assertTrue(\"\"+pointCount, pointCount / countPerLeaf <= 4 && pointCount / countPerLeaf >= 1);\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d2a31e0fc759eb44faad7a1421dccebcfd10e391":["abaa6869d9a2c89d73cec577c32ad639b1cf194f"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"abaa6869d9a2c89d73cec577c32ad639b1cf194f":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"25f1c6da9c5bfcffd31d9cf0653f0c4c358548b2":["0d1b1f6bc8b7827c951e135141bea776bf57ac7e"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["302d34f2c66e8d489ee13078305c330cbf67b226","d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"302d34f2c66e8d489ee13078305c330cbf67b226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"0d1b1f6bc8b7827c951e135141bea776bf57ac7e":["71da933d30aea361ccc224d6544c451cbf49916d"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["25f1c6da9c5bfcffd31d9cf0653f0c4c358548b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"71da933d30aea361ccc224d6544c451cbf49916d":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b88a121b875f9ae2ac50f85cf46dcb680f126357","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"]},"commit2Childs":{"d2a31e0fc759eb44faad7a1421dccebcfd10e391":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","41f60ea1802fda42d3c91d023406066d00ddb5f8"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["abaa6869d9a2c89d73cec577c32ad639b1cf194f","302d34f2c66e8d489ee13078305c330cbf67b226"],"abaa6869d9a2c89d73cec577c32ad639b1cf194f":["d2a31e0fc759eb44faad7a1421dccebcfd10e391"],"25f1c6da9c5bfcffd31d9cf0653f0c4c358548b2":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"302d34f2c66e8d489ee13078305c330cbf67b226":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","b0b597c65628ca9e73913a07e81691f8229bae35"],"0d1b1f6bc8b7827c951e135141bea776bf57ac7e":["25f1c6da9c5bfcffd31d9cf0653f0c4c358548b2"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["069d686c3ab4d51d0d217cff30aad53b2b70ece0","302d34f2c66e8d489ee13078305c330cbf67b226"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"71da933d30aea361ccc224d6544c451cbf49916d":["0d1b1f6bc8b7827c951e135141bea776bf57ac7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["71da933d30aea361ccc224d6544c451cbf49916d","b0b597c65628ca9e73913a07e81691f8229bae35"],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}