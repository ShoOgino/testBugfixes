{"path":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","commits":[{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \" +\n            \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\"\n            , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      }\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \" +\n            \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\"\n            , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      }\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b73e9c1914a76cfa16576e9d7165e286cc35c36e","date":1593099382,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);\n\n    validateMemoryBreakerThreshold();\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c24f8f07a3e4a885c0e19286d51575df197a611b","date":1593281672,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);\n\n    validateMemoryBreakerThreshold();\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ef8e4fae9bcd156a117f5758819aeabdae3e963","date":1593674028,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 95);\n\n    validateMemoryBreakerThreshold();\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c38d3299f414132db022cec9d60b2dafc244a7c3","date":1597046674,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 95);\n\n    validateMemoryBreakerThreshold();\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 95);\n\n    validateMemoryBreakerThreshold();\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a761febaf4b3c09d4490395eb90617263016fc2a","date":1597909886,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreakers/@enabled\", false);\n    cpuCBEnabled = getBool(\"circuitBreakers/cpuBreaker/@enabled\", false);\n    memCBEnabled = getBool(\"circuitBreakers/memBreaker/@enabled\", false);\n    memCBThreshold = getInt(\"circuitBreakers/memBreaker/@threshold\", 95);\n    cpuCBThreshold = getInt(\"circuitBreakers/cpuBreaker/@threshold\", 95);\n\n    validateCircuitBreakerThresholds();\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 95);\n\n    validateMemoryBreakerThreshold();\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ef286034ca1be064a363aaec38e34e64a59154c","date":1598517382,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} {}\"\n          , booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount()\n          , \"and will have no effect set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    useCircuitBreakers = getBool(\"circuitBreakers/@enabled\", false);\n    cpuCBEnabled = getBool(\"circuitBreakers/cpuBreaker/@enabled\", false);\n    memCBEnabled = getBool(\"circuitBreakers/memBreaker/@enabled\", false);\n    memCBThreshold = getInt(\"circuitBreakers/memBreaker/@threshold\", 95);\n    cpuCBThreshold = getInt(\"circuitBreakers/cpuBreaker/@threshold\", 95);\n\n    validateCircuitBreakerThresholds();\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c24f8f07a3e4a885c0e19286d51575df197a611b":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"0ef286034ca1be064a363aaec38e34e64a59154c":["a761febaf4b3c09d4490395eb90617263016fc2a"],"c38d3299f414132db022cec9d60b2dafc244a7c3":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"140be51d03394488536f4aacedace29f9b318347":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["575e66bd4b2349209027f6801184da7fc3cba13f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["140be51d03394488536f4aacedace29f9b318347"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0ef286034ca1be064a363aaec38e34e64a59154c"],"a761febaf4b3c09d4490395eb90617263016fc2a":["c38d3299f414132db022cec9d60b2dafc244a7c3"]},"commit2Childs":{"c24f8f07a3e4a885c0e19286d51575df197a611b":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"0ef286034ca1be064a363aaec38e34e64a59154c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c38d3299f414132db022cec9d60b2dafc244a7c3":["a761febaf4b3c09d4490395eb90617263016fc2a"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["140be51d03394488536f4aacedace29f9b318347"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"140be51d03394488536f4aacedace29f9b318347":["575e66bd4b2349209027f6801184da7fc3cba13f"],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"575e66bd4b2349209027f6801184da7fc3cba13f":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["c38d3299f414132db022cec9d60b2dafc244a7c3"],"a761febaf4b3c09d4490395eb90617263016fc2a":["0ef286034ca1be064a363aaec38e34e64a59154c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}