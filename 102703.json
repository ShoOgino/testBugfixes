{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","commits":[{"id":"12ce9a95ee9b66c59103cc6016c0758c792d1b78","date":1359122086,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","sourceNew":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput, HashTable)}, this method\n   * is slower and uses more memory (~ 256KB per thread) but should provide\n   * better compression ratios (especially on large inputs) because it chooses\n   * the best match among up to 256 candidates and then performs trade-offs to\n   * fix overlapping matches. <code>ht</code> shouldn't be shared across threads\n   * but can safely be reused.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    ht.reset(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput)}, this method is slower,\n   * uses more memory (~ 256KB), but should provide better compression ratios\n   * (especially on large inputs) because it chooses the best match among up to\n   * 256 candidates and then performs trade-offs to fix overlapping matches.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","sourceNew":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput, HashTable)}, this method\n   * is slower and uses more memory (~ 256KB per thread) but should provide\n   * better compression ratios (especially on large inputs) because it chooses\n   * the best match among up to 256 candidates and then performs trade-offs to\n   * fix overlapping matches. <code>ht</code> shouldn't be shared across threads\n   * but can safely be reused.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    ht.reset(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput)}, this method is slower,\n   * uses more memory (~ 256KB), but should provide better compression ratios\n   * (especially on large inputs) because it chooses the best match among up to\n   * 256 candidates and then performs trade-offs to fix overlapping matches.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b45f1d4d3fa719ae1898e9753cc6b0f30cd4022a","date":1378311096,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","sourceNew":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput, HashTable)}, this method\n   * is slower and uses more memory (~ 256KB per thread) but should provide\n   * better compression ratios (especially on large inputs) because it chooses\n   * the best match among up to 256 candidates and then performs trade-offs to\n   * fix overlapping matches. <code>ht</code> shouldn't be shared across threads\n   * but can safely be reused.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n    final int mfLimit = matchLimit - MIN_MATCH;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    ht.reset(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff <= mfLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= mfLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= mfLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              match1.len = match2.start - match1.start;\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput, HashTable)}, this method\n   * is slower and uses more memory (~ 256KB per thread) but should provide\n   * better compression ratios (especially on large inputs) because it chooses\n   * the best match among up to 256 candidates and then performs trade-offs to\n   * fix overlapping matches. <code>ht</code> shouldn't be shared across threads\n   * but can safely be reused.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    ht.reset(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput,HCHashTable).mjava","sourceNew":null,"sourceOld":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput, HashTable)}, this method\n   * is slower and uses more memory (~ 256KB per thread) but should provide\n   * better compression ratios (especially on large inputs) because it chooses\n   * the best match among up to 256 candidates and then performs trade-offs to\n   * fix overlapping matches. <code>ht</code> shouldn't be shared across threads\n   * but can safely be reused.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n    final int mfLimit = matchLimit - MIN_MATCH;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    ht.reset(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff <= mfLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= mfLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= mfLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              match1.len = match2.start - match1.start;\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"12ce9a95ee9b66c59103cc6016c0758c792d1b78":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9407318969e8504257b4c5764c65755a043e5404":["b45f1d4d3fa719ae1898e9753cc6b0f30cd4022a"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","12ce9a95ee9b66c59103cc6016c0758c792d1b78"],"b45f1d4d3fa719ae1898e9753cc6b0f30cd4022a":["12ce9a95ee9b66c59103cc6016c0758c792d1b78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9407318969e8504257b4c5764c65755a043e5404"]},"commit2Childs":{"12ce9a95ee9b66c59103cc6016c0758c792d1b78":["dd45d4a2ee01a1932d33eec42f5272c2402da679","b45f1d4d3fa719ae1898e9753cc6b0f30cd4022a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["12ce9a95ee9b66c59103cc6016c0758c792d1b78","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"9407318969e8504257b4c5764c65755a043e5404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"b45f1d4d3fa719ae1898e9753cc6b0f30cd4022a":["9407318969e8504257b4c5764c65755a043e5404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}