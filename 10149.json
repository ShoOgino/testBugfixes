{"path":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext],SpanCollector).mjava","commits":[{"id":"2d530e71ed32ab23b34ca3fc72b080a554a40404","date":1432026158,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext],SpanCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts, SpanCollector collector)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts, collector);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public void collect(SpanCollector collector) throws IOException {\n        if (topPositionSpans != null)\n          topPositionSpans.collect(collector);\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        return topPositionSpans == null\n                ? null\n                : topPositionSpans.isPayloadAvailable()\n                ? new ArrayList<>(topPositionSpans.getPayload())\n                : null;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c257cd8ddb1ed5632a36c7488614a2ee21705d24","date":1432128550,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext],SpanCollector).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts, SpanCollector collector)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts, collector);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public void collect(SpanCollector collector) throws IOException {\n        if (topPositionSpans != null)\n          topPositionSpans.collect(collector);\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c257cd8ddb1ed5632a36c7488614a2ee21705d24":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c257cd8ddb1ed5632a36c7488614a2ee21705d24"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["c257cd8ddb1ed5632a36c7488614a2ee21705d24"],"c257cd8ddb1ed5632a36c7488614a2ee21705d24":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}