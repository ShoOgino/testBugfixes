{"path":"lucene/core/src/test/org/apache/lucene/util/TestMergedIterator#testCase(int,int,boolean).mjava","commits":[{"id":"050e6201c3a7d4c351ebc06cbe4822e26e028117","date":1382375603,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestMergedIterator#testCase(int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void testCase(int itrsWithVal, int specifiedValsOnItr, boolean removeDups) {\n    // Build a random number of lists\n    List<Integer> expected = new ArrayList<Integer>();\n    Random random = new Random(random().nextLong());\n    int numLists = itrsWithVal + random.nextInt(1000 - itrsWithVal);\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    List<Integer>[] lists = new List[numLists];\n    for (int i = 0; i < numLists; i++) {\n      lists[i] = new ArrayList<Integer>();\n    }\n    int start = random.nextInt(1000000);\n    int end = start + VALS_TO_MERGE / itrsWithVal / Math.abs(specifiedValsOnItr);\n    for (int i = start; i < end; i++) {\n      int maxList = lists.length;\n      int maxValsOnItr = 0;\n      int sumValsOnItr = 0;\n      for (int itrWithVal = 0; itrWithVal < itrsWithVal; itrWithVal++) {\n        int list = random.nextInt(maxList);\n        int valsOnItr = specifiedValsOnItr < 0 ? (1 + random.nextInt(-specifiedValsOnItr)) : specifiedValsOnItr;\n        maxValsOnItr = Math.max(maxValsOnItr, valsOnItr);\n        sumValsOnItr += valsOnItr;\n        for (int valOnItr = 0; valOnItr < valsOnItr; valOnItr++) {\n          lists[list].add(i);\n        }\n        maxList = maxList - 1;\n        ArrayUtil.swap(lists, list, maxList);\n      }\n      int maxCount = removeDups ? maxValsOnItr : sumValsOnItr;\n      for (int count = 0; count < maxCount; count++) {\n        expected.add(i);\n      }\n    }\n    // Now check that they get merged cleanly\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Iterator<Integer>[] itrs = new Iterator[numLists];\n    for (int i = 0; i < numLists; i++) {\n      itrs[i] = lists[i].iterator();\n    }\n    \n    MergedIterator<Integer> mergedItr = new MergedIterator<Integer>(removeDups, itrs);\n    Iterator<Integer> expectedItr = expected.iterator();\n    while (expectedItr.hasNext()) {\n      assertTrue(mergedItr.hasNext());\n      assertEquals(expectedItr.next(), mergedItr.next()); \n    }\n    assertFalse(mergedItr.hasNext());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestMergedIterator#testCase(int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestMergedIterator#testCase(int,int,boolean).mjava","sourceNew":"  private void testCase(int itrsWithVal, int specifiedValsOnItr, boolean removeDups) {\n    // Build a random number of lists\n    List<Integer> expected = new ArrayList<>();\n    Random random = new Random(random().nextLong());\n    int numLists = itrsWithVal + random.nextInt(1000 - itrsWithVal);\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    List<Integer>[] lists = new List[numLists];\n    for (int i = 0; i < numLists; i++) {\n      lists[i] = new ArrayList<>();\n    }\n    int start = random.nextInt(1000000);\n    int end = start + VALS_TO_MERGE / itrsWithVal / Math.abs(specifiedValsOnItr);\n    for (int i = start; i < end; i++) {\n      int maxList = lists.length;\n      int maxValsOnItr = 0;\n      int sumValsOnItr = 0;\n      for (int itrWithVal = 0; itrWithVal < itrsWithVal; itrWithVal++) {\n        int list = random.nextInt(maxList);\n        int valsOnItr = specifiedValsOnItr < 0 ? (1 + random.nextInt(-specifiedValsOnItr)) : specifiedValsOnItr;\n        maxValsOnItr = Math.max(maxValsOnItr, valsOnItr);\n        sumValsOnItr += valsOnItr;\n        for (int valOnItr = 0; valOnItr < valsOnItr; valOnItr++) {\n          lists[list].add(i);\n        }\n        maxList = maxList - 1;\n        ArrayUtil.swap(lists, list, maxList);\n      }\n      int maxCount = removeDups ? maxValsOnItr : sumValsOnItr;\n      for (int count = 0; count < maxCount; count++) {\n        expected.add(i);\n      }\n    }\n    // Now check that they get merged cleanly\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Iterator<Integer>[] itrs = new Iterator[numLists];\n    for (int i = 0; i < numLists; i++) {\n      itrs[i] = lists[i].iterator();\n    }\n    \n    MergedIterator<Integer> mergedItr = new MergedIterator<>(removeDups, itrs);\n    Iterator<Integer> expectedItr = expected.iterator();\n    while (expectedItr.hasNext()) {\n      assertTrue(mergedItr.hasNext());\n      assertEquals(expectedItr.next(), mergedItr.next()); \n    }\n    assertFalse(mergedItr.hasNext());\n  }\n\n","sourceOld":"  private void testCase(int itrsWithVal, int specifiedValsOnItr, boolean removeDups) {\n    // Build a random number of lists\n    List<Integer> expected = new ArrayList<Integer>();\n    Random random = new Random(random().nextLong());\n    int numLists = itrsWithVal + random.nextInt(1000 - itrsWithVal);\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    List<Integer>[] lists = new List[numLists];\n    for (int i = 0; i < numLists; i++) {\n      lists[i] = new ArrayList<Integer>();\n    }\n    int start = random.nextInt(1000000);\n    int end = start + VALS_TO_MERGE / itrsWithVal / Math.abs(specifiedValsOnItr);\n    for (int i = start; i < end; i++) {\n      int maxList = lists.length;\n      int maxValsOnItr = 0;\n      int sumValsOnItr = 0;\n      for (int itrWithVal = 0; itrWithVal < itrsWithVal; itrWithVal++) {\n        int list = random.nextInt(maxList);\n        int valsOnItr = specifiedValsOnItr < 0 ? (1 + random.nextInt(-specifiedValsOnItr)) : specifiedValsOnItr;\n        maxValsOnItr = Math.max(maxValsOnItr, valsOnItr);\n        sumValsOnItr += valsOnItr;\n        for (int valOnItr = 0; valOnItr < valsOnItr; valOnItr++) {\n          lists[list].add(i);\n        }\n        maxList = maxList - 1;\n        ArrayUtil.swap(lists, list, maxList);\n      }\n      int maxCount = removeDups ? maxValsOnItr : sumValsOnItr;\n      for (int count = 0; count < maxCount; count++) {\n        expected.add(i);\n      }\n    }\n    // Now check that they get merged cleanly\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Iterator<Integer>[] itrs = new Iterator[numLists];\n    for (int i = 0; i < numLists; i++) {\n      itrs[i] = lists[i].iterator();\n    }\n    \n    MergedIterator<Integer> mergedItr = new MergedIterator<Integer>(removeDups, itrs);\n    Iterator<Integer> expectedItr = expected.iterator();\n    while (expectedItr.hasNext()) {\n      assertTrue(mergedItr.hasNext());\n      assertEquals(expectedItr.next(), mergedItr.next()); \n    }\n    assertFalse(mergedItr.hasNext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["050e6201c3a7d4c351ebc06cbe4822e26e028117"],"050e6201c3a7d4c351ebc06cbe4822e26e028117":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"050e6201c3a7d4c351ebc06cbe4822e26e028117":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["050e6201c3a7d4c351ebc06cbe4822e26e028117"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}