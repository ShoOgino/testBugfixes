{"path":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","commits":[{"id":"1eee4175312c41f89aa23427f9e4edfc00deeaac","date":1446373190,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    //System.out.println(\"DIR: \" + ((FSDirectory) dir).getDirectory());\n\n    //IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));  \n    IndexWriterConfig iwc = newIndexWriterConfig();\n    //iwc.setUseCompoundFile(false);\n    //iwc.getMergePolicy().setNoCFSRatio(0.0);\n    iwc.setCodec(new SimpleTextCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            w.addDocument(doc);\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          w.addDocument(new Document());\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          w.addDocument(xdoc);\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      //System.out.println(\"TEST: r=\" + r);\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecf331f9d7bdd234863d2df2bb5c1f019979422f","date":1452250335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = dimValues.getMinPackedValue(\"field\");\n      byte[] maxValues = dimValues.getMaxPackedValue(\"field\");\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      PointValues dimValues = MultiPointValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = dimValues.getMinPackedValue(\"field\");\n      byte[] maxValues = dimValues.getMaxPackedValue(\"field\");\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n    iwc.setCodec(getCodec());\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed dimensional values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      iwc.setCodec(getCodec());\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new DimensionalBinaryField(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n      if (VERBOSE) {\n        System.out.println(\"  dimValues=\" + dimValues);\n      }\n      assertNotNull(dimValues);\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = dimValues.getMinPackedValue(\"field\");\n      byte[] maxValues = dimValues.getMaxPackedValue(\"field\");\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, scratch.length);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        dimValues.intersect(\"field\", new DimensionalValues.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              if (liveDocs == null || liveDocs.get(docID)) {\n                hits.set((int) idValues.get(docID));\n              }\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              if (liveDocs != null && liveDocs.get(docID) == false) {\n                return;\n              }\n              //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n              for(int dim=0;dim<numDims;dim++) {\n                //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set((int) idValues.get(docID));\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              //System.out.println(\"compare\");\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  query_outside_cell\");\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                //System.out.println(\"  query_crosses_cell\");\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                //System.out.println(\"  cell_inside_query\");\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"770342641f7b505eaa8dccdc666158bff2419109":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}