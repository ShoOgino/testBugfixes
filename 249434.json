{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceSliceUnique(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"64707d25b6352cf02909d3916038a3b3cec7f0a8","date":1412782122,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceSliceUnique(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private void handleBalanceSliceUnique(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP, PROPERTY_PROP);\n    Boolean sliceUnique = Boolean.parseBoolean(req.getParams().get(SLICE_UNIQUE));\n    String prop = req.getParams().get(PROPERTY_PROP).toLowerCase(Locale.ROOT);\n    if (StringUtils.startsWith(prop, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n      prop = OverseerCollectionProcessor.COLL_PROP_PREFIX + prop;\n    }\n\n    if (sliceUnique == false &&\n        Overseer.sliceUniqueBooleanProperties.contains(prop) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n      + \" the property be pre-defined as a unique property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true'. \" +\n      \" Property: \" + prop + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n    }\n\n    Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, BALANCESLICEUNIQUE.toLower());\n    copyIfNotNull(req.getParams(), map, COLLECTION_PROP, PROPERTY_PROP, ONLY_ACTIVE_NODES, SLICE_UNIQUE);\n\n    handleResponse(BALANCESLICEUNIQUE.toLower(), new ZkNodeProps(map), rsp);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceSliceUnique(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private void handleBalanceSliceUnique(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP, PROPERTY_PROP);\n    Boolean sliceUnique = Boolean.parseBoolean(req.getParams().get(SLICE_UNIQUE));\n    String prop = req.getParams().get(PROPERTY_PROP).toLowerCase(Locale.ROOT);\n    if (StringUtils.startsWith(prop, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n      prop = OverseerCollectionProcessor.COLL_PROP_PREFIX + prop;\n    }\n\n    if (sliceUnique == false &&\n        Overseer.sliceUniqueBooleanProperties.contains(prop) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n      + \" the property be pre-defined as a unique property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true'. \" +\n      \" Property: \" + prop + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n    }\n\n    Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, BALANCESLICEUNIQUE.toLower());\n    copyIfNotNull(req.getParams(), map, COLLECTION_PROP, PROPERTY_PROP, ONLY_ACTIVE_NODES, SLICE_UNIQUE);\n\n    handleResponse(BALANCESLICEUNIQUE.toLower(), new ZkNodeProps(map), rsp);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfb61c9baefa8681e40fca3c803f61bf485a9d8d","date":1414979559,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceShardUnique(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceSliceUnique(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void handleBalanceShardUnique(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP, PROPERTY_PROP);\n    Boolean shardUnique = Boolean.parseBoolean(req.getParams().get(SHARD_UNIQUE));\n    String prop = req.getParams().get(PROPERTY_PROP).toLowerCase(Locale.ROOT);\n    if (StringUtils.startsWith(prop, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n      prop = OverseerCollectionProcessor.COLL_PROP_PREFIX + prop;\n    }\n\n    if (shardUnique == false &&\n        Overseer.sliceUniqueBooleanProperties.contains(prop) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n      + \" the property be pre-defined as a unique property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true'. \" +\n      \" Property: \" + prop + \" shardUnique: \" + Boolean.toString(shardUnique));\n    }\n\n    Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, BALANCESHARDUNIQUE.toLower());\n    copyIfNotNull(req.getParams(), map, COLLECTION_PROP, PROPERTY_PROP, ONLY_ACTIVE_NODES, SHARD_UNIQUE);\n\n    handleResponse(BALANCESHARDUNIQUE.toLower(), new ZkNodeProps(map), rsp);\n  }\n\n","sourceOld":"  private void handleBalanceSliceUnique(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP, PROPERTY_PROP);\n    Boolean sliceUnique = Boolean.parseBoolean(req.getParams().get(SLICE_UNIQUE));\n    String prop = req.getParams().get(PROPERTY_PROP).toLowerCase(Locale.ROOT);\n    if (StringUtils.startsWith(prop, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n      prop = OverseerCollectionProcessor.COLL_PROP_PREFIX + prop;\n    }\n\n    if (sliceUnique == false &&\n        Overseer.sliceUniqueBooleanProperties.contains(prop) == false) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n      + \" the property be pre-defined as a unique property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true'. \" +\n      \" Property: \" + prop + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n    }\n\n    Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, BALANCESLICEUNIQUE.toLower());\n    copyIfNotNull(req.getParams(), map, COLLECTION_PROP, PROPERTY_PROP, ONLY_ACTIVE_NODES, SLICE_UNIQUE);\n\n    handleResponse(BALANCESLICEUNIQUE.toLower(), new ZkNodeProps(map), rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"cfb61c9baefa8681e40fca3c803f61bf485a9d8d":["64707d25b6352cf02909d3916038a3b3cec7f0a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfb61c9baefa8681e40fca3c803f61bf485a9d8d"]},"commit2Childs":{"55980207f1977bd1463465de1659b821347e2fa8":[],"cfb61c9baefa8681e40fca3c803f61bf485a9d8d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["55980207f1977bd1463465de1659b821347e2fa8","cfb61c9baefa8681e40fca3c803f61bf485a9d8d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}