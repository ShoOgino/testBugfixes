{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","commits":[{"id":"baa23b5db56be939827f4340a4c7cfd3bcb8088c","date":1381177715,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["527cc14542789f47d75da436cb4287d1ab887e34","05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"527cc14542789f47d75da436cb4287d1ab887e34","date":1391705548,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":["baa23b5db56be939827f4340a4c7cfd3bcb8088c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e2fb55c0777755badd3b46d8140f3d4301febed","date":1398881584,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      try {\n        writer.getReader().close();\n      } catch (FakeIOException e) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"hit expected fake IOE\");\n        }\n      }\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":["baa23b5db56be939827f4340a4c7cfd3bcb8088c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        if (shouldFail.get()) {\n          if (callStackContainsAnyOf(\"getReadOnlyClone\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            shouldFail.set(false);\n            throw new FakeIOException();\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        if (shouldFail.get()) {\n          if (callStackContainsAnyOf(\"getReadOnlyClone\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            shouldFail.set(false);\n            throw new FakeIOException();\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        if (shouldFail.get()) {\n          for (int i = 0; i < trace.length; i++) {\n            if (\"getReadOnlyClone\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              shouldFail.set(false);\n              throw new FakeIOException();\n            }\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader#testNRTOpenExceptions().mjava","sourceNew":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        if (shouldFail.get()) {\n          if (callStackContainsAnyOf(\"getReadOnlyClone\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            shouldFail.set(false);\n            throw new FakeIOException();\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random())).setMaxFullFlushMergeWaitMillis(0);\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testNRTOpenExceptions() throws Exception {\n    // LUCENE-5262: test that several failed attempts to obtain an NRT reader\n    // don't leak file handles.\n    MockDirectoryWrapper dir = (MockDirectoryWrapper) getAssertNoDeletesDirectory(newMockDirectory());\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n      @Override\n      public void eval(MockDirectoryWrapper dir) throws IOException {\n        if (shouldFail.get()) {\n          if (callStackContainsAnyOf(\"getReadOnlyClone\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            shouldFail.set(false);\n            throw new FakeIOException();\n          }\n        }\n      }\n    });\n    \n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.INSTANCE); // prevent merges from getting in the way\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // create a segment and open an NRT reader\n    writer.addDocument(new Document());\n    writer.getReader().close();\n    \n    // add a new document so a new NRT reader is required\n    writer.addDocument(new Document());\n\n    // try to obtain an NRT reader twice: first time it fails and closes all the\n    // other NRT readers. second time it fails, but also fails to close the\n    // other NRT reader, since it is already marked closed!\n    for (int i = 0; i < 2; i++) {\n      shouldFail.set(true);\n      expectThrows(FakeIOException.class, () -> {\n        writer.getReader().close();\n      });\n    }\n    \n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2fb55c0777755badd3b46d8140f3d4301febed":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"527cc14542789f47d75da436cb4287d1ab887e34":["baa23b5db56be939827f4340a4c7cfd3bcb8088c"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["7e2fb55c0777755badd3b46d8140f3d4301febed"],"baa23b5db56be939827f4340a4c7cfd3bcb8088c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05fe562aa248790944d43cdd478f512572835ba0":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["05fe562aa248790944d43cdd478f512572835ba0"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["527cc14542789f47d75da436cb4287d1ab887e34"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["2916966cc9815e973c01452a0d76c98c5e0d0926"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["05fe562aa248790944d43cdd478f512572835ba0","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"7e2fb55c0777755badd3b46d8140f3d4301febed":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"527cc14542789f47d75da436cb4287d1ab887e34":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"baa23b5db56be939827f4340a4c7cfd3bcb8088c":["527cc14542789f47d75da436cb4287d1ab887e34"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["baa23b5db56be939827f4340a4c7cfd3bcb8088c"],"05fe562aa248790944d43cdd478f512572835ba0":["2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["05fe562aa248790944d43cdd478f512572835ba0"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["7e2fb55c0777755badd3b46d8140f3d4301febed"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["3f354ba79a5a3e8491ec2953f14f365a02c058ac","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}