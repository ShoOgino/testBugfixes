{"path":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","sourceNew":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Sun JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED)\n      throw new IllegalArgumentException(\"Unmap hack not supported on this platform!\");\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","sourceOld":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Sun JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED)\n      throw new IllegalArgumentException(\"Unmap hack not supported on this platform!\");\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb6c879a87683d96d7dee96cdded91f47f462412","date":1455562659,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","sourceNew":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Sun JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","sourceOld":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Sun JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED)\n      throw new IllegalArgumentException(\"Unmap hack not supported on this platform!\");\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aa165418ba5bc2b7ce31a080a36d56953cc4a13","date":1455577726,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","sourceNew":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Oracle/OpenJDK JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * <p>To enable the hack, the following requirements need to be\n   * fulfilled: The used JVM must be Oracle Java / OpenJDK 8\n   * <em>(preliminary support for Java 9 was added with Lucene 6)</em>.\n   * In addition, the following permissions need to be granted\n   * to {@code lucene-core.jar} in your\n   * <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\">policy file</a>:\n   * <ul>\n   * <li>{@code permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.sun.misc\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.ref\";}</li>\n   * </ul>\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   * The exception message also contains an explanation why the hack\n   * cannot be enabled (e.g., missing permissions).\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","sourceOld":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Sun JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2613a05c615dab2b84745ce1983d2f053fdb4358","date":1482346162,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","sourceNew":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Oracle/OpenJDK JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * <p>To enable the hack, the following requirements need to be\n   * fulfilled: The used JVM must be Oracle Java / OpenJDK 8\n   * <em>(preliminary support for Java 9 EA build 150+ was added with Lucene 6.4)</em>.\n   * In addition, the following permissions need to be granted\n   * to {@code lucene-core.jar} in your\n   * <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\">policy file</a>:\n   * <ul>\n   * <li>{@code permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.sun.misc\";}</li>\n   * </ul>\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   * The exception message also contains an explanation why the hack\n   * cannot be enabled (e.g., missing permissions).\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","sourceOld":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Oracle/OpenJDK JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * <p>To enable the hack, the following requirements need to be\n   * fulfilled: The used JVM must be Oracle Java / OpenJDK 8\n   * <em>(preliminary support for Java 9 was added with Lucene 6)</em>.\n   * In addition, the following permissions need to be granted\n   * to {@code lucene-core.jar} in your\n   * <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\">policy file</a>:\n   * <ul>\n   * <li>{@code permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.sun.misc\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.ref\";}</li>\n   * </ul>\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   * The exception message also contains an explanation why the hack\n   * cannot be enabled (e.g., missing permissions).\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#setUseUnmap(boolean).mjava","sourceNew":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Oracle/OpenJDK JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * <p>To enable the hack, the following requirements need to be\n   * fulfilled: The used JVM must be Oracle Java / OpenJDK 8\n   * <em>(preliminary support for Java 9 EA build 150+ was added with Lucene 6.4)</em>.\n   * In addition, the following permissions need to be granted\n   * to {@code lucene-core.jar} in your\n   * <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\">policy file</a>:\n   * <ul>\n   * <li>{@code permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.sun.misc\";}</li>\n   * </ul>\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   * The exception message also contains an explanation why the hack\n   * cannot be enabled (e.g., missing permissions).\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","sourceOld":"  /**\n   * This method enables the workaround for unmapping the buffers\n   * from address space after closing {@link IndexInput}, that is\n   * mentioned in the bug report. This hack may fail on non-Oracle/OpenJDK JVMs.\n   * It forcefully unmaps the buffer on close by using\n   * an undocumented internal cleanup functionality.\n   * <p><b>NOTE:</b> Enabling this is completely unsupported\n   * by Java and may lead to JVM crashes if <code>IndexInput</code>\n   * is closed while another thread is still accessing it (SIGSEGV).\n   * <p>To enable the hack, the following requirements need to be\n   * fulfilled: The used JVM must be Oracle Java / OpenJDK 8\n   * <em>(preliminary support for Java 9 was added with Lucene 6)</em>.\n   * In addition, the following permissions need to be granted\n   * to {@code lucene-core.jar} in your\n   * <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html\">policy file</a>:\n   * <ul>\n   * <li>{@code permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.sun.misc\";}</li>\n   * <li>{@code permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.ref\";}</li>\n   * </ul>\n   * @throws IllegalArgumentException if {@link #UNMAP_SUPPORTED}\n   * is <code>false</code> and the workaround cannot be enabled.\n   * The exception message also contains an explanation why the hack\n   * cannot be enabled (e.g., missing permissions).\n   */\n  public void setUseUnmap(final boolean useUnmapHack) {\n    if (useUnmapHack && !UNMAP_SUPPORTED) {\n      throw new IllegalArgumentException(UNMAP_NOT_SUPPORTED_REASON);\n    }\n    this.useUnmapHack=useUnmapHack;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7aa165418ba5bc2b7ce31a080a36d56953cc4a13":["cb6c879a87683d96d7dee96cdded91f47f462412"],"cb6c879a87683d96d7dee96cdded91f47f462412":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2613a05c615dab2b84745ce1983d2f053fdb4358":["7aa165418ba5bc2b7ce31a080a36d56953cc4a13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2613a05c615dab2b84745ce1983d2f053fdb4358"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["7aa165418ba5bc2b7ce31a080a36d56953cc4a13","2613a05c615dab2b84745ce1983d2f053fdb4358"]},"commit2Childs":{"7aa165418ba5bc2b7ce31a080a36d56953cc4a13":["2613a05c615dab2b84745ce1983d2f053fdb4358","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cb6c879a87683d96d7dee96cdded91f47f462412":["7aa165418ba5bc2b7ce31a080a36d56953cc4a13"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cb6c879a87683d96d7dee96cdded91f47f462412"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2613a05c615dab2b84745ce1983d2f053fdb4358":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}