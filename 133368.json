{"path":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","commits":[{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedDate().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      SolrException e1 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.update(add( doc(\"id\",\"100\", field, BAD_VALUE))));\n      String msg1 = e1.getMessage();\n      assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg1,\n          400 <= e1.code() && e1.code() < 500);\n      assertTrue(\"(update) client error does not mention bad value: \" + msg1,\n          msg1.contains(BAD_VALUE));\n      assertTrue(\"client error does not mention document id: \" + msg1,\n          msg1.contains(\"[doc=100]\"));\n      SchemaField sf = h.getCore().getLatestSchema().getField(field);\n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      SolrException e2 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.query(req(\"q\",field + \":\" + BAD_VALUE))\n      );\n      String msg2 = e2.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg2,\n          400 <= e2.code() && e2.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg2,\n          msg2.contains(BAD_VALUE));\n\n      SolrException e3 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"))\n      );\n      String msg3 = e3.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg3,\n          400 <= e3.code() && e3.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg3,\n          msg3.contains(BAD_VALUE));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92f789dbd1886e4b468e61b0def88b29a3f55228":["28288370235ed02234a64753cdbf0c6ec096304a"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92f789dbd1886e4b468e61b0def88b29a3f55228"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}