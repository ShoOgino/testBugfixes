{"path":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#updateLatestCommit(List[IndexCommitWrapper]).mjava","commits":[{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#updateLatestCommit(List[IndexCommitWrapper]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Updates {@link #latestCommit}.\n   * <p>\n   * This is handled special, and not included in {@link #updateKnownCommitPoints}, because we need to \n   * ensure this happens <em>before</em> delegating calls to {@link #onInit} or {@link #onCommit} to our \n   * inner Policy.  Doing this ensures that we can always protect {@link #latestCommit} from being deleted.  \n   * </p>\n   * <p>\n   * If we did not do this, and waited to update <code>latestCommit</code> in \n   * <code>updateKnownCommitPoints()</code> then we would need to wrap synchronization completley around \n   * the (delegated) <code>onInit()</code> and <code>onCommit()</code> calls, to ensure there was no \n   * window of time when {@link #getAndSaveLatestCommit} might return the \"old\" latest commit, after our \n   * delegate Policy had already deleted it.\n   * </p>\n   * <p>\n   * (Since Saving/Reserving (other) commits is handled indirectly (\"by reference\") via the generation\n   * callers can still safely (try) to reserve \"old\" commits using an explicit generation since \n   * {@link IndexCommitWrapper#delete} is synchornized on <code>this</code>)\n   *\n   * @see #latestCommit\n   * @see #updateKnownCommitPoints\n   */\n  private synchronized void updateLatestCommit(final List<IndexCommitWrapper> list) {\n    // NOTE: There's a hypothetical, not neccessarily possible/plausible, situation that\n    // could lead to this combination of updateLatestCommit + updateKnownCommitPoints not\n    // being as thread safe as completley synchornizing in onInit/onCommit...\n    //  - knownCommits==(1, 2, 3, 4), latestCommit==4\n    //  - onCommit(1, 2, 3, 4, 5, 6, 7) - we immediately update latestCommit=7\n    //    - before knownCommits is updated, some client calls getAndSaveCommitPoint(6)\n    //      - call fails \"too old to be saved\" even though it's in flight\n    // (this assumes some future caller/use-case that doesn't currently exist)\n    //\n    // The upside of this current approach, and not completley synchornizing onInit/onCommit\n    // is that we have no control over what delegate is used, or how long those calls might take.\n    //\n    // If the hypotehtical situation above ever becomes problematic, then an alternative approach might be\n    // to *add* to the Set/Map of all known commits *before* delegating, then *remove* everything except\n    // the new (non-deleted) commits *after* delegating.\n\n    assert null != list;\n    if (list.isEmpty()) {\n      return;\n    }\n    final IndexCommitWrapper newLast = list.get(list.size() - 1);\n    assert ! newLast.isDeleted()\n      : \"Code flaw: Last commit already deleted, call this method before delegating onCommit/onInit\";\n\n    latestCommit = newLast.delegate;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"19f02bb04467ed179738a398a7da80bbbe161c16":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["19f02bb04467ed179738a398a7da80bbbe161c16"]},"commit2Childs":{"19f02bb04467ed179738a398a7da80bbbe161c16":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19f02bb04467ed179738a398a7da80bbbe161c16"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}