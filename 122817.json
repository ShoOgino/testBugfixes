{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetCells(Cell,Shape,int,boolean,boolean,List[Cell]).mjava","commits":[{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetCells(Cell,Shape,int,boolean,boolean,List[Cell]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetNodes(Node,Shape,int,boolean,boolean,List[Node]).mjava","sourceNew":"  /**\n   * Returns true if cell was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetCells(Cell cell, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Cell> result) {\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (inclParents && cell.getLevel() != 0)\n      result.add(cell);\n\n    Collection<Cell> subCells = cell.getSubCells(shape);\n    int leaves = 0;\n    for (Cell subCell : subCells) {\n      if (recursiveGetCells(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == cell.getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(cell);\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if node was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetNodes(Node node, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Node> result) {\n    if (node.getLevel() == detailLevel) {\n      node.setLeaf();//FYI might already be a leaf\n    }\n    if (node.isLeaf()) {\n      result.add(node);\n      return true;\n    }\n    if (inclParents && node.getLevel() != 0)\n      result.add(node);\n\n    Collection<Node> subCells = node.getSubCells(shape);\n    int leaves = 0;\n    for (Node subCell : subCells) {\n      if (recursiveGetNodes(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == node.getSubCellsSize() && node.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add node as the leaf\n      node.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(node);\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#recursiveGetCells(Cell,Shape,int,boolean,boolean,List[Cell]).mjava","sourceNew":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if cell was added as a leaf. If it wasn't it recursively\n   * descends.\n   */\n  private boolean recursiveGetCells(Cell cell, Shape shape, int detailLevel,\n                                    boolean inclParents, boolean simplify,\n                                    List<Cell> result) {\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (inclParents && cell.getLevel() != 0)\n      result.add(cell);\n\n    Collection<Cell> subCells = cell.getSubCells(shape);\n    int leaves = 0;\n    for (Cell subCell : subCells) {\n      if (recursiveGetCells(subCell, shape, detailLevel, inclParents, simplify, result))\n        leaves++;\n    }\n    //can we simplify?\n    if (simplify && leaves == cell.getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      if (!inclParents) // otherwise it was already added up above\n        result.add(cell);\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["8259c159da2de2e8528524fb76b244b46cbded59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8259c159da2de2e8528524fb76b244b46cbded59":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8259c159da2de2e8528524fb76b244b46cbded59"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8259c159da2de2e8528524fb76b244b46cbded59":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}