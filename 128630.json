{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","commits":[{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","pathOld":"/dev/null","sourceNew":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0732a1e488deedeceef7f601e066085e7ac655a","date":1391629546,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      FixedBitSet bits = hits.bits;\n    \n      final int length = hits.bits.length();\n      int doc = 0;\n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      while (doc < length && (doc = bits.nextSetBit(doc)) != -1) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n        ++doc;\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<String, Scorer>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.doc = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.docID = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cf250cb8fdff62f4b753866d44e5bf59bfd1616","date":1483789944,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,DoubleValuesSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, DoubleValuesSource valueSource) throws IOException {\n\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      DoubleValues scores = keepScores ? scores(hits) : null;\n      DoubleValues functionValues = valueSource.getValues(hits.context, scores);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (functionValues.advanceExact(doc)) {\n          float value = (float) functionValues.doubleValue();\n          for (int i = 0; i < scratch.length; i++) {\n            values[scratch.ints[i]] += value;\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.doc = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,DoubleValuesSource).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetSumValueSource#sumValues(List[MatchingDocs],boolean,ValueSource).mjava","sourceNew":"  private void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, DoubleValuesSource valueSource) throws IOException {\n\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      DoubleValues scores = keepScores ? scores(hits) : null;\n      DoubleValues functionValues = valueSource.getValues(hits.context, scores);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (functionValues.advanceExact(doc)) {\n          float value = (float) functionValues.doubleValue();\n          for (int i = 0; i < scratch.length; i++) {\n            values[scratch.ints[i]] += value;\n          }\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","sourceOld":"  private final void sumValues(List<MatchingDocs> matchingDocs, boolean keepScores, ValueSource valueSource) throws IOException {\n    final FakeScorer scorer = new FakeScorer();\n    Map<String, Scorer> context = new HashMap<>();\n    if (keepScores) {\n      context.put(\"scorer\", scorer);\n    }\n    IntsRef scratch = new IntsRef();\n    for(MatchingDocs hits : matchingDocs) {\n      OrdinalsReader.OrdinalsSegmentReader ords = ordinalsReader.getReader(hits.context);\n      \n      int scoresIdx = 0;\n      float[] scores = hits.scores;\n\n      FunctionValues functionValues = valueSource.getValues(context, hits.context);\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        ords.get(doc, scratch);\n        if (keepScores) {\n          scorer.doc = doc;\n          scorer.score = scores[scoresIdx++];\n        }\n        float value = (float) functionValues.doubleVal(doc);\n        for(int i=0;i<scratch.length;i++) {\n          values[scratch.ints[i]] += value;\n        }\n      }\n    }\n\n    rollup();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0732a1e488deedeceef7f601e066085e7ac655a"],"a0732a1e488deedeceef7f601e066085e7ac655a":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["51f5280f31484820499077f41fcdfe92d527d9dc","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["51f5280f31484820499077f41fcdfe92d527d9dc"],"51f5280f31484820499077f41fcdfe92d527d9dc":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9cf250cb8fdff62f4b753866d44e5bf59bfd1616"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["51f5280f31484820499077f41fcdfe92d527d9dc"],"a0732a1e488deedeceef7f601e066085e7ac655a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4edc984f0f4ac77c37e48ace2932f780f888453c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0732a1e488deedeceef7f601e066085e7ac655a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"51f5280f31484820499077f41fcdfe92d527d9dc":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}