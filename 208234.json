{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c","2d9277507444d59b3e010e1208066807ee408bc3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"694c4ae1a6fef9d2740471ec0f3a8db6367817c8","date":1428290189,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n  }\n\n","bugFix":null,"bugIntro":["2d9277507444d59b3e010e1208066807ee408bc3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d9277507444d59b3e010e1208066807ee408bc3","date":1429669389,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":["4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b74ed46dcc95a6b48b17415355685e1e50bc69d","date":1429730392,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":["da82ad4c841d491f277436297bc692dcda1b01a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c","date":1429817709,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","2d9277507444d59b3e010e1208066807ee408bc3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e","date":1445972879,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\", \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":["da82ad4c841d491f277436297bc692dcda1b01a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da82ad4c841d491f277436297bc692dcda1b01a2","date":1457969596,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e","9b74ed46dcc95a6b48b17415355685e1e50bc69d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79759974460bc59933cd169acc94f5c6b16368d5","date":1471318443,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a510dfee3d23db41e13a46adf0e1b2bfc303f108","date":1495587166,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"730fe41fb3af5691ad519dc6da96240c41ef187f","date":1504632797,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#doStats(Client,ModifiableSolrParams).mjava","sourceNew":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","sourceOld":"  public void doStats(Client client, ModifiableSolrParams p) throws Exception {\n\n    Map<String, List<String>> fieldLists = new HashMap<>();\n    fieldLists.put(\"noexist\", getAlternatives(\"noexist_s\"));\n    fieldLists.put(\"cat_s\", getAlternatives(\"cat_s\"));\n    fieldLists.put(\"where_s\", getAlternatives(\"where_s\"));\n    fieldLists.put(\"num_d\", getAlternatives(\"num_f\")); // num_d name is historical, which is why we map it to num_f alternatives so we can include floats as well\n    fieldLists.put(\"num_i\", getAlternatives(\"num_i\"));\n    fieldLists.put(\"super_s\", getAlternatives(\"super_s\"));\n    fieldLists.put(\"val_b\", getAlternatives(\"val_b\"));\n    fieldLists.put(\"date\", getAlternatives(\"date_dt\"));\n    fieldLists.put(\"sparse_s\", getAlternatives(\"sparse_s\"));\n    fieldLists.put(\"multi_ss\", getAlternatives(\"multi_ss\"));\n\n    // TODO: if a field will be used as a function source, we can't use multi-valued types for it (currently)\n\n    int maxAlt = 0;\n    for (List<String> fieldList : fieldLists.values()) {\n      maxAlt = Math.max(fieldList.size(), maxAlt);\n    }\n\n    // take the field with the maximum number of alternative types and loop through our variants that many times\n    for (int i=0; i<maxAlt; i++) {\n      ModifiableSolrParams args = params(p);\n      for (String field : fieldLists.keySet()) {\n        List<String> alts = fieldLists.get(field);\n        String alt = alts.get( i % alts.size() );\n        args.add(field, alt);\n      }\n\n      args.set(\"rows\",\"0\");\n      // doStatsTemplated(client, args);\n    }\n\n\n    // single valued strings\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_s\",  \"cat_s\",\"cat_s\", \"where_s\",\"where_s\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_l\",\"long_l\", \"super_s\",\"super_s\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_s\"    ,\"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, long/float substitute for int/double\n    doStatsTemplated(client, params(p, \"facet\",\"true\",       \"rows\",\"0\", \"noexist\",\"noexist_ss\", \"cat_s\",\"cat_ss\", \"where_s\",\"where_ss\", \"num_d\",\"num_f\", \"num_i\",\"num_l\", \"num_l\",\"long_l\", \"num_is\",\"num_ls\", \"num_fs\", \"num_ds\", \"super_s\",\"super_ss\", \"val_b\",\"val_b\", \"date\",\"date_dt\", \"sparse_s\",\"sparse_ss\", \"multi_ss\",\"multi_ss\") );\n\n    // multi-valued strings, method=dv for terms facets\n    doStatsTemplated(client, params(p, \"terms_method\", \"method:dv,\", \"rows\", \"0\", \"noexist\", \"noexist_ss\", \"cat_s\", \"cat_ss\", \"where_s\", \"where_ss\", \"num_d\", \"num_f\", \"num_i\", \"num_l\", \"num_l\",\"long_l\",\"super_s\", \"super_ss\", \"val_b\", \"val_b\", \"date\", \"date_dt\", \"sparse_s\", \"sparse_ss\", \"multi_ss\", \"multi_ss\"));\n\n    // single valued docvalues for strings, and single valued numeric doc values for numeric fields\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sd\",  \"cat_s\",\"cat_sd\", \"where_s\",\"where_sd\", \"num_d\",\"num_dd\", \"num_i\",\"num_id\", \"num_is\",\"num_lds\", \"num_l\",\"long_ld\", \"num_fs\",\"num_dds\", \"super_s\",\"super_sd\", \"val_b\",\"val_b\", \"date\",\"date_dtd\", \"sparse_s\",\"sparse_sd\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = false;  // better multi-valued coverage\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",    \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n\n    // multi-valued docvalues\n    FacetFieldProcessorByArrayDV.unwrap_singleValued_multiDv = true;\n    doStatsTemplated(client, params(p,                \"rows\",\"0\", \"noexist\",\"noexist_sds\",  \"cat_s\",\"cat_sds\", \"where_s\",\"where_sds\", \"num_d\",\"num_d\", \"num_i\",\"num_i\", \"num_is\",\"num_ids\", \"num_l\",\"long_ld\", \"num_fs\",\"num_fds\",   \"super_s\",\"super_sds\", \"val_b\",\"val_b\", \"date\",\"date_dtds\", \"sparse_s\",\"sparse_sds\"    ,\"multi_ss\",\"multi_sds\") );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["a510dfee3d23db41e13a46adf0e1b2bfc303f108","730fe41fb3af5691ad519dc6da96240c41ef187f"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["da82ad4c841d491f277436297bc692dcda1b01a2","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"730fe41fb3af5691ad519dc6da96240c41ef187f":["a510dfee3d23db41e13a46adf0e1b2bfc303f108"],"694c4ae1a6fef9d2740471ec0f3a8db6367817c8":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c":["9b74ed46dcc95a6b48b17415355685e1e50bc69d"],"9b74ed46dcc95a6b48b17415355685e1e50bc69d":["2d9277507444d59b3e010e1208066807ee408bc3"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["da82ad4c841d491f277436297bc692dcda1b01a2","79759974460bc59933cd169acc94f5c6b16368d5"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["da82ad4c841d491f277436297bc692dcda1b01a2","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["403d05f7f8d69b65659157eff1bc1d2717f04c66","a510dfee3d23db41e13a46adf0e1b2bfc303f108"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["e9017cf144952056066919f1ebc7897ff9bd71b1","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"da82ad4c841d491f277436297bc692dcda1b01a2":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["a510dfee3d23db41e13a46adf0e1b2bfc303f108","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e":["4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"79759974460bc59933cd169acc94f5c6b16368d5":["da82ad4c841d491f277436297bc692dcda1b01a2"],"a510dfee3d23db41e13a46adf0e1b2bfc303f108":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"2d9277507444d59b3e010e1208066807ee408bc3":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","a510dfee3d23db41e13a46adf0e1b2bfc303f108"],"730fe41fb3af5691ad519dc6da96240c41ef187f":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"694c4ae1a6fef9d2740471ec0f3a8db6367817c8":["2d9277507444d59b3e010e1208066807ee408bc3"],"4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e"],"9b74ed46dcc95a6b48b17415355685e1e50bc69d":["4f3d0182e3d1a4e667fc4d41c06a3c54809c2a9c"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":["685bd38810c206c93e9058f3c2cfa9827c086c27"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"da82ad4c841d491f277436297bc692dcda1b01a2":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","79759974460bc59933cd169acc94f5c6b16368d5"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["94ce69d020f939568b84a1dbbfbd11bfd9907b73","685bd38810c206c93e9058f3c2cfa9827c086c27"],"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e":["da82ad4c841d491f277436297bc692dcda1b01a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"79759974460bc59933cd169acc94f5c6b16368d5":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"a510dfee3d23db41e13a46adf0e1b2bfc303f108":["b21283ed01203901a7257aa4b7f0a0899c86e56e","730fe41fb3af5691ad519dc6da96240c41ef187f","e9017cf144952056066919f1ebc7897ff9bd71b1","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"2d9277507444d59b3e010e1208066807ee408bc3":["9b74ed46dcc95a6b48b17415355685e1e50bc69d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","685bd38810c206c93e9058f3c2cfa9827c086c27","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}