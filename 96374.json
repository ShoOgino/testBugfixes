{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","commits":[{"id":"c07dc645ff236a7d51da2a5ef49a948dfbf8610c","date":1498242650,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a98a4a35a7dcf79e29d32629c8bfba5d4f49d0b","date":1510260515,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.parallelUpdates = builder.parallelUpdates;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Builder).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    super(builder.shardLeadersOnly, builder.parallelUpdates, builder.directUpdatesToLeadersOnly);\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param builder a {@link CloudSolrClient.Builder} with the options used to create the client.\n   */\n  protected CloudSolrClient(Builder builder) {\n    if (builder.stateProvider == null) {\n      if (builder.zkHosts != null && builder.solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (builder.zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(builder.zkHosts, builder.zkChroot);\n      } else if (builder.solrUrls != null && !builder.solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(builder.solrUrls, builder.httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + builder.solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = builder.stateProvider;\n    }\n    this.clientIsInternal = builder.httpClient == null;\n    this.shutdownLBHttpSolrServer = builder.loadBalancedSolrClient == null;\n    if(builder.lbClientBuilder != null) {\n      propagateLBClientConfigOptions(builder);\n      builder.loadBalancedSolrClient = builder.lbClientBuilder.build();\n    }\n    if(builder.loadBalancedSolrClient != null) builder.httpClient = builder.loadBalancedSolrClient.getHttpClient();\n    this.myClient = (builder.httpClient == null) ? HttpClientUtil.createClient(null) : builder.httpClient;\n    if (builder.loadBalancedSolrClient == null) builder.loadBalancedSolrClient = createLBHttpSolrClient(builder, myClient);\n    this.lbClient = builder.loadBalancedSolrClient;\n    this.updatesToLeaders = builder.shardLeadersOnly;\n    this.parallelUpdates = builder.parallelUpdates;\n    this.directUpdatesToLeadersOnly = builder.directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43d1e498704edd2bba13548a189eed4dfccff11b":["28288370235ed02234a64753cdbf0c6ec096304a"],"1a98a4a35a7dcf79e29d32629c8bfba5d4f49d0b":["43d1e498704edd2bba13548a189eed4dfccff11b"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["1a98a4a35a7dcf79e29d32629c8bfba5d4f49d0b"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","43d1e498704edd2bba13548a189eed4dfccff11b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"43d1e498704edd2bba13548a189eed4dfccff11b":["1a98a4a35a7dcf79e29d32629c8bfba5d4f49d0b","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"1a98a4a35a7dcf79e29d32629c8bfba5d4f49d0b":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"28288370235ed02234a64753cdbf0c6ec096304a":["43d1e498704edd2bba13548a189eed4dfccff11b"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}