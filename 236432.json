{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","commits":[{"id":"40ed02185d30689c656882e95985219485a6bec2","date":1462295737,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","pathOld":"/dev/null","sourceNew":"    /** Create a tree.\n     * @param edges is the list of edges.\n     */\n    public Tree(final List<Edge> allEdges) {\n      final Edge[] edges = allEdges.toArray(NO_EDGES);\n      // Sort by edge length, and then by minimum value\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(getMaximum(left) - getMinimum(left), getMaximum(right) - getMinimum(right));\n        if (ret == 0) {\n          ret = Double.compare(getMinimum(left), getMinimum(right));\n        }\n        return ret;\n      });\n\n      for (final Edge edge : edges) {\n        add(edge);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e88f4df686a68a3a4c46a14d0021465d39271d","date":1462303766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","sourceNew":"    /** Create a tree.\n     * @param allEdges is the list of edges.\n     */\n    public Tree(final List<Edge> allEdges) {\n      final Edge[] edges = allEdges.toArray(NO_EDGES);\n      // Sort by edge length, and then by minimum value\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(getMaximum(left) - getMinimum(left), getMaximum(right) - getMinimum(right));\n        if (ret == 0) {\n          ret = Double.compare(getMinimum(left), getMinimum(right));\n        }\n        return ret;\n      });\n\n      for (final Edge edge : edges) {\n        add(edge);\n      }\n    }\n\n","sourceOld":"    /** Create a tree.\n     * @param edges is the list of edges.\n     */\n    public Tree(final List<Edge> allEdges) {\n      final Edge[] edges = allEdges.toArray(NO_EDGES);\n      // Sort by edge length, and then by minimum value\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(getMaximum(left) - getMinimum(left), getMaximum(right) - getMinimum(right));\n        if (ret == 0) {\n          ret = Double.compare(getMinimum(left), getMinimum(right));\n        }\n        return ret;\n      });\n\n      for (final Edge edge : edges) {\n        add(edge);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"083674ea80108c4053d9526cdef6f77b2494e551","date":1462313169,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","sourceNew":"    /** Constructor.\n     * @param allEdges is the list of all edges for the tree.\n     */\n    public Tree(final List<Edge> allEdges) {\n      // Dump edges into an array and then sort it\n      final Node[] edges = new Node[allEdges.size()];\n      int i = 0;\n      for (final Edge edge : allEdges) {\n        edges[i++] = new Node(edge, getMinimum(edge), getMaximum(edge));\n      }\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(left.low, right.low);\n        if (ret == 0) {\n          ret = Double.compare(left.max, right.max);\n        }\n        return ret;\n      });\n      rootNode = createTree(edges, 0, edges.length - 1);\n    }\n\n","sourceOld":"    /** Create a tree.\n     * @param allEdges is the list of edges.\n     */\n    public Tree(final List<Edge> allEdges) {\n      final Edge[] edges = allEdges.toArray(NO_EDGES);\n      // Sort by edge length, and then by minimum value\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(getMaximum(left) - getMinimum(left), getMaximum(right) - getMinimum(right));\n        if (ret == 0) {\n          ret = Double.compare(getMinimum(left), getMinimum(right));\n        }\n        return ret;\n      });\n\n      for (final Edge edge : edges) {\n        add(edge);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#Tree(List[Edge]).mjava","pathOld":"/dev/null","sourceNew":"    /** Constructor.\n     * @param allEdges is the list of all edges for the tree.\n     */\n    public Tree(final List<Edge> allEdges) {\n      // Dump edges into an array and then sort it\n      final Node[] edges = new Node[allEdges.size()];\n      int i = 0;\n      for (final Edge edge : allEdges) {\n        edges[i++] = new Node(edge, getMinimum(edge), getMaximum(edge));\n      }\n      Arrays.sort(edges, (left, right) -> {\n        int ret = Double.compare(left.low, right.low);\n        if (ret == 0) {\n          ret = Double.compare(left.max, right.max);\n        }\n        return ret;\n      });\n      rootNode = createTree(edges, 0, edges.length - 1);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d9e88f4df686a68a3a4c46a14d0021465d39271d":["40ed02185d30689c656882e95985219485a6bec2"],"083674ea80108c4053d9526cdef6f77b2494e551":["d9e88f4df686a68a3a4c46a14d0021465d39271d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40ed02185d30689c656882e95985219485a6bec2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["083674ea80108c4053d9526cdef6f77b2494e551"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","083674ea80108c4053d9526cdef6f77b2494e551"]},"commit2Childs":{"d9e88f4df686a68a3a4c46a14d0021465d39271d":["083674ea80108c4053d9526cdef6f77b2494e551"],"083674ea80108c4053d9526cdef6f77b2494e551":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["40ed02185d30689c656882e95985219485a6bec2","55b50463286869f584cf849d1587a0fcd54d1dfa"],"40ed02185d30689c656882e95985219485a6bec2":["d9e88f4df686a68a3a4c46a14d0021465d39271d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}