{"path":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    \n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    \n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    \n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87340ba49f7de6f2a327aa12318db130e454b590","date":1329528671,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    \n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"061d6b56d515b9b8ec46e009d9534cfb93ec9848","date":1329574557,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(5000);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ef6348b84bf0f8a649826b69a70ac815ff560e2","date":1343106054,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"217c5e3cedf564c6d370670858e1b1edab16fcac","date":1343114420,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1);\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToClient.get(\"shard1\").get(0).query(query).getResults().getNumFound();\n    long client2Docs = shardToClient.get(\"shard1\").get(1).query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd19d7dabf5202d84d4d0f0497fb35e2fa628947","date":1355440258,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042c474f8983c7bfede807d97ad9faf73ff694cc","date":1355859039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e27be44a84b426a815615a9fd23d333667ed78c","date":1355936687,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32894b6a37309f6bcd787fee790c507da0c635bc","date":1356116428,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    commit();\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false); \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404ce65467563294c09554aaa635d236d155f96c","date":1359929177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"709ec1e7204705625cbd074102a6ced459df9c99","date":1361046093,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {2000, 3000, 5000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // give some time for replication to complete\n    Thread.sleep(5000);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {2000, 3000, 5000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // give some time for replication to complete\n    Thread.sleep(5000);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    indexThread = new StopableIndexingThread(0, true);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    Thread.sleep(atLeast(2000));   \n    \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(atLeast(2000));\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(1500);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(1000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69f8e56ca20869301b79b5b945f28bbd93e9ba25","date":1362339751,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {2000, 3000, 5000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // give some time for replication to complete\n    Thread.sleep(5000);\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(500);\n  \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    checkShardConsistency(\"shard1\", false, false);\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699","date":1385913128,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(\"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(\"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":["709ec1e7204705625cbd074102a6ced459df9c99"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(\"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(\"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(0, true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(10000, true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19389fe47925b510b2811e2b385a75f7ad19dcca","date":1393903127,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(\"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(\"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(\"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(\"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(45);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a20d1dfc29180e579d8f914a4c1ac7a51a94c7d","date":1395628085,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 3000};\n    int[] maxDocNightlyList = new int[] {3000, 7000, 12000, 30000, 45000, 60000};\n    \n    int maxDoc;\n    if (!TEST_NIGHTLY) {\n      maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    } else {\n      maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];\n    }\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 5000, 15000};\n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 3000};\n    int[] maxDocNightlyList = new int[] {3000, 7000, 12000, 30000, 45000, 60000};\n    \n    int maxDoc;\n    if (!TEST_NIGHTLY) {\n      maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    } else {\n      maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];\n    }\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 3000};\n    int[] maxDocNightlyList = new int[] {3000, 7000, 12000, 30000, 45000, 60000};\n    \n    int maxDoc;\n    if (!TEST_NIGHTLY) {\n      maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    } else {\n      maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];\n    }\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 3000};\n    int[] maxDocNightlyList = new int[] {3000, 7000, 12000, 30000, 45000, 60000};\n    \n    int maxDoc;\n    if (!TEST_NIGHTLY) {\n      maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    } else {\n      maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];\n    }\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {300, 700, 1200, 1350, 3000};\n    int[] maxDocNightlyList = new int[] {3000, 7000, 12000, 30000, 45000, 60000};\n    \n    int maxDoc;\n    if (!TEST_NIGHTLY) {\n      maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    } else {\n      maxDoc = maxDocNightlyList[random().nextInt(maxDocList.length - 1)];\n    }\n    \n    indexThread = new StopableIndexingThread(controlClient, cloudClient, \"1\", true, maxDoc);\n    indexThread.start();\n    \n    indexThread2 = new StopableIndexingThread(controlClient, cloudClient, \"2\", true, maxDoc);\n    \n    indexThread2.start();\n\n    // give some time to index...\n    int[] waitTimes = new int[] {200, 2000, 3000};\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n     \n    // bring shard replica down\n    JettySolrRunner replica = chaosMonkey.stopShard(\"shard1\", 1).jetty;\n\n    \n    // wait a moment - lets allow some docs to be indexed so replication time is non 0\n    Thread.sleep(waitTimes[random().nextInt(waitTimes.length - 1)]);\n    \n    // bring shard replica up\n    replica.start();\n    \n    // make sure replication can start\n    Thread.sleep(3000);\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    \n    // stop indexing threads\n    indexThread.safeStop();\n    indexThread2.safeStop();\n    \n    indexThread.join();\n    indexThread2.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, zkStateReader, false, true);\n\n    // test that leader and replica have same doc count\n    \n    String fail = checkShardConsistency(\"shard1\", false, false);\n    if (fail != null) {\n      fail(fail);\n    }\n    \n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.setParam(\"distrib\", \"false\");\n    long client1Docs = shardToJetty.get(\"shard1\").get(0).client.solrClient.query(query).getResults().getNumFound();\n    long client2Docs = shardToJetty.get(\"shard1\").get(1).client.solrClient.query(query).getResults().getNumFound();\n    \n    assertTrue(client1Docs > 0);\n    assertEquals(client1Docs, client2Docs);\n \n    // won't always pass yet...\n    //query(\"q\", \"*:*\", \"sort\", \"id desc\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","32894b6a37309f6bcd787fee790c507da0c635bc"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["5a20d1dfc29180e579d8f914a4c1ac7a51a94c7d"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699","19389fe47925b510b2811e2b385a75f7ad19dcca"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["69f8e56ca20869301b79b5b945f28bbd93e9ba25","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"abb23fcc2461782ab204e61213240feb77d355aa":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"5e27be44a84b426a815615a9fd23d333667ed78c":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","404ce65467563294c09554aaa635d236d155f96c"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["061d6b56d515b9b8ec46e009d9534cfb93ec9848","217c5e3cedf564c6d370670858e1b1edab16fcac"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["217c5e3cedf564c6d370670858e1b1edab16fcac"],"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"19389fe47925b510b2811e2b385a75f7ad19dcca":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"5a20d1dfc29180e579d8f914a4c1ac7a51a94c7d":["19389fe47925b510b2811e2b385a75f7ad19dcca"],"aba371508186796cc6151d8223a5b4e16d02e26e":["061d6b56d515b9b8ec46e009d9534cfb93ec9848","217c5e3cedf564c6d370670858e1b1edab16fcac"],"217c5e3cedf564c6d370670858e1b1edab16fcac":["6ef6348b84bf0f8a649826b69a70ac815ff560e2"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["404ce65467563294c09554aaa635d236d155f96c","709ec1e7204705625cbd074102a6ced459df9c99"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"042c474f8983c7bfede807d97ad9faf73ff694cc":["fd19d7dabf5202d84d4d0f0497fb35e2fa628947"],"f2126b84bd093fa3d921582a109a0ee578c28126":["217c5e3cedf564c6d370670858e1b1edab16fcac","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"709ec1e7204705625cbd074102a6ced459df9c99":["404ce65467563294c09554aaa635d236d155f96c"],"87340ba49f7de6f2a327aa12318db130e454b590":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"69f8e56ca20869301b79b5b945f28bbd93e9ba25":["709ec1e7204705625cbd074102a6ced459df9c99"],"32894b6a37309f6bcd787fee790c507da0c635bc":["5e27be44a84b426a815615a9fd23d333667ed78c"],"6ef6348b84bf0f8a649826b69a70ac815ff560e2":["061d6b56d515b9b8ec46e009d9534cfb93ec9848"],"061d6b56d515b9b8ec46e009d9534cfb93ec9848":["87340ba49f7de6f2a327aa12318db130e454b590"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["69f8e56ca20869301b79b5b945f28bbd93e9ba25"],"404ce65467563294c09554aaa635d236d155f96c":["32894b6a37309f6bcd787fee790c507da0c635bc"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["061d6b56d515b9b8ec46e009d9534cfb93ec9848","217c5e3cedf564c6d370670858e1b1edab16fcac"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["849494cf2f3a96af5c8c84995108ddd8456fcd04","67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"],"fd19d7dabf5202d84d4d0f0497fb35e2fa628947":["d9405f486872f1e416304dfe389741f4ee2f8a4d"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["abb23fcc2461782ab204e61213240feb77d355aa"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5e27be44a84b426a815615a9fd23d333667ed78c":["32894b6a37309f6bcd787fee790c507da0c635bc"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","fd19d7dabf5202d84d4d0f0497fb35e2fa628947"],"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699":["96ea64d994d340044e0d57aeb6a5871539d10ca5","19389fe47925b510b2811e2b385a75f7ad19dcca","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"19389fe47925b510b2811e2b385a75f7ad19dcca":["96ea64d994d340044e0d57aeb6a5871539d10ca5","5a20d1dfc29180e579d8f914a4c1ac7a51a94c7d"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"5a20d1dfc29180e579d8f914a4c1ac7a51a94c7d":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"217c5e3cedf564c6d370670858e1b1edab16fcac":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","d9405f486872f1e416304dfe389741f4ee2f8a4d","aba371508186796cc6151d8223a5b4e16d02e26e","f2126b84bd093fa3d921582a109a0ee578c28126","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"042c474f8983c7bfede807d97ad9faf73ff694cc":["5e27be44a84b426a815615a9fd23d333667ed78c"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"709ec1e7204705625cbd074102a6ced459df9c99":["95303ff3749680c743b9425f9cf99e6e4065e8a8","69f8e56ca20869301b79b5b945f28bbd93e9ba25"],"87340ba49f7de6f2a327aa12318db130e454b590":["061d6b56d515b9b8ec46e009d9534cfb93ec9848"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"69f8e56ca20869301b79b5b945f28bbd93e9ba25":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"32894b6a37309f6bcd787fee790c507da0c635bc":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","404ce65467563294c09554aaa635d236d155f96c"],"061d6b56d515b9b8ec46e009d9534cfb93ec9848":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","aba371508186796cc6151d8223a5b4e16d02e26e","6ef6348b84bf0f8a649826b69a70ac815ff560e2","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"6ef6348b84bf0f8a649826b69a70ac815ff560e2":["217c5e3cedf564c6d370670858e1b1edab16fcac"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"404ce65467563294c09554aaa635d236d155f96c":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","95303ff3749680c743b9425f9cf99e6e4065e8a8","709ec1e7204705625cbd074102a6ced459df9c99"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","87340ba49f7de6f2a327aa12318db130e454b590","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"fd19d7dabf5202d84d4d0f0497fb35e2fa628947":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","37a0f60745e53927c4c876cfe5b5a58170f0646c","3e4d4ec39bf5396230748ca859ff05ab024b6fc5","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","0d22ac6a4146774c1bc8400160fc0b6150294e92","aba371508186796cc6151d8223a5b4e16d02e26e","95303ff3749680c743b9425f9cf99e6e4065e8a8","f2126b84bd093fa3d921582a109a0ee578c28126","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}