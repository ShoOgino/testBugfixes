{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","commits":[{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float]).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    assertEquals(expected.counts.length, actual.facetResults.size());\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      FacetResult fr = actual.facetResults.get(dim);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      int idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleFacetResult expected, DrillSidewaysResult actual, Map<String,Float> scores) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n    assertEquals(expected.counts.length, actual.facetResults.size());\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n      FacetResult fr = actual.facetResults.get(dim);\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      for(FacetResultNode childNode : fr.getFacetResultNode().subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"      expected\");\n      }\n\n      int setCount = 0;\n      for(int i=0;i<dimValues[dim].length;i++) {\n        String value = dimValues[dim][i];\n        if (expected.counts[dim][i] != 0) {\n          if (VERBOSE) {\n            System.out.println(\"        \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n          } \n          assertTrue(actualValues.containsKey(value));\n          assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n          setCount++;\n        } else {\n          assertFalse(actualValues.containsKey(value));\n        }\n      }\n\n      assertEquals(setCount, actualValues.size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70df4d80cde893a6897f8e6543c2d7666b73d7a","date":1365615272,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(List[FacetRequest],String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleFacetResult,DrillSidewaysResult,Map[String,Float],int,boolean).mjava","sourceNew":"  void verifyEquals(List<FacetRequest> requests, String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    int numExpected = 0;\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] != null) {\n        numExpected++;\n      }\n    }\n\n    assertEquals(numExpected, actual.facetResults.size());\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      if (expected.counts[dim] == null) {\n        continue;\n      }\n      int idx = -1;\n      for(int i=0;i<requests.size();i++) {\n        if (Integer.parseInt(requests.get(i).categoryPath.components[0].substring(3)) == dim) {\n          idx = i;\n          break;\n        }\n      }\n      assert idx != -1;\n      FacetResult fr = actual.facetResults.get(idx);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, int topN, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    assertEquals(expected.counts.length, actual.facetResults.size());\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      FacetResult fr = actual.facetResults.get(dim);\n      List<FacetResultNode> subResults = fr.getFacetResultNode().subResults;\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim);\n        System.out.println(\"      actual\");\n      }\n\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n      int idx = 0;\n      for(FacetResultNode childNode : subResults) {\n        actualValues.put(childNode.label.components[1], (int) childNode.value);\n        if (VERBOSE) {\n          System.out.println(\"        \" + idx + \": \" + new BytesRef(childNode.label.components[1]) + \": \" + (int) childNode.value);\n          idx++;\n        }\n      }\n\n      if (topN != -1) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        assertEquals(topNIDs.length, subResults.size());\n        for(int i=0;i<topNIDs.length;i++) {\n          FacetResultNode node = subResults.get(i);\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], (int) node.value);\n          assertEquals(2, node.label.length);\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], node.label.components[1]);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"]},"commit2Childs":{"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}