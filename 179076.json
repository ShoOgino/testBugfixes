{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","commits":[{"id":"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b","date":1364392557,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"/dev/null","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\"+i;\n      Shape indexedShape;\n      if (random().nextInt(4) == 0) {\n        indexedShape = new ShapePair( gridSnapp(randomRectangle()), gridSnapp(randomRectangle()) );\n      } else {\n        indexedShape = gridSnapp(randomRectangle());\n      }\n      indexedShapes.put(id, indexedShape);\n      adoc(id, indexedShape);\n      if (random().nextInt(10) == 0)\n        commit();\n    }\n\n    //delete some\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      Shape queryShape = gridSnapp(randomRectangle());\n\n      //Generate truth via brute force\n      Set<String> expectedIds = new TreeSet<String>();\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        if (operation.evaluate(entry.getValue(), queryShape))\n          expectedIds.add(entry.getKey());\n      }\n\n      //Search and verify results\n      Query query = strategy.makeQuery(new SpatialArgs(operation, queryShape));\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new TreeSet<String>(expectedIds);\n      String msg = queryShape.toString()+\" Expect: \"+expectedIds;\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        Object removed = remainingExpectedIds.remove(id);\n        if (removed == null) {\n          fail(\"Shouldn't match \" + id + \" (\"+ indexedShapes.get(id) +\") in \" + msg);\n        }\n      }\n      if (!remainingExpectedIds.isEmpty()) {\n        Shape firstFailedMatch = indexedShapes.get(remainingExpectedIds.iterator().next());\n        fail(\"Didn't match \" + firstFailedMatch + \" in \" + msg +\" (of \"+remainingExpectedIds.size()+\")\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50b84d7eef0fc32233dd6251567fdbdb10c4cda7","date":1365707213,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 10\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 4 == 0) {//3 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\"+i;\n      Shape indexedShape;\n      if (random().nextInt(4) == 0) {\n        indexedShape = new ShapePair( gridSnapp(randomRectangle()), gridSnapp(randomRectangle()) );\n      } else {\n        indexedShape = gridSnapp(randomRectangle());\n      }\n      indexedShapes.put(id, indexedShape);\n      adoc(id, indexedShape);\n      if (random().nextInt(10) == 0)\n        commit();\n    }\n\n    //delete some\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      Shape queryShape = gridSnapp(randomRectangle());\n\n      //Generate truth via brute force\n      Set<String> expectedIds = new TreeSet<String>();\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        if (operation.evaluate(entry.getValue(), queryShape))\n          expectedIds.add(entry.getKey());\n      }\n\n      //Search and verify results\n      Query query = strategy.makeQuery(new SpatialArgs(operation, queryShape));\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new TreeSet<String>(expectedIds);\n      String msg = queryShape.toString()+\" Expect: \"+expectedIds;\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        Object removed = remainingExpectedIds.remove(id);\n        if (removed == null) {\n          fail(\"Shouldn't match \" + id + \" (\"+ indexedShapes.get(id) +\") in \" + msg);\n        }\n      }\n      if (!remainingExpectedIds.isEmpty()) {\n        Shape firstFailedMatch = indexedShapes.get(remainingExpectedIds.iterator().next());\n        fail(\"Didn't match \" + firstFailedMatch + \" in \" + msg +\" (of \"+remainingExpectedIds.size()+\")\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9","date":1371743283,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 10\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 4 == 0) {//3 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 10\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 4 == 0) {//3 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"656f7931e8a3dc60676fe66839b7fa03afbe8098","date":1374722646,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c812573c5617c5a3eff581b09251df3030455fbb","date":1392316648,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4 in 12 (0,3,6,9)\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      //TODO sometimes index a point. Need to fix LUCENE-4978 first though.\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape = randomRectangle();\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4-1 in 12\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      final Shape queryShape = randomRectangle();\n\n      final boolean DISJOINT = operation.equals(SpatialOperation.IsDisjointTo);\n\n      //Generate truth via brute force:\n      // We really try to ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set <String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n        String id = entry.getKey();\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (DISJOINT) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!DISJOINT) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation.equals(SpatialOperation.Intersects)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n            queryShapeCompare = gridSnap(queryShape);\n          } else if (operation.equals(SpatialOperation.Contains)) {\n            indexedShapeCompare = indexedShapesGS.get(entry.getKey());\n          } else if (operation.equals(SpatialOperation.IsWithin)) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!DISJOINT && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (DISJOINT)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4 in 12 (0,3,6,9)\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      //TODO sometimes index a point. Need to fix LUCENE-4978 first though.\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape = randomRectangle();\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<String, Shape>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4 in 12 (0,3,6,9)\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      //TODO sometimes index a point. Need to fix LUCENE-4978 first though.\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape = randomRectangle();\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<String>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<String>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<String>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f54c29b684839e16d0a7ffd41ee8a1e93e905184","date":1395120410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n        case 1:case 2:case 3:\n          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n            queryShape = randomShapePairRect(biasContains);\n            break;\n          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      Shape indexedShapeGS; //(grid-snapped)\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null; //no shape for this doc\n        indexedShapeGS = null;\n      } else if (R % 3 == 0) {//4 in 12 (0,3,6,9)\n        //comprised of more than one shape\n        Rectangle shape1 = randomRectangle();\n        Rectangle shape2 = randomRectangle();\n        indexedShape = new ShapePair(shape1, shape2, biasContains);\n        indexedShapeGS = new ShapePair(gridSnap(shape1), gridSnap(shape2), biasContains);\n      } else {\n        //just one shape\n        indexedShape = randomRectangle();\n        indexedShapeGS = gridSnap(indexedShape);\n      }\n      //TODO sometimes index a point. Need to fix LUCENE-4978 first though.\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, indexedShapeGS);\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape = randomRectangle();\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = gridSnap(queryShape);\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = gridSnap(queryShape);\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["9c19e4123dbaa2dd49fbbf38068c1f587d304ff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c19e4123dbaa2dd49fbbf38068c1f587d304ff2","date":1395150412,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n        case 1:case 2:case 3:\n          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n            break;\n          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n        case 1:case 2:case 3:\n          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n            queryShape = randomShapePairRect(biasContains);\n            break;\n          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628","date":1395439624,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n        case 1:case 2:case 3:\n          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n            break;\n          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0521546db127e358ced1772a9d696dbdd255b203","date":1403202289,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c812573c5617c5a3eff581b09251df3030455fbb"],"c812573c5617c5a3eff581b09251df3030455fbb":["656f7931e8a3dc60676fe66839b7fa03afbe8098"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7","0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628":["9c19e4123dbaa2dd49fbbf38068c1f587d304ff2"],"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7"],"9c19e4123dbaa2dd49fbbf38068c1f587d304ff2":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"656f7931e8a3dc60676fe66839b7fa03afbe8098":["0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"0521546db127e358ced1772a9d696dbdd255b203":["9bbe72b1a752bdee427ae5d2bc9f2a847b51a628"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0521546db127e358ced1772a9d696dbdd255b203"],"50b84d7eef0fc32233dd6251567fdbdb10c4cda7":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["9c19e4123dbaa2dd49fbbf38068c1f587d304ff2"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"c812573c5617c5a3eff581b09251df3030455fbb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628":["0521546db127e358ced1772a9d696dbdd255b203"],"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9":["37a0f60745e53927c4c876cfe5b5a58170f0646c","656f7931e8a3dc60676fe66839b7fa03afbe8098"],"9c19e4123dbaa2dd49fbbf38068c1f587d304ff2":["9bbe72b1a752bdee427ae5d2bc9f2a847b51a628"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"656f7931e8a3dc60676fe66839b7fa03afbe8098":["c812573c5617c5a3eff581b09251df3030455fbb"],"0521546db127e358ced1772a9d696dbdd255b203":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"50b84d7eef0fc32233dd6251567fdbdb10c4cda7":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7"]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}