{"path":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(cloudDescriptor.getCollectionName(),\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        state = nodeProps.get(ZkStateReader.STATE_PROP);\n        boolean live = cloudState.liveNodesContain(nodeName);\n        if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n            && live) {\n          break;\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(cloudDescriptor.getCollectionName(),\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        state = nodeProps.get(ZkStateReader.STATE_PROP);\n        boolean live = cloudState.liveNodesContain(nodeName);\n        if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n            && live) {\n          break;\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(cloudDescriptor.getCollectionName(),\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        state = nodeProps.get(ZkStateReader.STATE_PROP);\n        boolean live = cloudState.liveNodesContain(nodeName);\n        if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n            && live) {\n          break;\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32c479cc61614dce1cba211e353e2cb8193e88ee","date":1329430818,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n              && live) {\n            break;\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(cloudDescriptor.getCollectionName(),\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        state = nodeProps.get(ZkStateReader.STATE_PROP);\n        boolean live = cloudState.liveNodesContain(nodeName);\n        if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n            && live) {\n          break;\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    boolean checkLive = params.getBool(\"checkLive\", true);\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive && live) {\n              break;\n            } else {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n              && live) {\n            break;\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"32c479cc61614dce1cba211e353e2cb8193e88ee":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["32c479cc61614dce1cba211e353e2cb8193e88ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a80994db3380cd78c6f65b84515e2e931b6b3da"]},"commit2Childs":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","32c479cc61614dce1cba211e353e2cb8193e88ee"],"32c479cc61614dce1cba211e353e2cb8193e88ee":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}