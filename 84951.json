{"path":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","commits":[{"id":"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f","date":1343307395,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","pathOld":"/dev/null","sourceNew":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, \"UTF-8\");\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, \"UTF-8\");\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","pathOld":"/dev/null","sourceNew":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, \"UTF-8\");\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, \"UTF-8\");\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","pathOld":"/dev/null","sourceNew":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, \"UTF-8\");\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, \"UTF-8\");\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","pathOld":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","sourceNew":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, StandardCharsets.UTF_8);\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","sourceOld":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, \"UTF-8\");\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, \"UTF-8\");\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","pathOld":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateUTR30DataFiles#expandDataFileRules(File).mjava","sourceNew":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, StandardCharsets.UTF_8);\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","sourceOld":"  private static void expandDataFileRules(File file) throws IOException {\n    final FileInputStream stream = new FileInputStream(file);\n    final InputStreamReader reader = new InputStreamReader(stream, \"UTF-8\");\n    final BufferedReader bufferedReader = new BufferedReader(reader);\n    StringBuilder builder = new StringBuilder();\n    String line;\n    boolean verbatim = false;\n    boolean modified = false;\n    int lineNum = 0;\n    try {\n      while (null != (line = bufferedReader.readLine())) {\n        ++lineNum;\n        if (VERBATIM_RULE_LINE_PATTERN.matcher(line).matches()) {\n          verbatim = true;\n          builder.append(line).append(\"\\n\");\n        } else {\n          Matcher ruleMatcher = RULE_LINE_PATTERN.matcher(line);\n          if (ruleMatcher.matches()) {\n            verbatim = false;\n            builder.append(line).append(\"\\n\");\n            try {\n              String leftHandSide = ruleMatcher.group(1).trim();\n              String rightHandSide = ruleMatcher.group(2).trim();\n              expandSingleRule(builder, leftHandSide, rightHandSide);\n            } catch (IllegalArgumentException e) {\n              System.err.println\n                  (\"ERROR in \" + file.getName() + \" line #\" + lineNum + \":\");\n              e.printStackTrace(System.err);\n              System.exit(1);\n            }\n            modified = true;\n          } else {\n            if (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches()) {\n              builder.append(line).append(\"\\n\");\n            } else {\n              if (verbatim) {\n                builder.append(line).append(\"\\n\");\n              } else {\n                modified = true;\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      bufferedReader.close();\n    }\n    if (modified) {\n      System.err.println(\"Expanding rules in and overwriting \" + file.getName());\n      final FileOutputStream out = new FileOutputStream(file, false);\n      Writer writer = new OutputStreamWriter(out, \"UTF-8\");\n      try {\n        writer.write(builder.toString());\n      } finally {\n        writer.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f","7d89d7e4e5101347833eea558851bf4209218619"],"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f"],"7d89d7e4e5101347833eea558851bf4209218619":["c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7d89d7e4e5101347833eea558851bf4209218619"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f":["5eb2511ababf862ea11e10761c70ee560cd84510","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","7d89d7e4e5101347833eea558851bf4209218619"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}