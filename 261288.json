{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","commits":[{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76a51551f05a6c96a115b5a656837ecc8fd0b1ff","date":1551422476,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a14a9a6131884330f34844dabc1ece206ceaea9","date":1561954503,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, randomBoolean()));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, randomBoolean());\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, in, in, randomBoolean()));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        Runnable finalizer = w.merge(out, out, out, docMaps, readers);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, randomBoolean()));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, randomBoolean());\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, in, in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        Runnable finalizer = w.merge(out, out, out, docMaps, readers);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, in, in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, in, in, randomBoolean()));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        Runnable finalizer = w.merge(out, out, out, docMaps, readers);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, new BKDConfig(numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode), maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, new BKDConfig(numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode), maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, new BKDConfig(numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode), maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, in, in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        Runnable finalizer = w.merge(out, out, out, docMaps, readers);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, in, in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n    //we force sometimes to provide a bigger  point count\n    long maxDocs = Long.MIN_VALUE;\n    if (random().nextBoolean()) {\n       maxDocs  = docValues.length;\n    } else {\n      while (maxDocs < docValues.length) {\n        maxDocs = random().nextLong();\n      }\n    }\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, maxDocs);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          Runnable finalizer = w.finish(out, out, out);\n          toMerge.add(out.getFilePointer());\n          finalizer.run();\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in, in, in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        Runnable finalizer = w.merge(out, out, out, docMaps, readers);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in, in, in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n          @Override\n          public void visit(DocIdSetIterator iterator, byte[] packedValue) throws IOException {\n              if (random().nextBoolean()) {\n                // check the default method is correct\n                IntersectVisitor.super.visit(iterator, packedValue);\n              } else {\n                assertEquals(iterator.docID(), -1);\n                int cost = Math.toIntExact(iterator.cost());\n                int numberOfPoints = 0;\n                int docID;\n                while ((docID = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n                  assertEquals(iterator.docID(), docID);\n                  visit(docID, packedValue);\n                  numberOfPoints++;\n                }\n                assertEquals(cost,  numberOfPoints);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.nextDoc(), DocIdSetIterator.NO_MORE_DOCS);\n                assertEquals(iterator.docID(), DocIdSetIterator.NO_MORE_DOCS);\n              }\n          }\n\n          @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["8a14a9a6131884330f34844dabc1ece206ceaea9"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"f6652c943595e92c187ee904c382863013eae28f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"8a14a9a6131884330f34844dabc1ece206ceaea9":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["8a14a9a6131884330f34844dabc1ece206ceaea9"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6652c943595e92c187ee904c382863013eae28f"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"8a14a9a6131884330f34844dabc1ece206ceaea9":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}