{"path":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYZSolid#XYZSolid(PlanetModel,double,double,double,double,double,double).mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYZSolid#XYZSolid(PlanetModel,double,double,double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param minZ is the minimum Z value.\n   *@param maxZ is the maximum Z value.\n   */\n  public XYZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double minZ,\n    final double maxZ) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n    if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Z values in wrong order or identical\");\n\n    final double worldMinX = planetModel.getMinimumXValue();\n    final double worldMaxX = planetModel.getMaximumXValue();\n    final double worldMinY = planetModel.getMinimumYValue();\n    final double worldMaxY = planetModel.getMaximumYValue();\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // We must distinguish between the case where the solid represents the entire world,\n    // and when the solid has no overlap with any part of the surface.  In both cases,\n    // there will be no edgepoints.\n    isWholeWorld =\n        (minX - worldMinX < -Vector.MINIMUM_RESOLUTION) &&\n        (maxX - worldMaxX > Vector.MINIMUM_RESOLUTION) &&\n        (minY - worldMinY < -Vector.MINIMUM_RESOLUTION) &&\n        (maxY - worldMaxY > Vector.MINIMUM_RESOLUTION) &&\n        (minZ - worldMinZ < -Vector.MINIMUM_RESOLUTION) &&\n        (maxZ - worldMaxZ > Vector.MINIMUM_RESOLUTION);\n\n    if (isWholeWorld) {\n      minXPlane = null;\n      maxXPlane = null;\n      minYPlane = null;\n      maxYPlane = null;\n      minZPlane = null;\n      maxZPlane = null;\n      notableMinXPoints = null;\n      notableMaxXPoints = null;\n      notableMinYPoints = null;\n      notableMaxYPoints = null;\n      notableMinZPoints = null;\n      notableMaxZPoints = null;\n      edgePoints = null;\n    } else {\n      // Construct the planes\n      minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n      maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n      minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n      maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n      minZPlane = new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);\n      maxZPlane = new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);\n      \n      // We need at least one point on the planet surface for each manifestation of the shape.\n      // There can be up to 2 (on opposite sides of the world).  But we have to go through\n      // 12 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n      // Typically, this requires 12 square root operations. \n      final GeoPoint[] minXminY = minXPlane.findIntersections(planetModel,minYPlane,maxXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXmaxY = minXPlane.findIntersections(planetModel,maxYPlane,maxXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXminZ = minXPlane.findIntersections(planetModel,minZPlane,maxXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] minXmaxZ = minXPlane.findIntersections(planetModel,maxZPlane,maxXPlane,minZPlane,minYPlane,maxYPlane);\n\n      final GeoPoint[] maxXminY = maxXPlane.findIntersections(planetModel,minYPlane,minXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXmaxY = maxXPlane.findIntersections(planetModel,maxYPlane,minXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXminZ = maxXPlane.findIntersections(planetModel,minZPlane,minXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] maxXmaxZ = maxXPlane.findIntersections(planetModel,maxZPlane,minXPlane,minZPlane,minYPlane,maxYPlane);\n      \n      final GeoPoint[] minYminZ = minYPlane.findIntersections(planetModel,minZPlane,maxYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] minYmaxZ = minYPlane.findIntersections(planetModel,maxZPlane,maxYPlane,minZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYminZ = maxYPlane.findIntersections(planetModel,minZPlane,minYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYmaxZ = maxYPlane.findIntersections(planetModel,maxZPlane,minYPlane,minZPlane,minXPlane,maxXPlane);\n      \n      notableMinXPoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ);\n      notableMaxXPoints = glueTogether(maxXminY, maxXmaxY, maxXminZ, maxXmaxZ);\n      notableMinYPoints = glueTogether(minXminY, maxXminY, minYminZ, minYmaxZ);\n      notableMaxYPoints = glueTogether(minXmaxY, maxXmaxY, maxYminZ, maxYmaxZ);\n      notableMinZPoints = glueTogether(minXminZ, maxXminZ, minYminZ, maxYminZ);\n      notableMaxZPoints = glueTogether(minXmaxZ, maxXmaxZ, minYmaxZ, maxYmaxZ);\n\n      // Now, compute the edge points.\n      // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n      // we'll start there.\n      // There can be a number of shapes, each of which needs an edgepoint.  Each side by itself might contribute\n      // an edgepoint, for instance, if the plane describing that side intercepts the planet in such a way that the ellipse\n      // of interception does not meet any other planes.  Plane intersections can each contribute 0, 1, or 2 edgepoints.\n      //\n      // All of this makes for a lot of potential edgepoints, but I believe these can be pruned back with careful analysis.\n      // I haven't yet done that analysis, however, so I will treat them all as individual edgepoints.\n      \n      // The cases we are looking for are when the four corner points for any given\n      // plane are all outside of the world, AND that plane intersects the world.\n      // There are eight corner points all told; we must evaluate these WRT the planet surface.\n      final boolean minXminYminZ = planetModel.pointOutside(minX, minY, minZ);\n      final boolean minXminYmaxZ = planetModel.pointOutside(minX, minY, maxZ);\n      final boolean minXmaxYminZ = planetModel.pointOutside(minX, maxY, minZ);\n      final boolean minXmaxYmaxZ = planetModel.pointOutside(minX, maxY, maxZ);\n      final boolean maxXminYminZ = planetModel.pointOutside(maxX, minY, minZ);\n      final boolean maxXminYmaxZ = planetModel.pointOutside(maxX, minY, maxZ);\n      final boolean maxXmaxYminZ = planetModel.pointOutside(maxX, maxY, minZ);\n      final boolean maxXmaxYmaxZ = planetModel.pointOutside(maxX, maxY, maxZ);\n        \n      // Look at single-plane/world intersections.\n      // We detect these by looking at the world model and noting its x, y, and z bounds.\n\n      final GeoPoint[] minXEdges;\n      if (minX - worldMinX >= -Vector.MINIMUM_RESOLUTION && minX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && minXmaxYminZ && minXmaxYmaxZ) {\n        // Find any point on the minX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        minXEdges = new GeoPoint[]{minXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        minXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxXEdges;\n      if (maxX - worldMinX >= -Vector.MINIMUM_RESOLUTION && maxX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        maxXminYminZ && maxXminYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        maxXEdges = new GeoPoint[]{maxXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        maxXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minYEdges;\n      if (minY - worldMinY >= -Vector.MINIMUM_RESOLUTION && minY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && maxXminYminZ && maxXminYmaxZ) {\n        // Find any point on the minY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        minYEdges = new GeoPoint[]{minYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane)};\n      } else {\n        minYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxYEdges;\n      if (maxY - worldMinY >= -Vector.MINIMUM_RESOLUTION && maxY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXmaxYminZ && minXmaxYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        maxYEdges = new GeoPoint[]{maxYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane)};\n      } else {\n        maxYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minZEdges;\n      if (minZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && minZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYminZ && minXmaxYminZ && maxXminYminZ && maxXmaxYminZ) {\n        // Find any point on the minZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        minZEdges = new GeoPoint[]{minZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        minZEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxZEdges;\n      if (maxZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && maxZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYmaxZ && minXmaxYmaxZ && maxXminYmaxZ && maxXmaxYmaxZ) {\n        // Find any point on the maxZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0) (that is, its orientation doesn't matter)\n        // Then use it to compute a sample point.\n        maxZEdges = new GeoPoint[]{maxZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        maxZEdges = EMPTY_POINTS;\n      }\n      \n      // Glue everything together.  This is not a minimal set of edgepoints, as of now, but it does completely describe all shapes on the\n      // planet.\n      this.edgePoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ,\n        maxXminY, maxXmaxY, maxXminZ, maxXmaxZ,\n        minYminZ, minYmaxZ, maxYminZ, maxYmaxZ,\n        minXEdges, maxXEdges, minYEdges, maxYEdges, minZEdges, maxZEdges);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d8f71af177fad4bbfdf462d318247e573faac27f","dc584fa95053c03d95035277a2d2aaddd537c0fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8f71af177fad4bbfdf462d318247e573faac27f","date":1441729530,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYZSolid#XYZSolid(PlanetModel,double,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYZSolid#XYZSolid(PlanetModel,double,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param minZ is the minimum Z value.\n   *@param maxZ is the maximum Z value.\n   */\n  public XYZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double minZ,\n    final double maxZ) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n    if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Z values in wrong order or identical\");\n\n    final double worldMinX = planetModel.getMinimumXValue();\n    final double worldMaxX = planetModel.getMaximumXValue();\n    final double worldMinY = planetModel.getMinimumYValue();\n    final double worldMaxY = planetModel.getMaximumYValue();\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // We must distinguish between the case where the solid represents the entire world,\n    // and when the solid has no overlap with any part of the surface.  In both cases,\n    // there will be no edgepoints.\n    isWholeWorld =\n        (minX - worldMinX < -Vector.MINIMUM_RESOLUTION) &&\n        (maxX - worldMaxX > Vector.MINIMUM_RESOLUTION) &&\n        (minY - worldMinY < -Vector.MINIMUM_RESOLUTION) &&\n        (maxY - worldMaxY > Vector.MINIMUM_RESOLUTION) &&\n        (minZ - worldMinZ < -Vector.MINIMUM_RESOLUTION) &&\n        (maxZ - worldMaxZ > Vector.MINIMUM_RESOLUTION);\n\n    if (isWholeWorld) {\n      minXPlane = null;\n      maxXPlane = null;\n      minYPlane = null;\n      maxYPlane = null;\n      minZPlane = null;\n      maxZPlane = null;\n      notableMinXPoints = null;\n      notableMaxXPoints = null;\n      notableMinYPoints = null;\n      notableMaxYPoints = null;\n      notableMinZPoints = null;\n      notableMaxZPoints = null;\n      edgePoints = null;\n    } else {\n      // Construct the planes\n      minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n      maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n      minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n      maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n      minZPlane = new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);\n      maxZPlane = new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);\n      \n      // We need at least one point on the planet surface for each manifestation of the shape.\n      // There can be up to 2 (on opposite sides of the world).  But we have to go through\n      // 12 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n      // Typically, this requires 12 square root operations. \n      final GeoPoint[] minXminY = minXPlane.findIntersections(planetModel,minYPlane,maxXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXmaxY = minXPlane.findIntersections(planetModel,maxYPlane,maxXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXminZ = minXPlane.findIntersections(planetModel,minZPlane,maxXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] minXmaxZ = minXPlane.findIntersections(planetModel,maxZPlane,maxXPlane,minZPlane,minYPlane,maxYPlane);\n\n      final GeoPoint[] maxXminY = maxXPlane.findIntersections(planetModel,minYPlane,minXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXmaxY = maxXPlane.findIntersections(planetModel,maxYPlane,minXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXminZ = maxXPlane.findIntersections(planetModel,minZPlane,minXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] maxXmaxZ = maxXPlane.findIntersections(planetModel,maxZPlane,minXPlane,minZPlane,minYPlane,maxYPlane);\n      \n      final GeoPoint[] minYminZ = minYPlane.findIntersections(planetModel,minZPlane,maxYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] minYmaxZ = minYPlane.findIntersections(planetModel,maxZPlane,maxYPlane,minZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYminZ = maxYPlane.findIntersections(planetModel,minZPlane,minYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYmaxZ = maxYPlane.findIntersections(planetModel,maxZPlane,minYPlane,minZPlane,minXPlane,maxXPlane);\n      \n      notableMinXPoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ);\n      notableMaxXPoints = glueTogether(maxXminY, maxXmaxY, maxXminZ, maxXmaxZ);\n      notableMinYPoints = glueTogether(minXminY, maxXminY, minYminZ, minYmaxZ);\n      notableMaxYPoints = glueTogether(minXmaxY, maxXmaxY, maxYminZ, maxYmaxZ);\n      notableMinZPoints = glueTogether(minXminZ, maxXminZ, minYminZ, maxYminZ);\n      notableMaxZPoints = glueTogether(minXmaxZ, maxXmaxZ, minYmaxZ, maxYmaxZ);\n\n      // Now, compute the edge points.\n      // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n      // we'll start there.\n      // There can be a number of shapes, each of which needs an edgepoint.  Each side by itself might contribute\n      // an edgepoint, for instance, if the plane describing that side intercepts the planet in such a way that the ellipse\n      // of interception does not meet any other planes.  Plane intersections can each contribute 0, 1, or 2 edgepoints.\n      //\n      // All of this makes for a lot of potential edgepoints, but I believe these can be pruned back with careful analysis.\n      // I haven't yet done that analysis, however, so I will treat them all as individual edgepoints.\n      \n      // The cases we are looking for are when the four corner points for any given\n      // plane are all outside of the world, AND that plane intersects the world.\n      // There are eight corner points all told; we must evaluate these WRT the planet surface.\n      final boolean minXminYminZ = planetModel.pointOutside(minX, minY, minZ);\n      final boolean minXminYmaxZ = planetModel.pointOutside(minX, minY, maxZ);\n      final boolean minXmaxYminZ = planetModel.pointOutside(minX, maxY, minZ);\n      final boolean minXmaxYmaxZ = planetModel.pointOutside(minX, maxY, maxZ);\n      final boolean maxXminYminZ = planetModel.pointOutside(maxX, minY, minZ);\n      final boolean maxXminYmaxZ = planetModel.pointOutside(maxX, minY, maxZ);\n      final boolean maxXmaxYminZ = planetModel.pointOutside(maxX, maxY, minZ);\n      final boolean maxXmaxYmaxZ = planetModel.pointOutside(maxX, maxY, maxZ);\n        \n      // Look at single-plane/world intersections.\n      // We detect these by looking at the world model and noting its x, y, and z bounds.\n\n      final GeoPoint[] minXEdges;\n      if (minX - worldMinX >= -Vector.MINIMUM_RESOLUTION && minX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && minXmaxYminZ && minXmaxYmaxZ) {\n        // Find any point on the minX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minXEdges = new GeoPoint[]{intPoint};\n        } else {\n          // No intersection found?\n          minXEdges = EMPTY_POINTS;\n        }\n      } else {\n        minXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxXEdges;\n      if (maxX - worldMinX >= -Vector.MINIMUM_RESOLUTION && maxX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        maxXminYminZ && maxXminYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxXEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxXEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minYEdges;\n      if (minY - worldMinY >= -Vector.MINIMUM_RESOLUTION && minY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && maxXminYminZ && maxXminYmaxZ) {\n        // Find any point on the minY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          minYEdges = new GeoPoint[]{intPoint};\n        } else {\n          minYEdges = EMPTY_POINTS;\n        }\n      } else {\n        minYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxYEdges;\n      if (maxY - worldMinY >= -Vector.MINIMUM_RESOLUTION && maxY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXmaxYminZ && minXmaxYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          maxYEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxYEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minZEdges;\n      if (minZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && minZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYminZ && minXmaxYminZ && maxXminYminZ && maxXmaxYminZ) {\n        // Find any point on the minZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minZEdges = new GeoPoint[]{intPoint};\n        } else {\n          minZEdges = EMPTY_POINTS;\n        }\n      } else {\n        minZEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxZEdges;\n      if (maxZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && maxZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYmaxZ && minXmaxYmaxZ && maxXminYmaxZ && maxXmaxYmaxZ) {\n        // Find any point on the maxZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0) (that is, its orientation doesn't matter)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxZEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxZEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxZEdges = EMPTY_POINTS;\n      }\n      \n      // Glue everything together.  This is not a minimal set of edgepoints, as of now, but it does completely describe all shapes on the\n      // planet.\n      this.edgePoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ,\n        maxXminY, maxXmaxY, maxXminZ, maxXmaxZ,\n        minYminZ, minYmaxZ, maxYminZ, maxYmaxZ,\n        minXEdges, maxXEdges, minYEdges, maxYEdges, minZEdges, maxZEdges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param minZ is the minimum Z value.\n   *@param maxZ is the maximum Z value.\n   */\n  public XYZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double minZ,\n    final double maxZ) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n    if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Z values in wrong order or identical\");\n\n    final double worldMinX = planetModel.getMinimumXValue();\n    final double worldMaxX = planetModel.getMaximumXValue();\n    final double worldMinY = planetModel.getMinimumYValue();\n    final double worldMaxY = planetModel.getMaximumYValue();\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // We must distinguish between the case where the solid represents the entire world,\n    // and when the solid has no overlap with any part of the surface.  In both cases,\n    // there will be no edgepoints.\n    isWholeWorld =\n        (minX - worldMinX < -Vector.MINIMUM_RESOLUTION) &&\n        (maxX - worldMaxX > Vector.MINIMUM_RESOLUTION) &&\n        (minY - worldMinY < -Vector.MINIMUM_RESOLUTION) &&\n        (maxY - worldMaxY > Vector.MINIMUM_RESOLUTION) &&\n        (minZ - worldMinZ < -Vector.MINIMUM_RESOLUTION) &&\n        (maxZ - worldMaxZ > Vector.MINIMUM_RESOLUTION);\n\n    if (isWholeWorld) {\n      minXPlane = null;\n      maxXPlane = null;\n      minYPlane = null;\n      maxYPlane = null;\n      minZPlane = null;\n      maxZPlane = null;\n      notableMinXPoints = null;\n      notableMaxXPoints = null;\n      notableMinYPoints = null;\n      notableMaxYPoints = null;\n      notableMinZPoints = null;\n      notableMaxZPoints = null;\n      edgePoints = null;\n    } else {\n      // Construct the planes\n      minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n      maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n      minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n      maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n      minZPlane = new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);\n      maxZPlane = new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);\n      \n      // We need at least one point on the planet surface for each manifestation of the shape.\n      // There can be up to 2 (on opposite sides of the world).  But we have to go through\n      // 12 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n      // Typically, this requires 12 square root operations. \n      final GeoPoint[] minXminY = minXPlane.findIntersections(planetModel,minYPlane,maxXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXmaxY = minXPlane.findIntersections(planetModel,maxYPlane,maxXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXminZ = minXPlane.findIntersections(planetModel,minZPlane,maxXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] minXmaxZ = minXPlane.findIntersections(planetModel,maxZPlane,maxXPlane,minZPlane,minYPlane,maxYPlane);\n\n      final GeoPoint[] maxXminY = maxXPlane.findIntersections(planetModel,minYPlane,minXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXmaxY = maxXPlane.findIntersections(planetModel,maxYPlane,minXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXminZ = maxXPlane.findIntersections(planetModel,minZPlane,minXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] maxXmaxZ = maxXPlane.findIntersections(planetModel,maxZPlane,minXPlane,minZPlane,minYPlane,maxYPlane);\n      \n      final GeoPoint[] minYminZ = minYPlane.findIntersections(planetModel,minZPlane,maxYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] minYmaxZ = minYPlane.findIntersections(planetModel,maxZPlane,maxYPlane,minZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYminZ = maxYPlane.findIntersections(planetModel,minZPlane,minYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYmaxZ = maxYPlane.findIntersections(planetModel,maxZPlane,minYPlane,minZPlane,minXPlane,maxXPlane);\n      \n      notableMinXPoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ);\n      notableMaxXPoints = glueTogether(maxXminY, maxXmaxY, maxXminZ, maxXmaxZ);\n      notableMinYPoints = glueTogether(minXminY, maxXminY, minYminZ, minYmaxZ);\n      notableMaxYPoints = glueTogether(minXmaxY, maxXmaxY, maxYminZ, maxYmaxZ);\n      notableMinZPoints = glueTogether(minXminZ, maxXminZ, minYminZ, maxYminZ);\n      notableMaxZPoints = glueTogether(minXmaxZ, maxXmaxZ, minYmaxZ, maxYmaxZ);\n\n      // Now, compute the edge points.\n      // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n      // we'll start there.\n      // There can be a number of shapes, each of which needs an edgepoint.  Each side by itself might contribute\n      // an edgepoint, for instance, if the plane describing that side intercepts the planet in such a way that the ellipse\n      // of interception does not meet any other planes.  Plane intersections can each contribute 0, 1, or 2 edgepoints.\n      //\n      // All of this makes for a lot of potential edgepoints, but I believe these can be pruned back with careful analysis.\n      // I haven't yet done that analysis, however, so I will treat them all as individual edgepoints.\n      \n      // The cases we are looking for are when the four corner points for any given\n      // plane are all outside of the world, AND that plane intersects the world.\n      // There are eight corner points all told; we must evaluate these WRT the planet surface.\n      final boolean minXminYminZ = planetModel.pointOutside(minX, minY, minZ);\n      final boolean minXminYmaxZ = planetModel.pointOutside(minX, minY, maxZ);\n      final boolean minXmaxYminZ = planetModel.pointOutside(minX, maxY, minZ);\n      final boolean minXmaxYmaxZ = planetModel.pointOutside(minX, maxY, maxZ);\n      final boolean maxXminYminZ = planetModel.pointOutside(maxX, minY, minZ);\n      final boolean maxXminYmaxZ = planetModel.pointOutside(maxX, minY, maxZ);\n      final boolean maxXmaxYminZ = planetModel.pointOutside(maxX, maxY, minZ);\n      final boolean maxXmaxYmaxZ = planetModel.pointOutside(maxX, maxY, maxZ);\n        \n      // Look at single-plane/world intersections.\n      // We detect these by looking at the world model and noting its x, y, and z bounds.\n\n      final GeoPoint[] minXEdges;\n      if (minX - worldMinX >= -Vector.MINIMUM_RESOLUTION && minX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && minXmaxYminZ && minXmaxYmaxZ) {\n        // Find any point on the minX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        minXEdges = new GeoPoint[]{minXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        minXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxXEdges;\n      if (maxX - worldMinX >= -Vector.MINIMUM_RESOLUTION && maxX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        maxXminYminZ && maxXminYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        maxXEdges = new GeoPoint[]{maxXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        maxXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minYEdges;\n      if (minY - worldMinY >= -Vector.MINIMUM_RESOLUTION && minY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && maxXminYminZ && maxXminYmaxZ) {\n        // Find any point on the minY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        minYEdges = new GeoPoint[]{minYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane)};\n      } else {\n        minYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxYEdges;\n      if (maxY - worldMinY >= -Vector.MINIMUM_RESOLUTION && maxY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXmaxYminZ && minXmaxYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        maxYEdges = new GeoPoint[]{maxYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane)};\n      } else {\n        maxYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minZEdges;\n      if (minZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && minZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYminZ && minXmaxYminZ && maxXminYminZ && maxXmaxYminZ) {\n        // Find any point on the minZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        minZEdges = new GeoPoint[]{minZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        minZEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxZEdges;\n      if (maxZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && maxZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYmaxZ && minXmaxYmaxZ && maxXminYmaxZ && maxXmaxYmaxZ) {\n        // Find any point on the maxZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0) (that is, its orientation doesn't matter)\n        // Then use it to compute a sample point.\n        maxZEdges = new GeoPoint[]{maxZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane)};\n      } else {\n        maxZEdges = EMPTY_POINTS;\n      }\n      \n      // Glue everything together.  This is not a minimal set of edgepoints, as of now, but it does completely describe all shapes on the\n      // planet.\n      this.edgePoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ,\n        maxXminY, maxXmaxY, maxXminZ, maxXmaxZ,\n        minYminZ, minYmaxZ, maxYminZ, maxYmaxZ,\n        minXEdges, maxXEdges, minYEdges, maxYEdges, minZEdges, maxZEdges);\n    }\n  }\n\n","bugFix":["f64b7098768253180859cd8faeae6b1a185b06ed"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb2e534491f753a302fda3fc99c81120482bba19","date":1441977047,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/StandardXYZSolid#StandardXYZSolid(PlanetModel,double,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYZSolid#XYZSolid(PlanetModel,double,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param minZ is the minimum Z value.\n   *@param maxZ is the maximum Z value.\n   */\n  public StandardXYZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double minZ,\n    final double maxZ) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n    if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Z values in wrong order or identical\");\n\n    final double worldMinX = planetModel.getMinimumXValue();\n    final double worldMaxX = planetModel.getMaximumXValue();\n    final double worldMinY = planetModel.getMinimumYValue();\n    final double worldMaxY = planetModel.getMaximumYValue();\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // We must distinguish between the case where the solid represents the entire world,\n    // and when the solid has no overlap with any part of the surface.  In both cases,\n    // there will be no edgepoints.\n    isWholeWorld =\n        (minX - worldMinX < -Vector.MINIMUM_RESOLUTION) &&\n        (maxX - worldMaxX > Vector.MINIMUM_RESOLUTION) &&\n        (minY - worldMinY < -Vector.MINIMUM_RESOLUTION) &&\n        (maxY - worldMaxY > Vector.MINIMUM_RESOLUTION) &&\n        (minZ - worldMinZ < -Vector.MINIMUM_RESOLUTION) &&\n        (maxZ - worldMaxZ > Vector.MINIMUM_RESOLUTION);\n\n    if (isWholeWorld) {\n      minXPlane = null;\n      maxXPlane = null;\n      minYPlane = null;\n      maxYPlane = null;\n      minZPlane = null;\n      maxZPlane = null;\n      notableMinXPoints = null;\n      notableMaxXPoints = null;\n      notableMinYPoints = null;\n      notableMaxYPoints = null;\n      notableMinZPoints = null;\n      notableMaxZPoints = null;\n      edgePoints = null;\n    } else {\n      // Construct the planes\n      minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n      maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n      minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n      maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n      minZPlane = new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);\n      maxZPlane = new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);\n      \n      // We need at least one point on the planet surface for each manifestation of the shape.\n      // There can be up to 2 (on opposite sides of the world).  But we have to go through\n      // 12 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n      // Typically, this requires 12 square root operations. \n      final GeoPoint[] minXminY = minXPlane.findIntersections(planetModel,minYPlane,maxXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXmaxY = minXPlane.findIntersections(planetModel,maxYPlane,maxXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXminZ = minXPlane.findIntersections(planetModel,minZPlane,maxXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] minXmaxZ = minXPlane.findIntersections(planetModel,maxZPlane,maxXPlane,minZPlane,minYPlane,maxYPlane);\n\n      final GeoPoint[] maxXminY = maxXPlane.findIntersections(planetModel,minYPlane,minXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXmaxY = maxXPlane.findIntersections(planetModel,maxYPlane,minXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXminZ = maxXPlane.findIntersections(planetModel,minZPlane,minXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] maxXmaxZ = maxXPlane.findIntersections(planetModel,maxZPlane,minXPlane,minZPlane,minYPlane,maxYPlane);\n      \n      final GeoPoint[] minYminZ = minYPlane.findIntersections(planetModel,minZPlane,maxYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] minYmaxZ = minYPlane.findIntersections(planetModel,maxZPlane,maxYPlane,minZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYminZ = maxYPlane.findIntersections(planetModel,minZPlane,minYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYmaxZ = maxYPlane.findIntersections(planetModel,maxZPlane,minYPlane,minZPlane,minXPlane,maxXPlane);\n      \n      notableMinXPoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ);\n      notableMaxXPoints = glueTogether(maxXminY, maxXmaxY, maxXminZ, maxXmaxZ);\n      notableMinYPoints = glueTogether(minXminY, maxXminY, minYminZ, minYmaxZ);\n      notableMaxYPoints = glueTogether(minXmaxY, maxXmaxY, maxYminZ, maxYmaxZ);\n      notableMinZPoints = glueTogether(minXminZ, maxXminZ, minYminZ, maxYminZ);\n      notableMaxZPoints = glueTogether(minXmaxZ, maxXmaxZ, minYmaxZ, maxYmaxZ);\n\n      // Now, compute the edge points.\n      // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n      // we'll start there.\n      // There can be a number of shapes, each of which needs an edgepoint.  Each side by itself might contribute\n      // an edgepoint, for instance, if the plane describing that side intercepts the planet in such a way that the ellipse\n      // of interception does not meet any other planes.  Plane intersections can each contribute 0, 1, or 2 edgepoints.\n      //\n      // All of this makes for a lot of potential edgepoints, but I believe these can be pruned back with careful analysis.\n      // I haven't yet done that analysis, however, so I will treat them all as individual edgepoints.\n      \n      // The cases we are looking for are when the four corner points for any given\n      // plane are all outside of the world, AND that plane intersects the world.\n      // There are eight corner points all told; we must evaluate these WRT the planet surface.\n      final boolean minXminYminZ = planetModel.pointOutside(minX, minY, minZ);\n      final boolean minXminYmaxZ = planetModel.pointOutside(minX, minY, maxZ);\n      final boolean minXmaxYminZ = planetModel.pointOutside(minX, maxY, minZ);\n      final boolean minXmaxYmaxZ = planetModel.pointOutside(minX, maxY, maxZ);\n      final boolean maxXminYminZ = planetModel.pointOutside(maxX, minY, minZ);\n      final boolean maxXminYmaxZ = planetModel.pointOutside(maxX, minY, maxZ);\n      final boolean maxXmaxYminZ = planetModel.pointOutside(maxX, maxY, minZ);\n      final boolean maxXmaxYmaxZ = planetModel.pointOutside(maxX, maxY, maxZ);\n        \n      // Look at single-plane/world intersections.\n      // We detect these by looking at the world model and noting its x, y, and z bounds.\n\n      final GeoPoint[] minXEdges;\n      if (minX - worldMinX >= -Vector.MINIMUM_RESOLUTION && minX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && minXmaxYminZ && minXmaxYmaxZ) {\n        // Find any point on the minX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minXEdges = new GeoPoint[]{intPoint};\n        } else {\n          // No intersection found?\n          minXEdges = EMPTY_POINTS;\n        }\n      } else {\n        minXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxXEdges;\n      if (maxX - worldMinX >= -Vector.MINIMUM_RESOLUTION && maxX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        maxXminYminZ && maxXminYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxXEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxXEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minYEdges;\n      if (minY - worldMinY >= -Vector.MINIMUM_RESOLUTION && minY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && maxXminYminZ && maxXminYmaxZ) {\n        // Find any point on the minY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          minYEdges = new GeoPoint[]{intPoint};\n        } else {\n          minYEdges = EMPTY_POINTS;\n        }\n      } else {\n        minYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxYEdges;\n      if (maxY - worldMinY >= -Vector.MINIMUM_RESOLUTION && maxY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXmaxYminZ && minXmaxYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          maxYEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxYEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minZEdges;\n      if (minZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && minZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYminZ && minXmaxYminZ && maxXminYminZ && maxXmaxYminZ) {\n        // Find any point on the minZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minZEdges = new GeoPoint[]{intPoint};\n        } else {\n          minZEdges = EMPTY_POINTS;\n        }\n      } else {\n        minZEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxZEdges;\n      if (maxZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && maxZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYmaxZ && minXmaxYmaxZ && maxXminYmaxZ && maxXmaxYmaxZ) {\n        // Find any point on the maxZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0) (that is, its orientation doesn't matter)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxZEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxZEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxZEdges = EMPTY_POINTS;\n      }\n      \n      // Glue everything together.  This is not a minimal set of edgepoints, as of now, but it does completely describe all shapes on the\n      // planet.\n      this.edgePoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ,\n        maxXminY, maxXmaxY, maxXminZ, maxXmaxZ,\n        minYminZ, minYmaxZ, maxYminZ, maxYmaxZ,\n        minXEdges, maxXEdges, minYEdges, maxYEdges, minZEdges, maxZEdges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param minZ is the minimum Z value.\n   *@param maxZ is the maximum Z value.\n   */\n  public XYZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double minZ,\n    final double maxZ) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n    if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Z values in wrong order or identical\");\n\n    final double worldMinX = planetModel.getMinimumXValue();\n    final double worldMaxX = planetModel.getMaximumXValue();\n    final double worldMinY = planetModel.getMinimumYValue();\n    final double worldMaxY = planetModel.getMaximumYValue();\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // We must distinguish between the case where the solid represents the entire world,\n    // and when the solid has no overlap with any part of the surface.  In both cases,\n    // there will be no edgepoints.\n    isWholeWorld =\n        (minX - worldMinX < -Vector.MINIMUM_RESOLUTION) &&\n        (maxX - worldMaxX > Vector.MINIMUM_RESOLUTION) &&\n        (minY - worldMinY < -Vector.MINIMUM_RESOLUTION) &&\n        (maxY - worldMaxY > Vector.MINIMUM_RESOLUTION) &&\n        (minZ - worldMinZ < -Vector.MINIMUM_RESOLUTION) &&\n        (maxZ - worldMaxZ > Vector.MINIMUM_RESOLUTION);\n\n    if (isWholeWorld) {\n      minXPlane = null;\n      maxXPlane = null;\n      minYPlane = null;\n      maxYPlane = null;\n      minZPlane = null;\n      maxZPlane = null;\n      notableMinXPoints = null;\n      notableMaxXPoints = null;\n      notableMinYPoints = null;\n      notableMaxYPoints = null;\n      notableMinZPoints = null;\n      notableMaxZPoints = null;\n      edgePoints = null;\n    } else {\n      // Construct the planes\n      minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n      maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n      minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n      maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n      minZPlane = new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);\n      maxZPlane = new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);\n      \n      // We need at least one point on the planet surface for each manifestation of the shape.\n      // There can be up to 2 (on opposite sides of the world).  But we have to go through\n      // 12 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n      // Typically, this requires 12 square root operations. \n      final GeoPoint[] minXminY = minXPlane.findIntersections(planetModel,minYPlane,maxXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXmaxY = minXPlane.findIntersections(planetModel,maxYPlane,maxXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] minXminZ = minXPlane.findIntersections(planetModel,minZPlane,maxXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] minXmaxZ = minXPlane.findIntersections(planetModel,maxZPlane,maxXPlane,minZPlane,minYPlane,maxYPlane);\n\n      final GeoPoint[] maxXminY = maxXPlane.findIntersections(planetModel,minYPlane,minXPlane,maxYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXmaxY = maxXPlane.findIntersections(planetModel,maxYPlane,minXPlane,minYPlane,minZPlane,maxZPlane);\n      final GeoPoint[] maxXminZ = maxXPlane.findIntersections(planetModel,minZPlane,minXPlane,maxZPlane,minYPlane,maxYPlane);\n      final GeoPoint[] maxXmaxZ = maxXPlane.findIntersections(planetModel,maxZPlane,minXPlane,minZPlane,minYPlane,maxYPlane);\n      \n      final GeoPoint[] minYminZ = minYPlane.findIntersections(planetModel,minZPlane,maxYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] minYmaxZ = minYPlane.findIntersections(planetModel,maxZPlane,maxYPlane,minZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYminZ = maxYPlane.findIntersections(planetModel,minZPlane,minYPlane,maxZPlane,minXPlane,maxXPlane);\n      final GeoPoint[] maxYmaxZ = maxYPlane.findIntersections(planetModel,maxZPlane,minYPlane,minZPlane,minXPlane,maxXPlane);\n      \n      notableMinXPoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ);\n      notableMaxXPoints = glueTogether(maxXminY, maxXmaxY, maxXminZ, maxXmaxZ);\n      notableMinYPoints = glueTogether(minXminY, maxXminY, minYminZ, minYmaxZ);\n      notableMaxYPoints = glueTogether(minXmaxY, maxXmaxY, maxYminZ, maxYmaxZ);\n      notableMinZPoints = glueTogether(minXminZ, maxXminZ, minYminZ, maxYminZ);\n      notableMaxZPoints = glueTogether(minXmaxZ, maxXmaxZ, minYmaxZ, maxYmaxZ);\n\n      // Now, compute the edge points.\n      // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n      // we'll start there.\n      // There can be a number of shapes, each of which needs an edgepoint.  Each side by itself might contribute\n      // an edgepoint, for instance, if the plane describing that side intercepts the planet in such a way that the ellipse\n      // of interception does not meet any other planes.  Plane intersections can each contribute 0, 1, or 2 edgepoints.\n      //\n      // All of this makes for a lot of potential edgepoints, but I believe these can be pruned back with careful analysis.\n      // I haven't yet done that analysis, however, so I will treat them all as individual edgepoints.\n      \n      // The cases we are looking for are when the four corner points for any given\n      // plane are all outside of the world, AND that plane intersects the world.\n      // There are eight corner points all told; we must evaluate these WRT the planet surface.\n      final boolean minXminYminZ = planetModel.pointOutside(minX, minY, minZ);\n      final boolean minXminYmaxZ = planetModel.pointOutside(minX, minY, maxZ);\n      final boolean minXmaxYminZ = planetModel.pointOutside(minX, maxY, minZ);\n      final boolean minXmaxYmaxZ = planetModel.pointOutside(minX, maxY, maxZ);\n      final boolean maxXminYminZ = planetModel.pointOutside(maxX, minY, minZ);\n      final boolean maxXminYmaxZ = planetModel.pointOutside(maxX, minY, maxZ);\n      final boolean maxXmaxYminZ = planetModel.pointOutside(maxX, maxY, minZ);\n      final boolean maxXmaxYmaxZ = planetModel.pointOutside(maxX, maxY, maxZ);\n        \n      // Look at single-plane/world intersections.\n      // We detect these by looking at the world model and noting its x, y, and z bounds.\n\n      final GeoPoint[] minXEdges;\n      if (minX - worldMinX >= -Vector.MINIMUM_RESOLUTION && minX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && minXmaxYminZ && minXmaxYmaxZ) {\n        // Find any point on the minX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minXEdges = new GeoPoint[]{intPoint};\n        } else {\n          // No intersection found?\n          minXEdges = EMPTY_POINTS;\n        }\n      } else {\n        minXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxXEdges;\n      if (maxX - worldMinX >= -Vector.MINIMUM_RESOLUTION && maxX - worldMaxX <= Vector.MINIMUM_RESOLUTION &&\n        minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        maxXminYminZ && maxXminYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxX plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxXPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxXEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxXEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxXEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minYEdges;\n      if (minY - worldMinY >= -Vector.MINIMUM_RESOLUTION && minY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXminYminZ && minXminYmaxZ && maxXminYminZ && maxXminYmaxZ) {\n        // Find any point on the minY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          minYEdges = new GeoPoint[]{intPoint};\n        } else {\n          minYEdges = EMPTY_POINTS;\n        }\n      } else {\n        minYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxYEdges;\n      if (maxY - worldMinY >= -Vector.MINIMUM_RESOLUTION && maxY - worldMaxY <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 &&\n        minXmaxYminZ && minXmaxYmaxZ && maxXmaxYminZ && maxXmaxYmaxZ) {\n        // Find any point on the maxY plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (0,1,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxYPlane.getSampleIntersectionPoint(planetModel, yVerticalPlane);\n        if (intPoint != null) {\n          maxYEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxYEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxYEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] minZEdges;\n      if (minZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && minZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYminZ && minXmaxYminZ && maxXminYminZ && maxXmaxYminZ) {\n        // Find any point on the minZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = minZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          minZEdges = new GeoPoint[]{intPoint};\n        } else {\n          minZEdges = EMPTY_POINTS;\n        }\n      } else {\n        minZEdges = EMPTY_POINTS;\n      }\n      \n      final GeoPoint[] maxZEdges;\n      if (maxZ - worldMinZ >= -Vector.MINIMUM_RESOLUTION && maxZ - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n        minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n        minXminYmaxZ && minXmaxYmaxZ && maxXminYmaxZ && maxXmaxYmaxZ) {\n        // Find any point on the maxZ plane that intersects the world\n        // First construct a perpendicular plane that will allow us to find a sample point.\n        // This plane is vertical and goes through the points (0,0,0) and (1,0,0) (that is, its orientation doesn't matter)\n        // Then use it to compute a sample point.\n        final GeoPoint intPoint = maxZPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n        if (intPoint != null) {\n          maxZEdges = new GeoPoint[]{intPoint};\n        } else {\n          maxZEdges = EMPTY_POINTS;\n        }\n      } else {\n        maxZEdges = EMPTY_POINTS;\n      }\n      \n      // Glue everything together.  This is not a minimal set of edgepoints, as of now, but it does completely describe all shapes on the\n      // planet.\n      this.edgePoints = glueTogether(minXminY, minXmaxY, minXminZ, minXmaxZ,\n        maxXminY, maxXmaxY, maxXminZ, maxXmaxZ,\n        minYminZ, minYmaxZ, maxYminZ, maxYmaxZ,\n        minXEdges, maxXEdges, minYEdges, maxYEdges, minZEdges, maxZEdges);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d8f71af177fad4bbfdf462d318247e573faac27f":["f64b7098768253180859cd8faeae6b1a185b06ed"],"fb2e534491f753a302fda3fc99c81120482bba19":["d8f71af177fad4bbfdf462d318247e573faac27f"],"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb2e534491f753a302fda3fc99c81120482bba19"]},"commit2Childs":{"d8f71af177fad4bbfdf462d318247e573faac27f":["fb2e534491f753a302fda3fc99c81120482bba19"],"f64b7098768253180859cd8faeae6b1a185b06ed":["d8f71af177fad4bbfdf462d318247e573faac27f"],"fb2e534491f753a302fda3fc99c81120482bba19":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}