{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexReader#FieldsIndexReader(Directory,String,String,String,String,byte[],IndexInput).mjava","commits":[{"id":"2b78d8dfe50af510bace3600bfc4cfa0b031f776","date":1598430423,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexReader#FieldsIndexReader(Directory,String,String,String,String,byte[],IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexReader#FieldsIndexReader(Directory,String,String,String,String,byte[]).mjava","sourceNew":"  FieldsIndexReader(Directory dir, String name, String suffix, String extension, String codecName, byte[] id, IndexInput metaIn) throws IOException {\n    maxDoc = metaIn.readInt();\n    blockShift = metaIn.readInt();\n    numChunks = metaIn.readInt();\n    docsStartPointer = metaIn.readLong();\n    docsMeta = DirectMonotonicReader.loadMeta(metaIn, numChunks, blockShift);\n    docsEndPointer = startPointersStartPointer = metaIn.readLong();\n    startPointersMeta = DirectMonotonicReader.loadMeta(metaIn, numChunks, blockShift);\n    startPointersEndPointer = metaIn.readLong();\n    maxPointer = metaIn.readLong();\n\n    indexInput = dir.openInput(IndexFileNames.segmentFileName(name, suffix, extension), IOContext.READ);\n    boolean success = false;\n    try {\n      CodecUtil.checkIndexHeader(indexInput, codecName + \"Idx\", VERSION_START, VERSION_CURRENT, id, suffix);\n      CodecUtil.retrieveChecksum(indexInput);\n      success = true;\n    } finally {\n      if (success == false) {\n        indexInput.close();\n      }\n    }\n    final RandomAccessInput docsSlice = indexInput.randomAccessSlice(docsStartPointer, docsEndPointer - docsStartPointer);\n    final RandomAccessInput startPointersSlice = indexInput.randomAccessSlice(startPointersStartPointer, startPointersEndPointer - startPointersStartPointer);\n    docs = DirectMonotonicReader.getInstance(docsMeta, docsSlice);\n    startPointers = DirectMonotonicReader.getInstance(startPointersMeta, startPointersSlice);\n  }\n\n","sourceOld":"  FieldsIndexReader(Directory dir, String name, String suffix, String extensionPrefix, String codecName, byte[] id) throws IOException {\n    try (ChecksumIndexInput metaIn = dir.openChecksumInput(IndexFileNames.segmentFileName(name, suffix, extensionPrefix + FIELDS_META_EXTENSION_SUFFIX), IOContext.READONCE)) {\n      Throwable priorE = null;\n      try {\n        CodecUtil.checkIndexHeader(metaIn, codecName + \"Meta\", VERSION_START, VERSION_CURRENT, id, suffix);\n        maxDoc = metaIn.readInt();\n        blockShift = metaIn.readInt();\n        numChunks = metaIn.readInt();\n        docsStartPointer = metaIn.readLong();\n        docsMeta = DirectMonotonicReader.loadMeta(metaIn, numChunks, blockShift);\n        docsEndPointer = startPointersStartPointer = metaIn.readLong();\n        startPointersMeta = DirectMonotonicReader.loadMeta(metaIn, numChunks, blockShift);\n        startPointersEndPointer = metaIn.readLong();\n        maxPointer = metaIn.readLong();\n      } finally {\n        CodecUtil.checkFooter(metaIn, priorE);\n      }\n    }\n\n    indexInput = dir.openInput(IndexFileNames.segmentFileName(name, suffix, extensionPrefix + FIELDS_INDEX_EXTENSION_SUFFIX), IOContext.READ);\n    boolean success = false;\n    try {\n      CodecUtil.checkIndexHeader(indexInput, codecName + \"Idx\", VERSION_START, VERSION_CURRENT, id, suffix);\n      CodecUtil.retrieveChecksum(indexInput);\n      success = true;\n    } finally {\n      if (success == false) {\n        indexInput.close();\n      }\n    }\n    final RandomAccessInput docsSlice = indexInput.randomAccessSlice(docsStartPointer, docsEndPointer - docsStartPointer);\n    final RandomAccessInput startPointersSlice = indexInput.randomAccessSlice(startPointersStartPointer, startPointersEndPointer - startPointersStartPointer);\n    docs = DirectMonotonicReader.getInstance(docsMeta, docsSlice);\n    startPointers = DirectMonotonicReader.getInstance(startPointersMeta, startPointersSlice);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2b78d8dfe50af510bace3600bfc4cfa0b031f776":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b78d8dfe50af510bace3600bfc4cfa0b031f776"]},"commit2Childs":{"2b78d8dfe50af510bace3600bfc4cfa0b031f776":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2b78d8dfe50af510bace3600bfc4cfa0b031f776"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}