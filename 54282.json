{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","commits":[{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":2,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.CrossingEdgeIterator#countCrossingPoint(GeoPoint,Plane,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      final Plane plane;\n      final Plane abovePlane;\n      final Plane belowPlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        abovePlane = travelAbovePlane;\n        belowPlane = travelBelowPlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        abovePlane = testPointAbovePlane;\n        belowPlane = testPointBelowPlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n      \n      // MHL - this code below is temporary code copied from LinearCrossing above\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Plane plane, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb","date":1461671204,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n      \n      // MHL - this code below is temporary code copied from LinearCrossing above\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideIntersections = insidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideIntersections = outsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(insideIntersections.length > 0 && outsideIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (insideIntersections.length == 0 && outsideIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideIntersections;\n        GeoPoint[] assessOutsideIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideIntersections = insidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideIntersections = outsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideIntersections.length > 0 && assessOutsideIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideIntersections.length == 0 && assessOutsideIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeInside = assessInsideIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideIntersections = insidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideIntersections = outsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(insideIntersections.length > 0 && outsideIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (insideIntersections.length == 0 && outsideIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideIntersections;\n        GeoPoint[] assessOutsideIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideIntersections = insidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideIntersections = outsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideIntersections.length > 0 && assessOutsideIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideIntersections.length == 0 && assessOutsideIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      final Plane plane;\n      final Plane abovePlane;\n      final Plane belowPlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        abovePlane = travelAbovePlane;\n        belowPlane = travelBelowPlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        abovePlane = testPointAbovePlane;\n        belowPlane = testPointBelowPlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n      \n      // MHL - this code below is temporary code copied from LinearCrossing above\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0108af7050cbe916cac082bcce73081e33e46ce","date":1461692987,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        // Intersection point crossing\n        \n        // MHL to deal with intersection point crossing!!\n        \n      } else {\n        // Standard plane crossing, either first leg or second leg\n      \n        final Plane plane;\n        final Plane insidePlane;\n        final Plane outsidePlane;\n        final SidedPlane bound1;\n        final SidedPlane bound2;\n        if (isSecondLeg) {\n          plane = travelPlane;\n          insidePlane = travelInsidePlane;\n          outsidePlane = travelOutsidePlane;\n          bound1 = checkPointCutoffPlane;\n          bound2 = checkPointOtherCutoffPlane;\n        } else {\n          plane = testPointPlane;\n          insidePlane = testPointInsidePlane;\n          outsidePlane = testPointOutsidePlane;\n          bound1 = testPointCutoffPlane;\n          bound2 = testPointOtherCutoffPlane;\n        }\n        \n        if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n          // We have to figure out if this crossing should be counted.\n          \n          // Does the crossing for this edge go up, or down?  Or can't we tell?\n          final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n          final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n          final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n          assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n          if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n            return;\n          }\n\n          final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n          // This depends on the previous edge that first departs from identicalness.\n          Edge assessEdge = edge;\n          GeoPoint[] assessInsideTestPointIntersections;\n          GeoPoint[] assessInsideTravelIntersections;\n          GeoPoint[] assessOutsideTestPointIntersections;\n          GeoPoint[] assessOutsideTravelIntersections;\n          while (true) {\n            assessEdge = assessEdge.previous;\n            assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n            assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n            assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n            assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n            assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n            if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n              continue;\n            }\n            break;\n          }\n\n          // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n          // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n          // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n          // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n          // a decision whether to count or not based on that.\n          \n          // Compute the crossing points of this other edge.\n          final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n          // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n          // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n          for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n            if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n              // Found it!\n              // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n              // Since we're the latter point, we exit here in that case.\n              return;\n            }\n          }\n          \n          // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n          // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n          // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n          final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n          if (assessEdgeInside != edgeCrossesInside) {\n            crossingCount++;\n          }\n          \n        } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n          // Figure out if the crossing should be counted.\n          \n          // Does the crossing for this edge go up, or down?  Or can't we tell?\n          final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n          final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n          final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n          assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n          if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n            return;\n          }\n\n          final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n          // This depends on the previous edge that first departs from identicalness.\n          Edge assessEdge = edge;\n          GeoPoint[] assessInsideTestPointIntersections;\n          GeoPoint[] assessInsideTravelIntersections;\n          GeoPoint[] assessOutsideTestPointIntersections;\n          GeoPoint[] assessOutsideTravelIntersections;\n          while (true) {\n            assessEdge = assessEdge.next;\n            assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n            assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n            assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n            assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n            assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n            if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n              continue;\n            }\n            break;\n          }\n          \n          // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n          // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n          // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n          // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n          // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n          // We need to determine the direction of both edges at the\n          // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n          // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n          final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n          if (assessEdgeInside != edgeCrossesInside) {\n            crossingCount++;\n          }\n        } else {\n          // Not a special case, so we can safely count a crossing.\n          crossingCount++;\n        }\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n      \n      // MHL - this code below is temporary code copied from LinearCrossing above\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideIntersections = insidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideIntersections = outsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(insideIntersections.length > 0 && outsideIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (insideIntersections.length == 0 && outsideIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideIntersections;\n        GeoPoint[] assessOutsideIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideIntersections = insidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideIntersections = outsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideIntersections.length > 0 && assessOutsideIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideIntersections.length == 0 && assessOutsideIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeInside = assessInsideIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideIntersections = insidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideIntersections = outsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(insideIntersections.length > 0 && outsideIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (insideIntersections.length == 0 && outsideIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideIntersections;\n        GeoPoint[] assessOutsideIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideIntersections = insidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideIntersections = outsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideIntersections.length > 0 && assessOutsideIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideIntersections.length == 0 && assessOutsideIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a25e1e8e152433ec6f51d0ab5cf8d5ea9148776e","date":1461756607,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        // Intersection point crossing\n        \n        // MHL to deal with intersection point crossing!!\n        \n      } else {\n        // Standard plane crossing, either first leg or second leg\n      \n        final Plane plane;\n        final Plane insidePlane;\n        final Plane outsidePlane;\n        final SidedPlane bound1;\n        final SidedPlane bound2;\n        if (isSecondLeg) {\n          plane = travelPlane;\n          insidePlane = travelInsidePlane;\n          outsidePlane = travelOutsidePlane;\n          bound1 = checkPointCutoffPlane;\n          bound2 = checkPointOtherCutoffPlane;\n        } else {\n          plane = testPointPlane;\n          insidePlane = testPointInsidePlane;\n          outsidePlane = testPointOutsidePlane;\n          bound1 = testPointCutoffPlane;\n          bound2 = testPointOtherCutoffPlane;\n        }\n        \n        if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n          // We have to figure out if this crossing should be counted.\n          \n          // Does the crossing for this edge go up, or down?  Or can't we tell?\n          final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n          final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n          final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n          assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n          if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n            return;\n          }\n\n          final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n          // This depends on the previous edge that first departs from identicalness.\n          Edge assessEdge = edge;\n          GeoPoint[] assessInsideTestPointIntersections;\n          GeoPoint[] assessInsideTravelIntersections;\n          GeoPoint[] assessOutsideTestPointIntersections;\n          GeoPoint[] assessOutsideTravelIntersections;\n          while (true) {\n            assessEdge = assessEdge.previous;\n            assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n            assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n            assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n            assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n            assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n            if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n              continue;\n            }\n            break;\n          }\n\n          // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n          // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n          // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n          // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n          // a decision whether to count or not based on that.\n          \n          // Compute the crossing points of this other edge.\n          final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n          // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n          // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n          for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n            if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n              // Found it!\n              // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n              // Since we're the latter point, we exit here in that case.\n              return;\n            }\n          }\n          \n          // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n          // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n          // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n          final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n          if (assessEdgeInside != edgeCrossesInside) {\n            crossingCount++;\n          }\n          \n        } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n          // Figure out if the crossing should be counted.\n          \n          // Does the crossing for this edge go up, or down?  Or can't we tell?\n          final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n          final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n          final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n          assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n          if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n            return;\n          }\n\n          final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n          // This depends on the previous edge that first departs from identicalness.\n          Edge assessEdge = edge;\n          GeoPoint[] assessInsideTestPointIntersections;\n          GeoPoint[] assessInsideTravelIntersections;\n          GeoPoint[] assessOutsideTestPointIntersections;\n          GeoPoint[] assessOutsideTravelIntersections;\n          while (true) {\n            assessEdge = assessEdge.next;\n            assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n            assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n            assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n            assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n            assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n            if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n              continue;\n            }\n            break;\n          }\n          \n          // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n          // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n          // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n          // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n          // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n          // We need to determine the direction of both edges at the\n          // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n          // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n          final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n          if (assessEdgeInside != edgeCrossesInside) {\n            crossingCount++;\n          }\n        } else {\n          // Not a special case, so we can safely count a crossing.\n          crossingCount++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f","date":1461870588,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414d7bcd2f513d7e7162dae022e9a9f3cd930277","date":1461885603,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          crossingCount++;\n        }\n      } else {\n        System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"/dev/null","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"/dev/null","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91d2c9ef44982358af4ac4600d8ac04f914c3ce4","date":1462431879,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dc71a6ca063b508a28bf5b68fedf25a945572a0","date":1462433813,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      final Plane plane;\n      final Plane insidePlane;\n      final Plane outsidePlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        insidePlane = travelInsidePlane;\n        outsidePlane = travelOutsidePlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        insidePlane = testPointInsidePlane;\n        outsidePlane = testPointOutsidePlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n        \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n          \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0f7139cdd1f0943275ead761e4705c424e9d638","date":1522191927,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        if ((insideTestPointPlaneIntersections == null || insideTestPointPlaneIntersections.length == 0) && \n          (insideTravelPlaneIntersections == null || insideTravelPlaneIntersections.length == 0) &&\n          (outsideTestPointPlaneIntersections == null || outsideTestPointPlaneIntersections.length == 0) &&\n          (outsideTravelPlaneIntersections == null || outsideTravelPlaneIntersections.length == 0)) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // If the assess edge is numerically identical to the edge we're trying to find the intersections with, there's not really a crossing, so count it as zero.\n          \n          if ((assessInsideTestPointIntersections == null || assessInsideTestPointIntersections.length == 0) &&\n            (assessInsideTravelIntersections == null || assessInsideTravelIntersections.length == 0) &&\n            (assessOutsideTestPointIntersections == null || assessOutsideTestPointIntersections.length == 0) &&\n            (assessOutsideTravelIntersections == null || assessOutsideTravelIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n\n        if (otherCrossingPoints == null) {\n          // The assessEdge plane is the same as the travel plane.  We consider this the same as \"no crossing\".\n          return;\n        }\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = (assessInsideTestPointIntersections != null && assessInsideTestPointIntersections.length > 0) ||\n          (assessInsideTravelIntersections != null && assessInsideTravelIntersections.length > 0);\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n\n        // If the assess edge is numerically identical to the edge we're trying to find the intersections with, there's not really a crossing, so count it as zero.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          \n        if ((insideTestPointPlaneIntersections == null || insideTestPointPlaneIntersections.length == 0) && \n          (insideTravelPlaneIntersections == null || insideTravelPlaneIntersections.length == 0) && \n          (outsideTestPointPlaneIntersections == null || outsideTestPointPlaneIntersections.length == 0) && \n          (outsideTravelPlaneIntersections == null || outsideTravelPlaneIntersections.length == 0)) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = (insideTestPointPlaneIntersections !=null && insideTestPointPlaneIntersections.length > 0) || \n          (insideTravelPlaneIntersections != null && insideTravelPlaneIntersections.length > 0);\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if ((assessInsideTestPointIntersections == null || assessInsideTestPointIntersections.length == 0) && \n            (assessInsideTravelIntersections == null || assessInsideTravelIntersections.length == 0) && \n            (assessOutsideTestPointIntersections == null || assessOutsideTestPointIntersections.length == 0) && \n            (assessOutsideTravelIntersections == null || assessOutsideTravelIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = (assessInsideTestPointIntersections !=null && assessInsideTestPointIntersections.length > 0) || \n          (assessInsideTravelIntersections != null && assessInsideTravelIntersections.length > 0);\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          //assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n          \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n        //assert !(insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length > 0) : \"edge that ends in a crossing can't go both up and down: insideTestPointPlaneIntersections: \"+insideTestPointPlaneIntersections.length+\" insideTravelPlaneIntersections: \"+insideTravelPlaneIntersections.length+\" outsideTestPointPlaneIntersections: \"+outsideTestPointPlaneIntersections.length+\" outsideTravelPlaneIntersections: \"+outsideTravelPlaneIntersections.length;\n          \n        if (insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length == 0 && outsideTestPointPlaneIntersections.length + outsideTravelPlaneIntersections.length == 0) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length == 0 && assessOutsideTestPointIntersections.length + assessOutsideTravelIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = assessInsideTestPointIntersections.length + assessInsideTravelIntersections.length > 0;\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","sourceNew":null,"sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      //System.err.println(\" Crossing point \"+crossingPoint);\n      // We consider crossing points only in this method.\n      // Unlike the linear case, there are additional cases when:\n      // (1) The crossing point and the intersection point are the same, but are not the endpoint of an edge;\n      // (2) The crossing point and the intersection point are the same, and they *are* the endpoint of an edge.\n      // The other logical difference is that crossings of all kinds have to be considered so that:\n      // (a) both inside edges are considered together at all times;\n      // (b) both outside edges are considered together at all times;\n      // (c) inside edge crossings that are between the other leg's inside and outside edge are ignored.\n      \n      // Intersection point crossings are either simple, or a crossing on an endpoint.\n      // In either case, we have to be sure to count each edge only once, since it might appear in both the\n      // first leg and the second.  If the first leg can process it, it should, and the second should skip it.\n      if (crossingPoint.isNumericallyIdentical(intersectionPoint)) {\n        //System.err.println(\" Crosses intersection point.\");\n        if (isSecondLeg) {\n          // See whether this edge would have been processed in the first leg; if so, we skip it.\n          final GeoPoint[] firstLegCrossings = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n          for (final GeoPoint firstLegCrossing : firstLegCrossings) {\n            if (firstLegCrossing.isNumericallyIdentical(intersectionPoint)) {\n              // We already processed it, so we're done here.\n              //System.err.println(\"  Already processed on previous leg: exit\");\n              return;\n            }\n          }\n        }\n      }\n        \n      // Plane crossing, either first leg or second leg\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        //System.err.println(\" Crossing point = edge.startPoint\");\n        // We have to figure out if this crossing should be counted.\n        computeInsideOutside();\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findCrossings(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n          \n        if ((insideTestPointPlaneIntersections == null || insideTestPointPlaneIntersections.length == 0) && \n          (insideTravelPlaneIntersections == null || insideTravelPlaneIntersections.length == 0) &&\n          (outsideTestPointPlaneIntersections == null || outsideTestPointPlaneIntersections.length == 0) &&\n          (outsideTravelPlaneIntersections == null || outsideTravelPlaneIntersections.length == 0)) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = insideTestPointPlaneIntersections.length + insideTravelPlaneIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          // If the assess edge is numerically identical to the edge we're trying to find the intersections with, there's not really a crossing, so count it as zero.\n          \n          if ((assessInsideTestPointIntersections == null || assessInsideTestPointIntersections.length == 0) &&\n            (assessInsideTravelIntersections == null || assessInsideTravelIntersections.length == 0) &&\n            (assessOutsideTestPointIntersections == null || assessOutsideTestPointIntersections.length == 0) &&\n            (assessOutsideTravelIntersections == null || assessOutsideTravelIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n\n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n          \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints;\n        if (isSecondLeg) {\n          otherCrossingPoints = travelPlane.findCrossings(planetModel, assessEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        } else {\n          otherCrossingPoints = testPointPlane.findCrossings(planetModel, assessEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, assessEdge.startPlane, assessEdge.endPlane);\n        }        \n\n        if (otherCrossingPoints == null) {\n          // The assessEdge plane is the same as the travel plane.  We consider this the same as \"no crossing\".\n          return;\n        }\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            //System.err.println(\" Earlier point fired, so this one shouldn't\");\n            return;\n          }\n        }\n          \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n          \n        final boolean assessEdgeInside = (assessInsideTestPointIntersections != null && assessInsideTestPointIntersections.length > 0) ||\n          (assessInsideTravelIntersections != null && assessInsideTravelIntersections.length > 0);\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n          \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        //System.err.println(\" Crossing point = edge.endPoint\");\n        // Figure out if the crossing should be counted.\n        computeInsideOutside();\n\n        // If the assess edge is numerically identical to the edge we're trying to find the intersections with, there's not really a crossing, so count it as zero.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] insideTestPointPlaneIntersections = testPointInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTestPointCutoffPlane);\n        final GeoPoint[] insideTravelPlaneIntersections = travelInsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane, insideTravelCutoffPlane);\n        final GeoPoint[] outsideTestPointPlaneIntersections = testPointOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] outsideTravelPlaneIntersections = travelOutsidePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        // An edge can cross both outside and inside, because of the corner.  But it can be considered to cross the inside ONLY if it crosses either of the inside edges.\n          \n        if ((insideTestPointPlaneIntersections == null || insideTestPointPlaneIntersections.length == 0) && \n          (insideTravelPlaneIntersections == null || insideTravelPlaneIntersections.length == 0) && \n          (outsideTestPointPlaneIntersections == null || outsideTestPointPlaneIntersections.length == 0) && \n          (outsideTravelPlaneIntersections == null || outsideTravelPlaneIntersections.length == 0)) {\n          //System.err.println(\" No inside or outside crossings found\");\n          return;\n        }\n\n        final boolean edgeCrossesInside = (insideTestPointPlaneIntersections !=null && insideTestPointPlaneIntersections.length > 0) || \n          (insideTravelPlaneIntersections != null && insideTravelPlaneIntersections.length > 0);\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessInsideTestPointIntersections;\n        GeoPoint[] assessInsideTravelIntersections;\n        GeoPoint[] assessOutsideTestPointIntersections;\n        GeoPoint[] assessOutsideTravelIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessInsideTestPointIntersections = testPointInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTestPointCutoffPlane);\n          assessInsideTravelIntersections = travelInsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane, insideTravelCutoffPlane);\n          assessOutsideTestPointIntersections = testPointOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessOutsideTravelIntersections = travelOutsidePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          if ((assessInsideTestPointIntersections == null || assessInsideTestPointIntersections.length == 0) && \n            (assessInsideTravelIntersections == null || assessInsideTravelIntersections.length == 0) && \n            (assessOutsideTestPointIntersections == null || assessOutsideTestPointIntersections.length == 0) && \n            (assessOutsideTravelIntersections == null || assessOutsideTravelIntersections.length == 0)) {\n            continue;\n          }\n          break;\n        }\n          \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n          \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n          \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeInside = (assessInsideTestPointIntersections !=null && assessInsideTestPointIntersections.length > 0) || \n          (assessInsideTravelIntersections != null && assessInsideTravelIntersections.length > 0);\n        if (assessEdgeInside != edgeCrossesInside) {\n          //System.err.println(\" Incrementing crossing count\");\n          crossingCount++;\n        } else {\n          //System.err.println(\" Entered and exited on same side\");\n        }\n      } else {\n        //System.err.println(\" Not a special case: incrementing crossing count\");\n        // Not a special case, so we can safely count a crossing.\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"8b879b14da40ab73551b75835099a61e622a83d3":["c0f7139cdd1f0943275ead761e4705c424e9d638"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["55b50463286869f584cf849d1587a0fcd54d1dfa","3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"a25e1e8e152433ec6f51d0ab5cf8d5ea9148776e":["a0108af7050cbe916cac082bcce73081e33e46ce"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0108af7050cbe916cac082bcce73081e33e46ce":["3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb"],"c0f7139cdd1f0943275ead761e4705c424e9d638":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["a25e1e8e152433ec6f51d0ab5cf8d5ea9148776e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b879b14da40ab73551b75835099a61e622a83d3"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"]},"commit2Childs":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","c0f7139cdd1f0943275ead761e4705c424e9d638","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"8b879b14da40ab73551b75835099a61e622a83d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":[],"a25e1e8e152433ec6f51d0ab5cf8d5ea9148776e":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"a0108af7050cbe916cac082bcce73081e33e46ce":["a25e1e8e152433ec6f51d0ab5cf8d5ea9148776e"],"c0f7139cdd1f0943275ead761e4705c424e9d638":["8b879b14da40ab73551b75835099a61e622a83d3"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ff44d836e8863507fa8711d2b1b2dd723516ca0","55b50463286869f584cf849d1587a0fcd54d1dfa","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb":["a0108af7050cbe916cac082bcce73081e33e46ce"],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["55b50463286869f584cf849d1587a0fcd54d1dfa","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}