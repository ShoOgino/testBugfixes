{"path":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","commits":[{"id":"81819c5a4a660afd353042c67106e682bb877cf1","date":1583169587,"type":0,"author":"msfroh","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitSeconds()} have elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, but will not be reflected\n   * in the commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba192a321314de8edbe20b279eee9c471b16b48b","date":1583706474,"type":4,"author":"Michael Sokolov","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","sourceNew":null,"sourceOld":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitSeconds()} have elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, but will not be reflected\n   * in the commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":0,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitSeconds()} have elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, but will not be reflected\n   * in the commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":4,"author":"Michael Sokolov","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","sourceNew":null,"sourceOld":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, do not synchronously merge on commit.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitSeconds()} have elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, but will not be reflected\n   * in the commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, this will do no merging on commit.\n   * If you implement this method in your {@code MergePolicy} you must also set a non-zero timeout using\n   * {@link IndexWriterConfig#setMaxCommitMergeWaitMillis}.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitMillis()} has elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, and eventually finish and\n   * apply to future commits, but will not be reflected in the current commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergePolicy#findFullFlushMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","sourceNew":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, this will do no merging on commit.\n   * If you implement this method in your {@code MergePolicy} you must also set a non-zero timeout using\n   * {@link IndexWriterConfig#setMaxFullFlushMergeWaitMillis}.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()}, {@link IndexWriter#prepareCommit()}\n   * or {@link IndexWriter#getReader(boolean, boolean)} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxFullFlushMergeWaitMillis()} has elapsed. This may be\n   * used to merge small segments that have just been flushed, reducing the number of segments in\n   * the point in time snapshot. If a merge does not complete in the allotted time, it will continue to execute, and eventually finish and\n   * apply to future point in time snapshot, but will not be reflected in the current one.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or GET_READER).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","sourceOld":"  /**\n   * Identifies merges that we want to execute (synchronously) on commit. By default, this will do no merging on commit.\n   * If you implement this method in your {@code MergePolicy} you must also set a non-zero timeout using\n   * {@link IndexWriterConfig#setMaxCommitMergeWaitMillis}.\n   *\n   * Any merges returned here will make {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} block until\n   * the merges complete or until {@link IndexWriterConfig#getMaxCommitMergeWaitMillis()} has elapsed. This may be\n   * used to merge small segments that have just been flushed as part of the commit, reducing the number of segments in\n   * the commit. If a merge does not complete in the allotted time, it will continue to execute, and eventually finish and\n   * apply to future commits, but will not be reflected in the current commit.\n   *\n   * If a {@link OneMerge} in the returned {@link MergeSpecification} includes a segment already included in a registered\n   * merge, then {@link IndexWriter#commit()} or {@link IndexWriter#prepareCommit()} will throw a {@link IllegalStateException}.\n   * Use {@link MergeContext#getMergingSegments()} to determine which segments are currently registered to merge.\n   *\n   * @param mergeTrigger the event that triggered the merge (COMMIT or FULL_FLUSH).\n   * @param segmentInfos the total set of segments in the index (while preparing the commit)\n   * @param mergeContext the MergeContext to find the merges on, which should be used to determine which segments are\n *                     already in a registered merge (see {@link MergeContext#getMergingSegments()}).\n   */\n  public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) throws IOException {\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba192a321314de8edbe20b279eee9c471b16b48b":["81819c5a4a660afd353042c67106e682bb877cf1"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81819c5a4a660afd353042c67106e682bb877cf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["ba192a321314de8edbe20b279eee9c471b16b48b"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"ba192a321314de8edbe20b279eee9c471b16b48b":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["81819c5a4a660afd353042c67106e682bb877cf1"],"81819c5a4a660afd353042c67106e682bb877cf1":["ba192a321314de8edbe20b279eee9c471b16b48b"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}