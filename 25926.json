{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"/dev/null","sourceNew":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"/dev/null","sourceNew":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"/dev/null","sourceNew":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9981f0cb0e2c6b6512a483e09fa27c840ad08e36","date":1327591744,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5dd811388ff9e790b1bf628567bdf6da4ca24cb8","date":1327610284,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    \n    boolean doRecovery = true;\n\n\n    if (isLeader) {\n      doRecovery = false;\n      \n      // recover from local transaction log and wait for it to complete before\n      // going active\n      // TODO: should this be moved to another thread? To recoveryStrat?\n      // TODO: should this actually be done earlier, before (or as part of)\n      // leader election perhaps?\n      // TODO: ensure that a replica that is trying to recover waits until I'm\n      // active (or don't make me the\n      // leader until my local replay is done. But this replay is only needed\n      // on the leader - replicas\n      // will do recovery anyway\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (!core.isReloaded() && ulog != null) {\n        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()\n            .getUpdateLog().recoverFromLog();\n        if (recoveryFuture != null) {\n          recoveryFuture.get(); // NOTE: this could potentially block for\n                                // minutes or more!\n          // TODO: public as recovering in the mean time?\n        }\n      }\n      return false;\n    } else {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n    }\n    \n    if (doRecovery && !SKIP_AUTO_RECOVERY) {\n      log.info(\"Core needs to recover:\" + core.getName());\n      core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n      return true;\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c516f1fb8a8bbd4b308968d3f638304888ce86d1","date":1329014706,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28eef717ead790cfb22deee28f45ccf45af2773e","date":1329921173,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"221ff19d62d5ff429ffecf8e7f3e01ff93754854","date":1329974551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery && !SKIP_AUTO_RECOVERY) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(core);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","5dd811388ff9e790b1bf628567bdf6da4ca24cb8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   * @throws InterruptedException\n   * @throws KeeperException\n   * @throws IOException\n   * @throws ExecutionException\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) throws InterruptedException,\n      KeeperException, IOException, ExecutionException {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param coreName\n   * @param desc\n   * @param recoverReloadedCores\n   * @param isLeader\n   * @param cloudDesc\n   * @param collection\n   * @param shardZkNodeName\n   * @param shardId\n   * @param leaderProps\n   * @param core\n   * @param cc\n   * @return whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, coreName);\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n      \n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreName);\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \"+core.getName()+\" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;        \n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c824e7f6927860d366e4888be45e4db8c9e03b","date":1405193679,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n      \n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \"+core.getName()+\" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;        \n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n      \n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreName);\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \"+core.getName()+\" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;        \n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbcfc050b9f253136eaa5950b57248b2109eac11","date":1427308993,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n      \n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \"+core.getName()+\" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;        \n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n      boolean recoverReloadedCores, final boolean isLeader,\n      final CloudDescriptor cloudDesc, final String collection,\n      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n      SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n      \n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n      \n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n      \n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \"+core.getName()+\" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;        \n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      String lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState)) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0e67453ef2c855797898e384afc5dd4a4d6bac5","date":1428334932,"type":5,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#checkRecovery(String,CoreDescriptor,boolean,boolean,CloudDescriptor,String,String,String,ZkNodeProps,SolrCore,CoreContainer).mjava","sourceNew":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc, boolean afterExpiration) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (!afterExpiration && core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns whether or not a recovery was started\n   */\n  private boolean checkRecovery(String coreName, final CoreDescriptor desc,\n                                boolean recoverReloadedCores, final boolean isLeader,\n                                final CloudDescriptor cloudDesc, final String collection,\n                                final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,\n                                SolrCore core, CoreContainer cc) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return false;\n    }\n    boolean doRecovery = true;\n    if (!isLeader) {\n\n      if (core.isReloaded() && !recoverReloadedCores) {\n        doRecovery = false;\n      }\n\n      if (doRecovery) {\n        log.info(\"Core needs to recover:\" + core.getName());\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n\n      // see if the leader told us to recover\n      final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN) {\n        log.info(\"Leader marked core \" + core.getName() + \" down; starting recovery process\");\n        core.getUpdateHandler().getSolrCoreState().doRecovery(cc, core.getCoreDescriptor());\n        return true;\n      }\n    } else {\n      log.info(\"I am the leader, no recovery necessary\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","5dd811388ff9e790b1bf628567bdf6da4ca24cb8"],"d0e67453ef2c855797898e384afc5dd4a4d6bac5":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["28eef717ead790cfb22deee28f45ccf45af2773e"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["c516f1fb8a8bbd4b308968d3f638304888ce86d1","221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","5dd811388ff9e790b1bf628567bdf6da4ca24cb8"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"28eef717ead790cfb22deee28f45ccf45af2773e":["c516f1fb8a8bbd4b308968d3f638304888ce86d1"],"c516f1fb8a8bbd4b308968d3f638304888ce86d1":["5dd811388ff9e790b1bf628567bdf6da4ca24cb8"],"9981f0cb0e2c6b6512a483e09fa27c840ad08e36":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["fbcfc050b9f253136eaa5950b57248b2109eac11"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["07c824e7f6927860d366e4888be45e4db8c9e03b","fbcfc050b9f253136eaa5950b57248b2109eac11"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"5dd811388ff9e790b1bf628567bdf6da4ca24cb8":["9981f0cb0e2c6b6512a483e09fa27c840ad08e36"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0e67453ef2c855797898e384afc5dd4a4d6bac5"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["07c824e7f6927860d366e4888be45e4db8c9e03b"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"d0e67453ef2c855797898e384afc5dd4a4d6bac5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"28eef717ead790cfb22deee28f45ccf45af2773e":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"c516f1fb8a8bbd4b308968d3f638304888ce86d1":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","28eef717ead790cfb22deee28f45ccf45af2773e"],"9981f0cb0e2c6b6512a483e09fa27c840ad08e36":["5dd811388ff9e790b1bf628567bdf6da4ca24cb8"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0e67453ef2c855797898e384afc5dd4a4d6bac5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fbcfc050b9f253136eaa5950b57248b2109eac11"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"5dd811388ff9e790b1bf628567bdf6da4ca24cb8":["78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4","c516f1fb8a8bbd4b308968d3f638304888ce86d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","9981f0cb0e2c6b6512a483e09fa27c840ad08e36","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["78a55f24d9b493c2a1cecf79f1d78279062b545b","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fd92b8bcc88e969302510acf77bd6970da3994c4","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}