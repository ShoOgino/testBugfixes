{"path":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"/dev/null","sourceNew":"  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n       throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer);\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15c469602973ef1a33c9a07367a380d278ffab20","date":1074206555,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n       throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer-freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","sourceOld":"  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n       throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer);\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770281b8a8459cafcdd2354b6a06078fea2d83c9","date":1077308096,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","sourceOld":"  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n       throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int)(skipPointer-freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","sourceOld":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","bugFix":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709","date":1180597733,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","sourceOld":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = writeSkip();\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final int mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n\n    return df;\n  }\n\n","sourceOld":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final void mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n  }\n\n","bugFix":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"902ba79f4590a41c663c447756d2e5041cbbdda9","date":1217956662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final int mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    final long freqPointer = freqOutput.getFilePointer();\n    final long proxPointer;\n    if (proxOutput != null)\n      proxPointer = proxOutput.getFilePointer();\n    else\n      proxPointer = 0;\n\n    int df;\n    if (fieldInfos.fieldInfo(smis[0].term.field).omitTf) { // append posting data\n      df = appendPostingsNoTf(smis, n);     \n    } else{\n      df = appendPostings(smis, n);      \n    }\n    \n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n\n    return df;\n  }\n\n","sourceOld":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final int mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    long freqPointer = freqOutput.getFilePointer();\n    long proxPointer = proxOutput.getFilePointer();\n\n    int df = appendPostings(smis, n);\t\t  // append posting data\n\n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n\n    return df;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d17492f26096e19670d947d1be5e9adc52b1d3d","date":1224931200,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeTermInfo(SegmentMergeInfo[],int).mjava","sourceNew":null,"sourceOld":"  /** Merge one term found in one or more segments. The array <code>smis</code>\n   *  contains segments that are positioned at the same term. <code>N</code>\n   *  is the number of cells in the array actually occupied.\n   *\n   * @param smis array of segments\n   * @param n number of cells in the array actually occupied\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  private final int mergeTermInfo(SegmentMergeInfo[] smis, int n)\n          throws CorruptIndexException, IOException {\n    final long freqPointer = freqOutput.getFilePointer();\n    final long proxPointer;\n    if (proxOutput != null)\n      proxPointer = proxOutput.getFilePointer();\n    else\n      proxPointer = 0;\n\n    int df;\n    if (fieldInfos.fieldInfo(smis[0].term.field).omitTf) { // append posting data\n      df = appendPostingsNoTf(smis, n);     \n    } else{\n      df = appendPostings(smis, n);      \n    }\n    \n    long skipPointer = skipListWriter.writeSkip(freqOutput);\n\n    if (df > 0) {\n      // add an entry to the dictionary with pointers to prox and freq files\n      termInfo.set(df, freqPointer, proxPointer, (int) (skipPointer - freqPointer));\n      termInfosWriter.add(smis[0].term, termInfo);\n    }\n\n    return df;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"770281b8a8459cafcdd2354b6a06078fea2d83c9":["15c469602973ef1a33c9a07367a380d278ffab20"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["08d1ee9808e270c86ce5c9be08b8bd7a19d0a709"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1b54a9bc667895a2095a886184bf69a3179e63df":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"902ba79f4590a41c663c447756d2e5041cbbdda9":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"4d17492f26096e19670d947d1be5e9adc52b1d3d":["902ba79f4590a41c663c447756d2e5041cbbdda9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d17492f26096e19670d947d1be5e9adc52b1d3d"],"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709":["1b54a9bc667895a2095a886184bf69a3179e63df"],"15c469602973ef1a33c9a07367a380d278ffab20":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"]},"commit2Childs":{"770281b8a8459cafcdd2354b6a06078fea2d83c9":["1b54a9bc667895a2095a886184bf69a3179e63df"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["902ba79f4590a41c663c447756d2e5041cbbdda9"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["15c469602973ef1a33c9a07367a380d278ffab20"],"1b54a9bc667895a2095a886184bf69a3179e63df":["08d1ee9808e270c86ce5c9be08b8bd7a19d0a709"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"902ba79f4590a41c663c447756d2e5041cbbdda9":["4d17492f26096e19670d947d1be5e9adc52b1d3d"],"4d17492f26096e19670d947d1be5e9adc52b1d3d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15c469602973ef1a33c9a07367a380d278ffab20":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}