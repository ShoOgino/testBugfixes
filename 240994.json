{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","commits":[{"id":"3a4e61034e4aff7de8a98f9e093d324f23f610e1","date":1351015892,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n    // nocommit we don't \"penalize\" for edits\n    // ... shouldn't we?  ie, ed=0 completions should have\n    // higher rank than ed=1, at the same \"weight\"?  maybe\n    // we can punt on this for starters ... or maybe we\n    // can re-run each prefix path through lev0, lev1,\n    // lev2 to figure out the number of edits?\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ba222c174ec1943d8d14d012d1d6e24a1cc4972","date":1351522220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n    // nocommit we don't \"penalize\" for edits\n    // ... shouldn't we?  ie, ed=0 completions should have\n    // higher rank than ed=1, at the same \"weight\"?  maybe\n    // we can punt on this for starters ... or maybe we\n    // can re-run each prefix path through lev0, lev1,\n    // lev2 to figure out the number of edits?\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","date":1374158194,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":["3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = toLevenshteinAutomata(lookupAutomaton);\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],LightAutomaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       LightAutomaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    LightAutomaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],LightAutomaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       LightAutomaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    LightAutomaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["7d89d7e4e5101347833eea558851bf4209218619"],"5eb2511ababf862ea11e10761c70ee560cd84510":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","7d89d7e4e5101347833eea558851bf4209218619"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"3a4e61034e4aff7de8a98f9e093d324f23f610e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["75ac8571c2d82c574e446c3729251b994c69a55c"],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"7d89d7e4e5101347833eea558851bf4209218619":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7d89d7e4e5101347833eea558851bf4209218619"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"3a4e61034e4aff7de8a98f9e093d324f23f610e1":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["5eb2511ababf862ea11e10761c70ee560cd84510","7d89d7e4e5101347833eea558851bf4209218619"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"7d89d7e4e5101347833eea558851bf4209218619":["75ac8571c2d82c574e446c3729251b994c69a55c","5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","4ca1c732df8923f5624f6c06b1dcca9e69d98c96","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}