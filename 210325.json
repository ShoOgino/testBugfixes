{"path":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","commits":[{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /** The single-core mode compatibility constructor; the core is named 'null'. */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    this(null, dataDir, config, schema);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fe3c163c8df3fb3e4248c30f8ae8034cc786589","date":1189317596,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  /** The single-core mode compatibility constructor; the core is named 'null'. */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    this(null, dataDir, config, schema);\n  }\n\n","bugFix":null,"bugIntro":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66ab3886c1d845c59c9e5b23b2fb247b927db498","date":1193060587,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014","date":1195912306,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.name = name;\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"[\"+name+\"] Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"6d6338c87060be5f66757a94945975f3bbd377a9":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["6d6338c87060be5f66757a94945975f3bbd377a9"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6d6338c87060be5f66757a94945975f3bbd377a9":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"048361614025800e582bfc7a7b0329dc6fd6a95e":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["6d6338c87060be5f66757a94945975f3bbd377a9"],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["048361614025800e582bfc7a7b0329dc6fd6a95e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}