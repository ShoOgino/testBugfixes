{"path":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","commits":[{"id":"b3af9908203648fa4313aca6c4913cb4864014bb","date":1099870044,"type":0,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) / length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n    private synchronized final float similarity(final String target) {\n        final int m = target.length();\n        final int n = text.length();\n        if (n == 0)  {\n          //we don't have antyhing to compare.  That means if we just add\n          //the letters for m we get the new word\n          return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n        }\n        if (m == 0) {\n          return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n        }\n\n        final int maxDistance = getMaxDistance(m);\n\n        if (maxDistance < Math.abs(m-n)) {\n          //just adding the characters of m to n or vice-versa results in\n          //too many edits\n          //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n          //given this optimal circumstance, the edit distance cannot be less than 5.\n          //which is 8-3 or more precisesly Math.abs(3-8).\n          //if our maximum edit distance is 4, than we can discard this word\n          //without looking at it.\n          return 0.0f;\n        }\n\n        //let's make sure we have enough room in our array to do the distance calculations.\n        if (d[0].length <= m) {\n          growDistanceArray(m);\n        }\n\n        // init matrix d\n        for (int i = 0; i <= n; i++) d[i][0] = i;\n        for (int j = 0; j <= m; j++) d[0][j] = j;\n        \n        // start computing edit distance\n        for (int i = 1; i <= n; i++) {\n            int bestPossibleEditDistance = m;\n            final char s_i = text.charAt(i - 1);\n            for (int j = 1; j <= m; j++) {\n                if (s_i != target.charAt(j-1)) {\n                    d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n                }\n                else {\n                  d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n                }\n                bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n            }\n\n          //After calculating row i, the best possible edit distance\n          //can be found by found by finding the smallest value in a given column.\n          //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n          if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n            //the closest the target can be to the text is just too far away.\n            //this target is leaving the party early.\n            return 0.0f;\n          }\n        }\n\n        // this will return less than 0.0 when the edit distance is\n        // greater than the number of characters in the shorter word.\n        // but this was the formula that was previously used in FuzzyTermEnum,\n        // so it has not been changed (even though minimumSimilarity must be\n        // greater than 0.0)\n        return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49a070f32444fce25dc4bd4cd63d856282e1498e","date":1099870910,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) / length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have antyhing to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, than we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) / length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n    private synchronized final float similarity(final String target) {\n        final int m = target.length();\n        final int n = text.length();\n        if (n == 0)  {\n          //we don't have antyhing to compare.  That means if we just add\n          //the letters for m we get the new word\n          return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n        }\n        if (m == 0) {\n          return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n        }\n\n        final int maxDistance = getMaxDistance(m);\n\n        if (maxDistance < Math.abs(m-n)) {\n          //just adding the characters of m to n or vice-versa results in\n          //too many edits\n          //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n          //given this optimal circumstance, the edit distance cannot be less than 5.\n          //which is 8-3 or more precisesly Math.abs(3-8).\n          //if our maximum edit distance is 4, than we can discard this word\n          //without looking at it.\n          return 0.0f;\n        }\n\n        //let's make sure we have enough room in our array to do the distance calculations.\n        if (d[0].length <= m) {\n          growDistanceArray(m);\n        }\n\n        // init matrix d\n        for (int i = 0; i <= n; i++) d[i][0] = i;\n        for (int j = 0; j <= m; j++) d[0][j] = j;\n        \n        // start computing edit distance\n        for (int i = 1; i <= n; i++) {\n            int bestPossibleEditDistance = m;\n            final char s_i = text.charAt(i - 1);\n            for (int j = 1; j <= m; j++) {\n                if (s_i != target.charAt(j-1)) {\n                    d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n                }\n                else {\n                  d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n                }\n                bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n            }\n\n          //After calculating row i, the best possible edit distance\n          //can be found by found by finding the smallest value in a given column.\n          //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n          if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n            //the closest the target can be to the text is just too far away.\n            //this target is leaving the party early.\n            return 0.0f;\n          }\n        }\n\n        // this will return less than 0.0 when the edit distance is\n        // greater than the number of characters in the shorter word.\n        // but this was the formula that was previously used in FuzzyTermEnum,\n        // so it has not been changed (even though minimumSimilarity must be\n        // greater than 0.0)\n        return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51cc0e97e5eb63c7141c279d0c0e17c048d966c7","date":1101236715,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have antyhing to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, than we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) / length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have antyhing to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, than we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f3dfb2bbbe596f1c22aef5ecea250a36a6d8dfe","date":1101239672,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have antyhing to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, than we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea62f19ad1b43de1b0fc5b86e9ec196e5e504092","date":1256073772,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text.charAt(i - 1);\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target.charAt(j-1)) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f","date":1260539714,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &lt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":["b3af9908203648fa4313aca6c4913cb4864014bb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5a8ffa80c99d24aab005ca79a96c3aeea643372","date":1265806740,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","pathOld":"src/java/org/apache/lucene/search/FuzzyTermEnum#similarity(String).mjava","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    // init matrix d\n    for (int i = 0; i<=n; ++i) {\n      p[i] = i;\n    }\n\n    // start computing edit distance\n    for (int j = 1; j<=m; ++j) { // iterates through target\n      int bestPossibleEditDistance = m;\n      final char t_j = target.charAt(j-1); // jth character of t\n      d[0] = j;\n\n      for (int i=1; i<=n; ++i) { // iterates through text\n        // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n        if (t_j != text.charAt(i-1)) {\n          d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n\t\t} else {\n          d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n\t\t}\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n\n      // copy current distance counts to 'previous row' distance counts: swap p and d\n      int _d[] = p;\n      p = d;\n      d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)p[n] / (float) (prefix.length() + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d5a8ffa80c99d24aab005ca79a96c3aeea643372":["cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f"],"ea62f19ad1b43de1b0fc5b86e9ec196e5e504092":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"49a070f32444fce25dc4bd4cd63d856282e1498e":["b3af9908203648fa4313aca6c4913cb4864014bb"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["2f3dfb2bbbe596f1c22aef5ecea250a36a6d8dfe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f3dfb2bbbe596f1c22aef5ecea250a36a6d8dfe":["51cc0e97e5eb63c7141c279d0c0e17c048d966c7"],"51cc0e97e5eb63c7141c279d0c0e17c048d966c7":["49a070f32444fce25dc4bd4cd63d856282e1498e"],"cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f":["ea62f19ad1b43de1b0fc5b86e9ec196e5e504092"],"b3af9908203648fa4313aca6c4913cb4864014bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d5a8ffa80c99d24aab005ca79a96c3aeea643372"]},"commit2Childs":{"d5a8ffa80c99d24aab005ca79a96c3aeea643372":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ea62f19ad1b43de1b0fc5b86e9ec196e5e504092":["cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f"],"49a070f32444fce25dc4bd4cd63d856282e1498e":["51cc0e97e5eb63c7141c279d0c0e17c048d966c7"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["ea62f19ad1b43de1b0fc5b86e9ec196e5e504092"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b3af9908203648fa4313aca6c4913cb4864014bb"],"2f3dfb2bbbe596f1c22aef5ecea250a36a6d8dfe":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"51cc0e97e5eb63c7141c279d0c0e17c048d966c7":["2f3dfb2bbbe596f1c22aef5ecea250a36a6d8dfe"],"cf38b33c7ff45f89ab6ce97e6c0ba8752948bf5f":["d5a8ffa80c99d24aab005ca79a96c3aeea643372"],"b3af9908203648fa4313aca6c4913cb4864014bb":["49a070f32444fce25dc4bd4cd63d856282e1498e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}