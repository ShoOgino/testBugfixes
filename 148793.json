{"path":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","commits":[{"id":"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1","date":1185690521,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see SolrParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(SolrParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,SolrParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,SolrParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,SolrParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,SolrParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,SolrParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","date":1185993405,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see SolrParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see SolrParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(SolrParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,SolrParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,SolrParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,SolrParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,SolrParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,SolrParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923","aa62c79a7afa4d7f22e1f71b883659f3213d7db1","aa62c79a7afa4d7f22e1f71b883659f3213d7db1","aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b6124b1a8da43c086b34ee5005d89e20f4f0764","date":1189219182,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see SolrParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb179b2fab2183d2f6041e450ff8022c592ecf0","date":1229553695,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(f, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c","date":1249333745,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          // final String label = ft.indexedToReadable(lowI);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          // resInner.add(label, rangeCount(sf,lowI,highI,true,true));\n          resInner.add(label, rangeCount(sf,low,high,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final FieldType trash = schema.getFieldType(f);\n      if (! (trash instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) trash;\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          final String label = ft.indexedToReadable(lowI);\n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          resInner.add(label, rangeCount(f,lowI,highI,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(f,null,startI,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(f,endI,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(f,startI,endI,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d060548953a5db87db288976d5e5504932d33a7","date":1249476278,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          resInner.add(label, rangeCount(sf,low,high,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          final String lowI = ft.toInternal(low);\n          // final String label = ft.indexedToReadable(lowI);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final String highI = ft.toInternal(high);\n          // resInner.add(label, rangeCount(sf,lowI,highI,true,true));\n          resInner.add(label, rangeCount(sf,low,high,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {\n          final String startI = ft.toInternal(start);\n          final String endI = ft.toInternal(end);\n          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74224d32ccff5e171a601105a0cf9ad0569f0e29","date":1260219849,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n      \n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          resInner.add(label, rangeCount(sf,low,high,true,true));\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1"],"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"9d060548953a5db87db288976d5e5504932d33a7":["dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["4b6124b1a8da43c086b34ee5005d89e20f4f0764"],"ad94625fb8d088209f46650c8097196fec67f00c":["74224d32ccff5e171a601105a0cf9ad0569f0e29"],"74224d32ccff5e171a601105a0cf9ad0569f0e29":["9d060548953a5db87db288976d5e5504932d33a7"],"4b6124b1a8da43c086b34ee5005d89e20f4f0764":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["4b6124b1a8da43c086b34ee5005d89e20f4f0764"],"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"9d060548953a5db87db288976d5e5504932d33a7":["74224d32ccff5e171a601105a0cf9ad0569f0e29"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c":["9d060548953a5db87db288976d5e5504932d33a7"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"74224d32ccff5e171a601105a0cf9ad0569f0e29":["ad94625fb8d088209f46650c8097196fec67f00c"],"4b6124b1a8da43c086b34ee5005d89e20f4f0764":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}