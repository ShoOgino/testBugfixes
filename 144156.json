{"path":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","commits":[{"id":"f986320666d675a260eb4529a0c3c40595731441","date":1401729997,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","pathOld":"/dev/null","sourceNew":"  public void testImplementations() throws Exception {\n    for (int i = 2; i < 12; i++) {\n      final int chunkSize = 1<<i;\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testImplementations\"), null, chunkSize);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      int size = random().nextInt(chunkSize * 2) + 3; // add some buffer of 3 for slice tests\n      byte bytes[] = new byte[size];\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[size]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      // reinit:\n      ii.seek(0L);\n      \n      // check impl (we must check size < chunksize: currently, if size==chunkSize, we get 2 buffers, the second one empty:\n      assertTrue((size < chunkSize) ? (ii instanceof ByteBufferIndexInput.SingleBufferImpl) : (ii instanceof ByteBufferIndexInput.DefaultImpl));\n      \n      // clone tests:\n      assertSame(ii.getClass(), ii.clone().getClass());\n      \n      // slice test (offset 0)\n      int sliceSize = random().nextInt(size);\n      IndexInput slice = ii.slice(\"slice\", 0, sliceSize);\n      assertTrue((sliceSize < chunkSize) ? (slice instanceof ByteBufferIndexInput.SingleBufferImpl) : (slice instanceof ByteBufferIndexInput.DefaultImpl));\n\n      // slice test (offset > 0 )\n      int offset = random().nextInt(size - 1) + 1;\n      sliceSize = random().nextInt(size - offset + 1);\n      slice = ii.slice(\"slice\", offset, sliceSize);\n      //System.out.println(offset + \"/\" + sliceSize + \" chunkSize=\" + chunkSize + \" \" + slice.getClass());\n      if (offset % chunkSize + sliceSize < chunkSize) {\n        assertTrue(slice instanceof ByteBufferIndexInput.SingleBufferImpl);\n      } else if (offset % chunkSize == 0) {\n        assertTrue(slice instanceof ByteBufferIndexInput.DefaultImpl);\n      } else {\n        assertTrue(slice instanceof ByteBufferIndexInput.WithOffsetImpl);\n      }\n\n      ii.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","sourceNew":"  public void testImplementations() throws Exception {\n    for (int i = 2; i < 12; i++) {\n      final int chunkSize = 1<<i;\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testImplementations\"), chunkSize);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      int size = random().nextInt(chunkSize * 2) + 3; // add some buffer of 3 for slice tests\n      byte bytes[] = new byte[size];\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[size]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      // reinit:\n      ii.seek(0L);\n      \n      // check impl (we must check size < chunksize: currently, if size==chunkSize, we get 2 buffers, the second one empty:\n      assertTrue((size < chunkSize) ? (ii instanceof ByteBufferIndexInput.SingleBufferImpl) : (ii instanceof ByteBufferIndexInput.DefaultImpl));\n      \n      // clone tests:\n      assertSame(ii.getClass(), ii.clone().getClass());\n      \n      // slice test (offset 0)\n      int sliceSize = random().nextInt(size);\n      IndexInput slice = ii.slice(\"slice\", 0, sliceSize);\n      assertTrue((sliceSize < chunkSize) ? (slice instanceof ByteBufferIndexInput.SingleBufferImpl) : (slice instanceof ByteBufferIndexInput.DefaultImpl));\n\n      // slice test (offset > 0 )\n      int offset = random().nextInt(size - 1) + 1;\n      sliceSize = random().nextInt(size - offset + 1);\n      slice = ii.slice(\"slice\", offset, sliceSize);\n      //System.out.println(offset + \"/\" + sliceSize + \" chunkSize=\" + chunkSize + \" \" + slice.getClass());\n      if (offset % chunkSize + sliceSize < chunkSize) {\n        assertTrue(slice instanceof ByteBufferIndexInput.SingleBufferImpl);\n      } else if (offset % chunkSize == 0) {\n        assertTrue(slice instanceof ByteBufferIndexInput.DefaultImpl);\n      } else {\n        assertTrue(slice instanceof ByteBufferIndexInput.WithOffsetImpl);\n      }\n\n      ii.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":"  public void testImplementations() throws Exception {\n    for (int i = 2; i < 12; i++) {\n      final int chunkSize = 1<<i;\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testImplementations\"), null, chunkSize);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      int size = random().nextInt(chunkSize * 2) + 3; // add some buffer of 3 for slice tests\n      byte bytes[] = new byte[size];\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[size]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      // reinit:\n      ii.seek(0L);\n      \n      // check impl (we must check size < chunksize: currently, if size==chunkSize, we get 2 buffers, the second one empty:\n      assertTrue((size < chunkSize) ? (ii instanceof ByteBufferIndexInput.SingleBufferImpl) : (ii instanceof ByteBufferIndexInput.DefaultImpl));\n      \n      // clone tests:\n      assertSame(ii.getClass(), ii.clone().getClass());\n      \n      // slice test (offset 0)\n      int sliceSize = random().nextInt(size);\n      IndexInput slice = ii.slice(\"slice\", 0, sliceSize);\n      assertTrue((sliceSize < chunkSize) ? (slice instanceof ByteBufferIndexInput.SingleBufferImpl) : (slice instanceof ByteBufferIndexInput.DefaultImpl));\n\n      // slice test (offset > 0 )\n      int offset = random().nextInt(size - 1) + 1;\n      sliceSize = random().nextInt(size - offset + 1);\n      slice = ii.slice(\"slice\", offset, sliceSize);\n      //System.out.println(offset + \"/\" + sliceSize + \" chunkSize=\" + chunkSize + \" \" + slice.getClass());\n      if (offset % chunkSize + sliceSize < chunkSize) {\n        assertTrue(slice instanceof ByteBufferIndexInput.SingleBufferImpl);\n      } else if (offset % chunkSize == 0) {\n        assertTrue(slice instanceof ByteBufferIndexInput.DefaultImpl);\n      } else {\n        assertTrue(slice instanceof ByteBufferIndexInput.WithOffsetImpl);\n      }\n\n      ii.close();\n      mmapDir.close();\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9","date":1434069165,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testImplementations().mjava","sourceNew":"  public void testImplementations() throws Exception {\n    for (int i = 2; i < 12; i++) {\n      final int chunkSize = 1<<i;\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testImplementations\"), chunkSize);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      int size = random().nextInt(chunkSize * 2) + 3; // add some buffer of 3 for slice tests\n      byte bytes[] = new byte[size];\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[size]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      // reinit:\n      ii.seek(0L);\n      \n      // check impl (we must check size < chunksize: currently, if size==chunkSize, we get 2 buffers, the second one empty:\n      assertTrue((size < chunkSize) ? (ii instanceof ByteBufferIndexInput.SingleBufferImpl) : (ii instanceof ByteBufferIndexInput.MultiBufferImpl));\n      \n      // clone tests:\n      assertSame(ii.getClass(), ii.clone().getClass());\n      \n      // slice test (offset 0)\n      int sliceSize = random().nextInt(size);\n      IndexInput slice = ii.slice(\"slice\", 0, sliceSize);\n      assertTrue((sliceSize < chunkSize) ? (slice instanceof ByteBufferIndexInput.SingleBufferImpl) : (slice instanceof ByteBufferIndexInput.MultiBufferImpl));\n\n      // slice test (offset > 0 )\n      int offset = random().nextInt(size - 1) + 1;\n      sliceSize = random().nextInt(size - offset + 1);\n      slice = ii.slice(\"slice\", offset, sliceSize);\n      //System.out.println(offset + \"/\" + sliceSize + \" chunkSize=\" + chunkSize + \" \" + slice.getClass());\n      if (offset % chunkSize + sliceSize < chunkSize) {\n        assertTrue(slice instanceof ByteBufferIndexInput.SingleBufferImpl);\n      } else {\n        assertTrue(slice instanceof ByteBufferIndexInput.MultiBufferImpl);\n      }\n\n      ii.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":"  public void testImplementations() throws Exception {\n    for (int i = 2; i < 12; i++) {\n      final int chunkSize = 1<<i;\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testImplementations\"), chunkSize);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      int size = random().nextInt(chunkSize * 2) + 3; // add some buffer of 3 for slice tests\n      byte bytes[] = new byte[size];\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[size]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      // reinit:\n      ii.seek(0L);\n      \n      // check impl (we must check size < chunksize: currently, if size==chunkSize, we get 2 buffers, the second one empty:\n      assertTrue((size < chunkSize) ? (ii instanceof ByteBufferIndexInput.SingleBufferImpl) : (ii instanceof ByteBufferIndexInput.DefaultImpl));\n      \n      // clone tests:\n      assertSame(ii.getClass(), ii.clone().getClass());\n      \n      // slice test (offset 0)\n      int sliceSize = random().nextInt(size);\n      IndexInput slice = ii.slice(\"slice\", 0, sliceSize);\n      assertTrue((sliceSize < chunkSize) ? (slice instanceof ByteBufferIndexInput.SingleBufferImpl) : (slice instanceof ByteBufferIndexInput.DefaultImpl));\n\n      // slice test (offset > 0 )\n      int offset = random().nextInt(size - 1) + 1;\n      sliceSize = random().nextInt(size - offset + 1);\n      slice = ii.slice(\"slice\", offset, sliceSize);\n      //System.out.println(offset + \"/\" + sliceSize + \" chunkSize=\" + chunkSize + \" \" + slice.getClass());\n      if (offset % chunkSize + sliceSize < chunkSize) {\n        assertTrue(slice instanceof ByteBufferIndexInput.SingleBufferImpl);\n      } else if (offset % chunkSize == 0) {\n        assertTrue(slice instanceof ByteBufferIndexInput.DefaultImpl);\n      } else {\n        assertTrue(slice instanceof ByteBufferIndexInput.WithOffsetImpl);\n      }\n\n      ii.close();\n      mmapDir.close();\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9":["285cdc737de75b7cc7c284a156b20214deb67bca"],"285cdc737de75b7cc7c284a156b20214deb67bca":["f986320666d675a260eb4529a0c3c40595731441"],"f986320666d675a260eb4529a0c3c40595731441":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9"]},"commit2Childs":{"96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"285cdc737de75b7cc7c284a156b20214deb67bca":["96d86741fa6ad3b3a96fbf99f5e41bc74784c5f9"],"f986320666d675a260eb4529a0c3c40595731441":["285cdc737de75b7cc7c284a156b20214deb67bca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f986320666d675a260eb4529a0c3c40595731441"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}