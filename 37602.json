{"path":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetRequest.RangeEndpointCalculator#computeRanges().mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetRequest.RangeEndpointCalculator#computeRanges().mjava","pathOld":"/dev/null","sourceNew":"    public List<FacetRange> computeRanges() {\n      List<FacetRange> ranges = new ArrayList<>();\n\n      this.gap = getGap(rfr.getGap());\n      this.start = getValue(rfr.getStart());\n      // not final, hardend may change this\n      T end = getValue(rfr.getEnd());\n      if (end.compareTo(start) < 0) {\n        throw new SolrException\n            (SolrException.ErrorCode.BAD_REQUEST,\n                \"range facet 'end' comes before 'start': \" + end + \" < \" + start);\n      }\n\n      final EnumSet<FacetParams.FacetRangeInclude> include = rfr.getInclude();\n\n      T low = start;\n\n      while (low.compareTo(end) < 0) {\n        T high = addGap(low, rfr.getGap());\n        if (end.compareTo(high) < 0) {\n          if (rfr.isHardEnd()) {\n            high = end;\n          } else {\n            end = high;\n          }\n        }\n        if (high.compareTo(low) < 0) {\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"range facet infinite loop (is gap negative? did the math overflow?)\");\n        }\n        if (high.compareTo(low) == 0) {\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + rfr.getGap() + \" = \" + high);\n        }\n\n        final boolean includeLower =\n            (include.contains(FacetParams.FacetRangeInclude.LOWER) ||\n                (include.contains(FacetParams.FacetRangeInclude.EDGE) &&\n                    0 == low.compareTo(start)));\n        final boolean includeUpper =\n            (include.contains(FacetParams.FacetRangeInclude.UPPER) ||\n                (include.contains(FacetParams.FacetRangeInclude.EDGE) &&\n                    0 == high.compareTo(end)));\n\n        final String lowS = formatValue(low);\n        final String highS = formatValue(high);\n\n        ranges.add(new FacetRange(lowS, lowS, highS, includeLower, includeUpper));\n\n        low = high;\n      }\n\n      // we must update the end value in RangeFacetRequest because the end is returned\n      // as a separate element in the range facet response\n      this.computedEnd = end;\n      this.computed = true;\n\n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if (!rfr.getOthers().contains(FacetParams.FacetRangeOther.NONE)) {\n\n        boolean all = rfr.getOthers().contains(FacetParams.FacetRangeOther.ALL);\n        final String startS = formatValue(start);\n        final String endS = formatValue(end);\n\n        if (all || rfr.getOthers().contains(FacetParams.FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add(new FacetRange(FacetParams.FacetRangeOther.BEFORE,\n              null, startS, false, include.contains(FacetParams.FacetRangeInclude.OUTER) || include.contains(FacetParams.FacetRangeInclude.ALL) ||\n              !(include.contains(FacetParams.FacetRangeInclude.LOWER) || include.contains(FacetParams.FacetRangeInclude.EDGE))));\n        }\n        if (all || rfr.getOthers().contains(FacetParams.FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add(new FacetRange(FacetParams.FacetRangeOther.AFTER,\n              endS, null, include.contains(FacetParams.FacetRangeInclude.OUTER) || include.contains(FacetParams.FacetRangeInclude.ALL) ||\n              !(include.contains(FacetParams.FacetRangeInclude.UPPER) || include.contains(FacetParams.FacetRangeInclude.EDGE)), false));\n        }\n        if (all || rfr.getOthers().contains(FacetParams.FacetRangeOther.BETWEEN)) {\n          ranges.add(new FacetRange(FacetParams.FacetRangeOther.BETWEEN, startS, endS,\n              include.contains(FacetParams.FacetRangeInclude.LOWER) || include.contains(FacetParams.FacetRangeInclude.EDGE) || include.contains(FacetParams.FacetRangeInclude.ALL),\n              include.contains(FacetParams.FacetRangeInclude.UPPER) || include.contains(FacetParams.FacetRangeInclude.EDGE) || include.contains(FacetParams.FacetRangeInclude.ALL)));\n        }\n      }\n\n      return ranges;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}