{"path":"solr/core/src/java/org/apache/solr/cluster/placement/impl/AttributeFetcherImpl#fetchAttributes().mjava","commits":[{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/AttributeFetcherImpl#fetchAttributes().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public AttributeValues fetchAttributes() {\n        // TODO Code here only supports node related attributes for now\n\n        // Maps in which attribute values will be added\n        Map<Node, Integer> nodeToCoreCount = Maps.newHashMap();\n        Map<Node, DiskHardwareType> nodeToDiskType = Maps.newHashMap();\n        Map<Node, Long> nodeToFreeDisk = Maps.newHashMap();\n        Map<Node, Long> nodeToTotalDisk = Maps.newHashMap();\n        Map<Node, Double> nodeToHeapUsage = Maps.newHashMap();\n        Map<Node, Double> nodeToSystemLoadAverage = Maps.newHashMap();\n        Map<String, Map<Node, String>> syspropSnitchToNodeToValue = Maps.newHashMap();\n        Map<String, Map<Node, Double>> metricSnitchToNodeToValue = Maps.newHashMap();\n\n        // In order to match the returned values for the various snitches, we need to keep track of where each\n        // received value goes. Given the target maps are of different types (the maps from Node to whatever defined\n        // above) we instead pass a function taking two arguments, the node and the (non null) returned value,\n        // that will cast the value into the appropriate type for the snitch tag and insert it into the appropriate map\n        // with the node as the key.\n        Map<String, BiConsumer<Node, Object>> allSnitchTagsToInsertion = Maps.newHashMap();\n        if (requestedNodeCoreCount) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.CORES, (node, value) -> nodeToCoreCount.put(node, ((Number) value).intValue()));\n        }\n        if (requestedNodeDiskType) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.DISKTYPE, (node, value) -> {\n                if (\"rotational\".equals(value)) {\n                    nodeToDiskType.put(node, DiskHardwareType.ROTATIONAL);\n                } else if (\"ssd\".equals(value)) {\n                    nodeToDiskType.put(node, DiskHardwareType.SSD);\n                }\n                // unknown disk type: insert no value, returned optional will be empty\n            });\n        }\n        if (requestedNodeFreeDisk) {\n            allSnitchTagsToInsertion.put(SolrClientNodeStateProvider.Variable.FREEDISK.tagName,\n                    // Convert from bytes to GB\n                    (node, value) -> nodeToFreeDisk.put(node, ((Number) value).longValue() / 1024 / 1024 / 1024));\n        }\n        if (requestedNodeTotalDisk) {\n            allSnitchTagsToInsertion.put(SolrClientNodeStateProvider.Variable.TOTALDISK.tagName,\n                    // Convert from bytes to GB\n                    (node, value) -> nodeToTotalDisk.put(node, ((Number) value).longValue() / 1024 / 1024 / 1024));\n        }\n        if (requestedNodeHeapUsage) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.HEAPUSAGE,\n                    (node, value) -> nodeToHeapUsage.put(node, ((Number) value).doubleValue()));\n        }\n        if (requestedNodeSystemLoadAverage) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.SYSLOADAVG,\n                    (node, value) -> nodeToSystemLoadAverage.put(node, ((Number) value).doubleValue()));\n        }\n        for (String sysPropSnitch : requestedNodeSystemPropertiesSnitchTags) {\n            final Map<Node, String> sysPropMap = Maps.newHashMap();\n            syspropSnitchToNodeToValue.put(sysPropSnitch, sysPropMap);\n            allSnitchTagsToInsertion.put(sysPropSnitch, (node, value) -> sysPropMap.put(node, (String) value));\n        }\n        for (String metricSnitch : requestedNodeMetricSnitchTags) {\n            final Map<Node, Double> metricMap = Maps.newHashMap();\n            metricSnitchToNodeToValue.put(metricSnitch, metricMap);\n            allSnitchTagsToInsertion.put(metricSnitch, (node, value) -> metricMap.put(node, (Double) value));\n        }\n\n        // Now that we know everything we need to fetch (and where to put it), just do it.\n        for (Node node : nodes) {\n            Map<String, Object> tagValues = cloudManager.getNodeStateProvider().getNodeValues(node.getName(), allSnitchTagsToInsertion.keySet());\n            for (Map.Entry<String, Object> e : tagValues.entrySet()) {\n                String tag = e.getKey();\n                Object value = e.getValue(); // returned value from the node\n\n                BiConsumer<Node, Object> inserter = allSnitchTagsToInsertion.get(tag);\n                // If inserter is null it's a return of a tag that we didn't request\n                if (inserter != null) {\n                    inserter.accept(node, value);\n                } else {\n                    log.error(\"Received unsolicited snitch tag {} from node {}\", tag, node);\n                }\n            }\n        }\n\n        return new AttributeValuesImpl(nodeToCoreCount,\n                                       nodeToDiskType,\n                                       nodeToFreeDisk,\n                                       nodeToTotalDisk,\n                                       nodeToHeapUsage,\n                                       nodeToSystemLoadAverage,\n                                       syspropSnitchToNodeToValue,\n                                       metricSnitchToNodeToValue);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":0,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/AttributeFetcherImpl#fetchAttributes().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public AttributeValues fetchAttributes() {\n        // TODO Code here only supports node related attributes for now\n\n        // Maps in which attribute values will be added\n        Map<Node, Integer> nodeToCoreCount = Maps.newHashMap();\n        Map<Node, DiskHardwareType> nodeToDiskType = Maps.newHashMap();\n        Map<Node, Long> nodeToFreeDisk = Maps.newHashMap();\n        Map<Node, Long> nodeToTotalDisk = Maps.newHashMap();\n        Map<Node, Double> nodeToHeapUsage = Maps.newHashMap();\n        Map<Node, Double> nodeToSystemLoadAverage = Maps.newHashMap();\n        Map<String, Map<Node, String>> syspropSnitchToNodeToValue = Maps.newHashMap();\n        Map<String, Map<Node, Double>> metricSnitchToNodeToValue = Maps.newHashMap();\n\n        // In order to match the returned values for the various snitches, we need to keep track of where each\n        // received value goes. Given the target maps are of different types (the maps from Node to whatever defined\n        // above) we instead pass a function taking two arguments, the node and the (non null) returned value,\n        // that will cast the value into the appropriate type for the snitch tag and insert it into the appropriate map\n        // with the node as the key.\n        Map<String, BiConsumer<Node, Object>> allSnitchTagsToInsertion = Maps.newHashMap();\n        if (requestedNodeCoreCount) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.CORES, (node, value) -> nodeToCoreCount.put(node, ((Number) value).intValue()));\n        }\n        if (requestedNodeDiskType) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.DISKTYPE, (node, value) -> {\n                if (\"rotational\".equals(value)) {\n                    nodeToDiskType.put(node, DiskHardwareType.ROTATIONAL);\n                } else if (\"ssd\".equals(value)) {\n                    nodeToDiskType.put(node, DiskHardwareType.SSD);\n                }\n                // unknown disk type: insert no value, returned optional will be empty\n            });\n        }\n        if (requestedNodeFreeDisk) {\n            allSnitchTagsToInsertion.put(SolrClientNodeStateProvider.Variable.FREEDISK.tagName,\n                    // Convert from bytes to GB\n                    (node, value) -> nodeToFreeDisk.put(node, ((Number) value).longValue() / 1024 / 1024 / 1024));\n        }\n        if (requestedNodeTotalDisk) {\n            allSnitchTagsToInsertion.put(SolrClientNodeStateProvider.Variable.TOTALDISK.tagName,\n                    // Convert from bytes to GB\n                    (node, value) -> nodeToTotalDisk.put(node, ((Number) value).longValue() / 1024 / 1024 / 1024));\n        }\n        if (requestedNodeHeapUsage) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.HEAPUSAGE,\n                    (node, value) -> nodeToHeapUsage.put(node, ((Number) value).doubleValue()));\n        }\n        if (requestedNodeSystemLoadAverage) {\n            allSnitchTagsToInsertion.put(ImplicitSnitch.SYSLOADAVG,\n                    (node, value) -> nodeToSystemLoadAverage.put(node, ((Number) value).doubleValue()));\n        }\n        for (String sysPropSnitch : requestedNodeSystemPropertiesSnitchTags) {\n            final Map<Node, String> sysPropMap = Maps.newHashMap();\n            syspropSnitchToNodeToValue.put(sysPropSnitch, sysPropMap);\n            allSnitchTagsToInsertion.put(sysPropSnitch, (node, value) -> sysPropMap.put(node, (String) value));\n        }\n        for (String metricSnitch : requestedNodeMetricSnitchTags) {\n            final Map<Node, Double> metricMap = Maps.newHashMap();\n            metricSnitchToNodeToValue.put(metricSnitch, metricMap);\n            allSnitchTagsToInsertion.put(metricSnitch, (node, value) -> metricMap.put(node, (Double) value));\n        }\n\n        // Now that we know everything we need to fetch (and where to put it), just do it.\n        for (Node node : nodes) {\n            Map<String, Object> tagValues = cloudManager.getNodeStateProvider().getNodeValues(node.getName(), allSnitchTagsToInsertion.keySet());\n            for (Map.Entry<String, Object> e : tagValues.entrySet()) {\n                String tag = e.getKey();\n                Object value = e.getValue(); // returned value from the node\n\n                BiConsumer<Node, Object> inserter = allSnitchTagsToInsertion.get(tag);\n                // If inserter is null it's a return of a tag that we didn't request\n                if (inserter != null) {\n                    inserter.accept(node, value);\n                } else {\n                    log.error(\"Received unsolicited snitch tag {} from node {}\", tag, node);\n                }\n            }\n        }\n\n        return new AttributeValuesImpl(nodeToCoreCount,\n                                       nodeToDiskType,\n                                       nodeToFreeDisk,\n                                       nodeToTotalDisk,\n                                       nodeToHeapUsage,\n                                       nodeToSystemLoadAverage,\n                                       syspropSnitchToNodeToValue,\n                                       metricSnitchToNodeToValue);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65352f844eb9e9a677ec4eb2abced4404f08181d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}