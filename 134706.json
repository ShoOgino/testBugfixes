{"path":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      h = PRIME * h + ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      h = PRIME * h + ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      h = PRIME * h + ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      h = PRIME * h + ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","date":1370275238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private int hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    int h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Integer.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"232252bc7056b698c1e1c550f4b97a9a3c00e520","date":1372943634,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f948dd442d23baa6cbb28daf77c8db78b351329","date":1378742876,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the un-frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for(int arcIdx=0;arcIdx<node.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(FSTCompiler.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((FSTCompiler.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(FSTCompiler.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((FSTCompiler.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"232252bc7056b698c1e1c550f4b97a9a3c00e520":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["ae67e1f82a53594208ca929f382ee861dad3d7a8","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"2f948dd442d23baa6cbb28daf77c8db78b351329":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","232252bc7056b698c1e1c550f4b97a9a3c00e520"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5":["232252bc7056b698c1e1c550f4b97a9a3c00e520","2f948dd442d23baa6cbb28daf77c8db78b351329"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["cf254a9a31b4dc0cc4d29c23ec1cd5c6934081b5","8917bfede3b4ca30f4305c1e391e9218959cd723"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","8917bfede3b4ca30f4305c1e391e9218959cd723"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"232252bc7056b698c1e1c550f4b97a9a3c00e520":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2f948dd442d23baa6cbb28daf77c8db78b351329":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}