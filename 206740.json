{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6101715a4732c1fe39eae50ce4a23fec6fc270d0","date":1328795951,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027","date":1328885564,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"99a533edf1b9ea2c1b85e012d6e826545389e9c8","date":1329256696,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d","date":1330786058,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df525117ddb4dc8c8fe6e9fded68f55b29070496","date":1331258843,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n    \n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0377027c7e39adc44758ebf8f66d66fce2a39ac0","date":1337700304,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2f59708a551dd34352ee9fe123544927201cf7b","date":1337819003,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b52dd493156fb4023d158d49e1ea92dbf3c20871","date":1337893063,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63fce89dfe8a5dcba79c726470441c175441f122","date":1342202709,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n    CloudSolrServer server = new CloudSolrServer(zkServer.getZkAddress());\n    server.setDefaultCollection(DEFAULT_COLLECTION);\n    solrj = server;\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n//    // TODO: This test currently fails because debug info is obtained only\n//    // on shards with matches.\n//    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n//\n//    // would be better if these where all separate tests - but much, much\n//    // slower\n//    doOptimisticLockingAndUpdating();\n//    testMultipleCollections();\n//    testANewCollectionInOneInstance();\n//    testSearchByCollectionName();\n//    testANewCollectionInOneInstanceWithManualShardAssignement();\n//    testNumberOfCommitsWithCommitAfterAdd();\n//\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01d7038753e558c19fba37629cb45f9740316fe7","date":1342203005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n    CloudSolrServer server = new CloudSolrServer(zkServer.getZkAddress());\n    server.setDefaultCollection(DEFAULT_COLLECTION);\n    solrj = server;\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n//    // TODO: This test currently fails because debug info is obtained only\n//    // on shards with matches.\n//    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n//\n//    // would be better if these where all separate tests - but much, much\n//    // slower\n//    doOptimisticLockingAndUpdating();\n//    testMultipleCollections();\n//    testANewCollectionInOneInstance();\n//    testSearchByCollectionName();\n//    testANewCollectionInOneInstanceWithManualShardAssignement();\n//    testNumberOfCommitsWithCommitAfterAdd();\n//\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d","date":1344284819,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"); \n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":["df525117ddb4dc8c8fe6e9fded68f55b29070496","bed62fe6383040eaff2ec720cdc55bb1462c61da","9001fdb834e467ef899e41c747c42b27b4d45099"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n//    doOptimisticLockingAndUpdating();\n//    testMultipleCollections();\n//    testANewCollectionInOneInstance();\n//    testSearchByCollectionName();\n//    testANewCollectionInOneInstanceWithManualShardAssignement();\n//    testNumberOfCommitsWithCommitAfterAdd();\n//\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n//\n//    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","01d7038753e558c19fba37629cb45f9740316fe7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a","date":1351228731,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n//    doOptimisticLockingAndUpdating();\n//    testMultipleCollections();\n//    testANewCollectionInOneInstance();\n//    testSearchByCollectionName();\n//    testANewCollectionInOneInstanceWithManualShardAssignement();\n//    testNumberOfCommitsWithCommitAfterAdd();\n//\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n//    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n//\n//    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    \n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    \n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82f063229e39b59c960866c1bc49285b95676491","date":1352733047,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c7cbf6b69f2a4acc536536fe1a152a8ad572d05","date":1353362776,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56a558aa5aadd60ae850d1ab090098bc63bdfaf9","date":1355245333,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0eff89b16ebd0046c839c5d02ee44500be5c7886","date":1355766557,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCollectionsAPI();\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81a4a1810b619aea1d002a09c1878b498e20bf33","date":1361142322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testCoreUnloadAndLeaders();\n    testUnloadLotsOfCores();\n    testStopAndStartCoresInOneInstance();\n    testUnloadShardAndCollection();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39192e50fe6a8aa77489a5dd93628b927c59ba6f","date":1362088059,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e14913df9327ed5dfa00075dc1ff09137dbdb896","date":1366997648,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1","date":1369336666,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9","date":1371479482,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    del(\"*:*\");\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9d424bd039937b4125152b454b3a32754b06f6c","date":1384391321,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab8657e27d6bdd6107b9d64da71c635e1f47b59e","date":1390524786,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 15000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work\", before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad4ed4be0c80b0aba123ee2c92bc046018ff127b","date":1393119817,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work\", before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 15000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work\", before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3677f29533e335483213ea0f0904780a54265760","date":1404597500,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrServer)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work\", before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrServer)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrServer)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":["2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrClient client : clients) {\n      foo_i_counter++;\n      indexDoc(client, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrClient client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrClient)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrServer server : clients) {\n      foo_i_counter++;\n      indexDoc(server, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrServer client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrServer)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acd7f5c2e175f7bc3bd2a5405dbde3010b49e390","date":1420990403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrClient client : clients) {\n      foo_i_counter++;\n      indexDoc(client, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 45000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrClient client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrClient)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrClient client : clients) {\n      foo_i_counter++;\n      indexDoc(client, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 30000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrClient client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrClient)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 4)\n  public void test() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrClient client : clients) {\n      foo_i_counter++;\n      indexDoc(client, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 45000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrClient client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrClient)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    // setLoggingLevel(null);\n\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    // make sure we have leaders for each shard\n    for (int j = 1; j < sliceCount; j++) {\n      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard\" + j, 10000);\n    }      // make sure we again have leaders for each shard\n    \n    waitForRecoveriesToFinish(false);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n\n    del(\"*:*\");\n    queryAndCompareShards(params(\"q\", \"*:*\", \"distrib\", \"false\", \"sanity_check\", \"is_empty\"));\n\n    // ask every individual replica of every shard to update+commit the same doc id\n    // with an incrementing counter on each update+commit\n    int foo_i_counter = 0;\n    for (SolrClient client : clients) {\n      foo_i_counter++;\n      indexDoc(client, params(\"commit\", \"true\"), // SOLR-4923\n               sdoc(id,1, i1,100, tlong,100, \"foo_i\", foo_i_counter));\n      // after every update+commit, check all the shards consistency\n      queryAndCompareShards(params(\"q\", \"id:1\", \"distrib\", \"false\", \n                                   \"sanity_check\", \"non_distrib_id_1_lookup\"));\n      queryAndCompareShards(params(\"q\", \"id:1\", \n                                   \"sanity_check\", \"distrib_id_1_lookup\"));\n    }\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n    queryAndCompareShards(params(\"q\", \"*:*\", \n                                 \"sort\", \"id desc\",\n                                 \"distrib\", \"false\", \n                                 \"sanity_check\", \"is_empty\"));\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" desc\"});\n      query(false, new String[] {\"q\",\"*:*\", \"sort\",f+\" asc\"});\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" asc\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"*,score\"}); \n    query(false, new String[] {\"q\",\"*:*\", \"sort\",\"n_tl1 desc\"});\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"{!func}\"+i1});// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(false, new String[] {\"q\",\"{!func}\"+i1, \"fl\",\"*,score\"});  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\"});  // no fields in returned docs\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\"});\n\n    handle.put(\"score\", SKIPVAL);\n    query(false, new String[] {\"q\",\"quick\",\"fl\",\"*,score\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\"});\n    query(false, new String[] {\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\"});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1});\n\n    query(false, new String[] {\"q\",\"matchesnothing\",\"fl\",\"*,score\"});  \n\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1});\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2});\n\n    // test faceting multiple things at once\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1});\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"}\n    );\n    query(false, new Object[] {\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\"});\n\n    // test field that is valid in schema but missing in all shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2});\n    // test field that is valid in schema and missing in some shards\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2});\n\n    query(false, new Object[] {\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1});\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    // check a complex key name\n    query(false, new Object[] {\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5});\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(false, new Object[] {\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1});\n      query(false, new Object[] {\"q\",\"*:*\", \"rows\",100});\n    }\n\n    // test debugging\n    handle.put(\"explain\", SKIPVAL);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    handle.put(\"track\", SKIP);\n    query(false, new Object[] {\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\"});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS});\n    query(false, new Object[] {\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY});\n\n    // try commitWithin\n    long before = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"commitWithin\", 10);\n    add(cloudClient, params , getDoc(\"id\", 300));\n    \n    long timeout = System.currentTimeMillis() + 45000;\n    while (cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() != before + 1) {\n      if (timeout <= System.currentTimeMillis()) {\n        fail(\"commitWithin did not work\");\n      }\n      Thread.sleep(100);\n    }\n    \n    for (SolrClient client : clients) {\n      assertEquals(\"commitWithin did not work on node: \" + ((HttpSolrClient)client).getBaseURL(), before + 1, client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // would be better if these where all separate tests - but much, much\n    // slower\n    doOptimisticLockingAndUpdating();\n    testShardParamVariations();\n    testMultipleCollections();\n    testANewCollectionInOneInstance();\n    testSearchByCollectionName();\n    testUpdateByCollectionName();\n    testANewCollectionInOneInstanceWithManualShardAssignement();\n    testNumberOfCommitsWithCommitAfterAdd();\n\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-explicit\");\n    testUpdateProcessorsRunOnlyOnce(\"distrib-dup-test-chain-implicit\");\n\n    testStopAndStartCoresInOneInstance();\n    testFailedCoreCreateCleansUp();\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d":["01d7038753e558c19fba37629cb45f9740316fe7"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1","2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["99a533edf1b9ea2c1b85e012d6e826545389e9c8","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["1525b4dfbc0d413b8d7247da232009778e624836"],"ab8657e27d6bdd6107b9d64da71c635e1f47b59e":["d9d424bd039937b4125152b454b3a32754b06f6c"],"f2f59708a551dd34352ee9fe123544927201cf7b":["0377027c7e39adc44758ebf8f66d66fce2a39ac0"],"f2126b84bd093fa3d921582a109a0ee578c28126":["e19067e820b148e8dc0b240da4f2771cf7b68252","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","df525117ddb4dc8c8fe6e9fded68f55b29070496"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"df525117ddb4dc8c8fe6e9fded68f55b29070496":["d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"63fce89dfe8a5dcba79c726470441c175441f122":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"6101715a4732c1fe39eae50ce4a23fec6fc270d0":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0377027c7e39adc44758ebf8f66d66fce2a39ac0":["1bea3922196318026c4274f2013416acb60c691e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","01d7038753e558c19fba37629cb45f9740316fe7"],"8c7cbf6b69f2a4acc536536fe1a152a8ad572d05":["82f063229e39b59c960866c1bc49285b95676491"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["33d0ed80b7b47e34ad3ff033a77544563aba3085","5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"82f063229e39b59c960866c1bc49285b95676491":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"b52dd493156fb4023d158d49e1ea92dbf3c20871":["3599646b4d4c346cf74d334813488b8b337b5bf5","f2f59708a551dd34352ee9fe123544927201cf7b"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","0eff89b16ebd0046c839c5d02ee44500be5c7886"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["3677f29533e335483213ea0f0904780a54265760"],"81a4a1810b619aea1d002a09c1878b498e20bf33":["0eff89b16ebd0046c839c5d02ee44500be5c7886"],"abb23fcc2461782ab204e61213240feb77d355aa":["acd7f5c2e175f7bc3bd2a5405dbde3010b49e390"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"bafca15d8e408346a67f4282ad1143b88023893b":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"1bea3922196318026c4274f2013416acb60c691e":["df525117ddb4dc8c8fe6e9fded68f55b29070496"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["0eff89b16ebd0046c839c5d02ee44500be5c7886","81a4a1810b619aea1d002a09c1878b498e20bf33"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"ad4ed4be0c80b0aba123ee2c92bc046018ff127b":["ab8657e27d6bdd6107b9d64da71c635e1f47b59e"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["1bea3922196318026c4274f2013416acb60c691e","0377027c7e39adc44758ebf8f66d66fce2a39ac0"],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["39192e50fe6a8aa77489a5dd93628b927c59ba6f"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["8c7cbf6b69f2a4acc536536fe1a152a8ad572d05"],"39192e50fe6a8aa77489a5dd93628b927c59ba6f":["81a4a1810b619aea1d002a09c1878b498e20bf33"],"acd7f5c2e175f7bc3bd2a5405dbde3010b49e390":["bafca15d8e408346a67f4282ad1143b88023893b"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","8c7cbf6b69f2a4acc536536fe1a152a8ad572d05"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"3677f29533e335483213ea0f0904780a54265760":["ad4ed4be0c80b0aba123ee2c92bc046018ff127b"],"d9d424bd039937b4125152b454b3a32754b06f6c":["2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"01d7038753e558c19fba37629cb45f9740316fe7":["63fce89dfe8a5dcba79c726470441c175441f122"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027":["6101715a4732c1fe39eae50ce4a23fec6fc270d0"],"1525b4dfbc0d413b8d7247da232009778e624836":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["f2f59708a551dd34352ee9fe123544927201cf7b"]},"commit2Childs":{"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d":["d6f074e73200c07d54f242d3880a8da5a35ff97b","c7869f64c874ebf7f317d22c00baf2b6857797a6","e19067e820b148e8dc0b240da4f2771cf7b68252"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["37a0f60745e53927c4c876cfe5b5a58170f0646c","2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","82f063229e39b59c960866c1bc49285b95676491","407687e67faf6e1f02a211ca078d8e3eed631027"],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"ab8657e27d6bdd6107b9d64da71c635e1f47b59e":["ad4ed4be0c80b0aba123ee2c92bc046018ff127b"],"f2f59708a551dd34352ee9fe123544927201cf7b":["b52dd493156fb4023d158d49e1ea92dbf3c20871","e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["63fce89dfe8a5dcba79c726470441c175441f122","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d9d424bd039937b4125152b454b3a32754b06f6c"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"df525117ddb4dc8c8fe6e9fded68f55b29070496":["38e3b736c7ca086d61b7dbb841c905ee115490da","1bea3922196318026c4274f2013416acb60c691e"],"63fce89dfe8a5dcba79c726470441c175441f122":["01d7038753e558c19fba37629cb45f9740316fe7"],"6101715a4732c1fe39eae50ce4a23fec6fc270d0":["7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027"],"0377027c7e39adc44758ebf8f66d66fce2a39ac0":["f2f59708a551dd34352ee9fe123544927201cf7b","3599646b4d4c346cf74d334813488b8b337b5bf5"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"8c7cbf6b69f2a4acc536536fe1a152a8ad572d05":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9","407687e67faf6e1f02a211ca078d8e3eed631027"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"82f063229e39b59c960866c1bc49285b95676491":["8c7cbf6b69f2a4acc536536fe1a152a8ad572d05"],"b52dd493156fb4023d158d49e1ea92dbf3c20871":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"072f211dfa8387028bb978d128c35bf9a450bbbf":["bafca15d8e408346a67f4282ad1143b88023893b"],"81a4a1810b619aea1d002a09c1878b498e20bf33":["09c8567c25c02eeeb3e719841606a1269f3538ca","39192e50fe6a8aa77489a5dd93628b927c59ba6f"],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bafca15d8e408346a67f4282ad1143b88023893b":["acd7f5c2e175f7bc3bd2a5405dbde3010b49e390"],"1bea3922196318026c4274f2013416acb60c691e":["0377027c7e39adc44758ebf8f66d66fce2a39ac0","3599646b4d4c346cf74d334813488b8b337b5bf5"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"ad4ed4be0c80b0aba123ee2c92bc046018ff127b":["3677f29533e335483213ea0f0904780a54265760"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["b52dd493156fb4023d158d49e1ea92dbf3c20871"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","81a4a1810b619aea1d002a09c1878b498e20bf33","09c8567c25c02eeeb3e719841606a1269f3538ca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["0eff89b16ebd0046c839c5d02ee44500be5c7886"],"39192e50fe6a8aa77489a5dd93628b927c59ba6f":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"acd7f5c2e175f7bc3bd2a5405dbde3010b49e390":["abb23fcc2461782ab204e61213240feb77d355aa"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","df525117ddb4dc8c8fe6e9fded68f55b29070496"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["f2126b84bd093fa3d921582a109a0ee578c28126","1525b4dfbc0d413b8d7247da232009778e624836"],"3677f29533e335483213ea0f0904780a54265760":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"d9d424bd039937b4125152b454b3a32754b06f6c":["ab8657e27d6bdd6107b9d64da71c635e1f47b59e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"01d7038753e558c19fba37629cb45f9740316fe7":["5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","6101715a4732c1fe39eae50ce4a23fec6fc270d0","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"1525b4dfbc0d413b8d7247da232009778e624836":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","f2126b84bd093fa3d921582a109a0ee578c28126","38e3b736c7ca086d61b7dbb841c905ee115490da","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","d6f074e73200c07d54f242d3880a8da5a35ff97b","b52dd493156fb4023d158d49e1ea92dbf3c20871","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09c8567c25c02eeeb3e719841606a1269f3538ca","0d22ac6a4146774c1bc8400160fc0b6150294e92","c7869f64c874ebf7f317d22c00baf2b6857797a6","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}