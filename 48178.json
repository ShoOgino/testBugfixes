{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomaton(automata, automaton_provider),\n            exp2.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomaton(automata, automaton_provider),\n            exp2.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomatonInternal(Map[String,Automaton],AutomatonProvider,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomatonInternal(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider, int maxDeterminizedStates)\n      throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider,\n          maxDeterminizedStates);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider, maxDeterminizedStates);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates),\n            exp2.toAutomatonInternal(\n              automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomatonInternal(automata,\n          automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomatonInternal(\n          automata, automaton_provider, maxDeterminizedStates));\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          min,\n          max);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(\n          exp1.toAutomatonInternal(automata, automaton_provider,\n            maxDeterminizedStates),\n          maxDeterminizedStates);\n        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomaton(automata, automaton_provider),\n            exp2.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b316f82baae88f5e279893a9cb7eee51fd8902f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}