{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","commits":[{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"11ab475c994c79138885cc8a30b2641d929cdc43":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["11ab475c994c79138885cc8a30b2641d929cdc43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["58b93c361b4f6fe193e84bfd27ea523366eada52"]},"commit2Childs":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"11ab475c994c79138885cc8a30b2641d929cdc43":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["11ab475c994c79138885cc8a30b2641d929cdc43","8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"8908009aaa8e9318b455c1c22b83e0e87738228a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8908009aaa8e9318b455c1c22b83e0e87738228a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}