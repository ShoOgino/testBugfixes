{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","commits":[{"id":"32f306edd62f81390a6e263e8b913f089f3e98a1","date":1305615519,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"/dev/null","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes ;   \n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f7698eeb1d6d7bff293dff708890f1a4849a45b4","73f7144b3d593d06882d826ef9e09bd8a1b75614"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"/dev/null","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes ;   \n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"/dev/null","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes ;   \n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76694aa6cdd8b1a568b516850630eb73a9c7ad91","date":1308045718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes + \" pending: \" + numPending + \" flushing: \" + numFlushingDWPT() + \" blocked: \" + numBlockedFlushes() + \" peakDelta: \" + peakDelta ;   \n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes ;   \n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["73f7144b3d593d06882d826ef9e09bd8a1b75614"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes + \" pending: \" + numPending + \" flushing: \" + numFlushingDWPT() + \" blocked: \" + numBlockedFlushes() + \" peakDelta: \" + peakDelta ;   \n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes ;   \n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73f7144b3d593d06882d826ef9e09bd8a1b75614","date":1308152318,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes + \" pending: \" + numPending + \" flushing: \" + numFlushingDWPT() + \" blocked: \" + numBlockedFlushes() + \" peakDelta: \" + peakDelta ;   \n    }\n    return true;\n  }\n\n","bugFix":["32f306edd62f81390a6e263e8b913f089f3e98a1","76694aa6cdd8b1a568b516850630eb73a9c7ad91"],"bugIntro":["3570e776df3671c1bce4f54b07bf03ca5a2c23de","f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (maxConfiguredRamBuffer * 1024 * 1024)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      assert ram <= expected  : \"ram was \" + ram + \" expected: \" + expected + \" flush mem: \" + flushBytes + \" active: \" + activeBytes + \" pending: \" + numPending + \" flushing: \" + numFlushingDWPT() + \" blocked: \" + numBlockedFlushes() + \" peakDelta: \" + peakDelta ;   \n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (long)(2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"73f7144b3d593d06882d826ef9e09bd8a1b75614":["76694aa6cdd8b1a568b516850630eb73a9c7ad91"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"2553b00f699380c64959ccb27991289aae87be2e":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","fd9cc9d77712aba3662f24632df7539ab75e3667"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["73f7144b3d593d06882d826ef9e09bd8a1b75614","fd9cc9d77712aba3662f24632df7539ab75e3667"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["a3776dccca01c11e7046323cfad46a3b4a471233","76694aa6cdd8b1a568b516850630eb73a9c7ad91"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["9ed208afa1e7aa98899ddb1dedfddedddf898253","73f7144b3d593d06882d826ef9e09bd8a1b75614"],"76694aa6cdd8b1a568b516850630eb73a9c7ad91":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","32f306edd62f81390a6e263e8b913f089f3e98a1"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","32f306edd62f81390a6e263e8b913f089f3e98a1"],"32f306edd62f81390a6e263e8b913f089f3e98a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["73f7144b3d593d06882d826ef9e09bd8a1b75614"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"73f7144b3d593d06882d826ef9e09bd8a1b75614":["d083e83f225b11e5fdd900e83d26ddb385b6955c","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","fd9cc9d77712aba3662f24632df7539ab75e3667"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["2553b00f699380c64959ccb27991289aae87be2e"],"76694aa6cdd8b1a568b516850630eb73a9c7ad91":["73f7144b3d593d06882d826ef9e09bd8a1b75614","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"a3776dccca01c11e7046323cfad46a3b4a471233":["9ed208afa1e7aa98899ddb1dedfddedddf898253"],"32f306edd62f81390a6e263e8b913f089f3e98a1":["76694aa6cdd8b1a568b516850630eb73a9c7ad91","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","32f306edd62f81390a6e263e8b913f089f3e98a1"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","c3a8a449466c1ff7ce2274fe73dab487256964b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}