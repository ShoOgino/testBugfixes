{"path":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","commits":[{"id":"75b4d037d2c8fd7d68c07be61d25c0260cf8091e","date":1336829560,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,boolean).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.avoidCodecs = avoidCodecs;\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    add(new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock));\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    add(new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    add(new MockSepPostingsFormat());\n    add(new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)));\n    add(new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)));\n    add(new MockRandomPostingsFormat(random));\n    add(new NestedPulsingPostingsFormat());\n    add(new Lucene40WithOrds());\n    add(new SimpleTextPostingsFormat());\n    add(new MemoryPostingsFormat(random.nextBoolean()));\n    Collections.shuffle(formats, random);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, boolean useNoMemoryExpensiveCodec) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    formats.add(new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock));\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    formats.add(new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    formats.add(new MockSepPostingsFormat());\n    formats.add(new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)));\n    formats.add(new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)));\n    formats.add(new MockRandomPostingsFormat(random));\n    formats.add(new NestedPulsingPostingsFormat());\n    formats.add(new Lucene40WithOrds());\n    if (!useNoMemoryExpensiveCodec) {\n      formats.add(new SimpleTextPostingsFormat());\n      formats.add(new MemoryPostingsFormat(random.nextBoolean()));\n    }\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    // TODO: make it possible to specify min/max iterms per block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(random.nextBoolean()));\n\n    Collections.shuffle(formats, random);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.avoidCodecs = avoidCodecs;\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    add(new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock));\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    add(new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    add(new MockSepPostingsFormat());\n    add(new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)));\n    add(new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)));\n    add(new MockRandomPostingsFormat(random));\n    add(new NestedPulsingPostingsFormat());\n    add(new Lucene40WithOrds());\n    add(new SimpleTextPostingsFormat());\n    add(new MemoryPostingsFormat(random.nextBoolean()));\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":null,"bugIntro":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f","date":1338408958,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true),\n        new MemoryPostingsFormat(false));\n\n    Collections.shuffle(formats, random);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    // TODO: make it possible to specify min/max iterms per block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(random.nextBoolean()));\n\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":["75b4d037d2c8fd7d68c07be61d25c0260cf8091e","5da0b42730b6b99b31389ef94cb97384e83b9ede"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true),\n        new MemoryPostingsFormat(false));\n\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e8faf10211a6fbcdd8675af75977da20199190","date":1340393829,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":null,"bugIntro":["400c694e5772b60e1a176127d6b1349bf6b6380e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3128e6d07d9fef0d1aa24f58b07133c9293131b2","date":1342190719,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"172cf08877d0e6738a51edd238c4dc5ffc088345","date":1342794823,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(minItemsPerBlock, lowFreqCutoff),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3da87ae09fdb5c01fbaf2cdb982c63db67843d1b","date":1342881417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(minItemsPerBlock, lowFreqCutoff),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0274c27988a26cb0cda3a0d15b282221b1b453f0","date":1343923460,"type":3,"author":"Mark Harwood","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1175de689f57b0cb8a2604ba4a6874ae32e112d","date":1345759554,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"400c694e5772b60e1a176127d6b1349bf6b6380e","date":1347927004,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats.subList(4, formats.size()).clear();\n  }\n\n","bugFix":["02e8faf10211a6fbcdd8675af75977da20199190"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf8086c7e11dc41303ef1b8050bd355ddfaee76d","date":1350007219,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6616b1fd222bb5a60f7f7856ace312252bc97890","date":1350142044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7492bcb52be51e55d596134b95b2e53cc4ffb91","date":1350223278,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene40PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new BlockPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing40PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene40Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene40Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene40WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b923fc833f1cce9fb09dfe2ced037c9d55fd43","date":1357684159,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene41SimpleDocValuesFormat(),\n        new SimpleTextSimpleDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7a738ebbf9537051521dcc7e49f69208f91e2fc","date":1358194026,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new DiskDocValuesFormat(),\n        new SimpleTextSimpleDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene41SimpleDocValuesFormat(),\n        new SimpleTextSimpleDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new DiskDocValuesFormat(),\n        new SimpleTextSimpleDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f06b860886fc48ea071171354835b8aed8a94de","date":1358789970,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene41DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new MemoryDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e","date":1358793943,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene41DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59d00acb12c9809438e21de7c24f016356973d46","date":1359349254,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f2be786bbf3746ffcd9720e0b473f4b121c4228","date":1359663177,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    // only if we get big dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    dvFormats = dvFormats.subList(0, 4);\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n\n    Collections.shuffle(formats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15adb143a3097f2342f07eb0929f6ce1877ad7e","date":1361027406,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    formats = formats.subList(0, 4);\n    dvFormats = dvFormats.subList(0, 4);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a45bec74b98f6fc05f52770cfb425739e6563960","date":1375119292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11a746437bc5c0a0b3df0337ed249c387c812871","date":1376687959,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8550173e67bccdaad7c5cbb85fb81886fecfcb7","date":1376943063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a6a338194ed0a2e9eef3247ffe4a535203aac09","date":1377222156,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    // nocommit: temporary disable other format tests\n    /*\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    */\n    add(avoidCodecs,\n        new TempBlockPostingsFormat(_TestUtil.nextInt(random, 1, 1000)),\n        new TempBlockTreePostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempRandomPostingsFormat(random),\n        new TempNestedPulsingPostingsFormat(),\n        new TempPulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n\n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    // nocommit: temporary disable other format tests\n    /*\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    */\n    add(avoidCodecs,\n        new TempBlockPostingsFormat(_TestUtil.nextInt(random, 1, 1000)),\n        new TempBlockTreePostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempRandomPostingsFormat(random),\n        new TempNestedPulsingPostingsFormat(),\n        new TempPulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n\n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    // nocommit: temporary disable other format tests\n    /*\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    */\n    add(avoidCodecs,\n        new TempBlockPostingsFormat(_TestUtil.nextInt(random, 1, 1000)),\n        new TempBlockTreePostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempRandomPostingsFormat(random),\n        new TempNestedPulsingPostingsFormat(),\n        new TempPulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n\n    addDocValues(avoidCodecs,\n        new Lucene42DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat(),\n        new CheapBastardDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6904bcc97d8afa27bd72ee29ac01e525e327ad4","date":1377958787,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempFSTPostingsFormat(),\n        new TempFSTOrdPostingsFormat(),\n        new TempFSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new TempFSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    // nocommit: temporary disable other format tests\n    /*\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    */\n    add(avoidCodecs,\n        new TempBlockPostingsFormat(_TestUtil.nextInt(random, 1, 1000)),\n        new TempBlockTreePostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempRandomPostingsFormat(random),\n        new TempNestedPulsingPostingsFormat(),\n        new TempPulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n\n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56df73d43b6fc340f5332322862382c7e30f4368","date":1378304988,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new TempFSTPostingsFormat(),\n        new TempFSTOrdPostingsFormat(),\n        new TempFSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new TempFSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f948dd442d23baa6cbb28daf77c8db78b351329","date":1378742876,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91d86ebcdb45ce6a1b2584e2603f76db47523d0a","date":1396466913,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockSepPostingsFormat(),\n        new MockFixedIntBlockPostingsFormat(TestUtil.nextInt(random, 1, 2000)),\n        new MockVariableIntBlockPostingsFormat( TestUtil.nextInt(random, 1, 127)),\n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8106bc60c7452250f84c65cdb43ab6b1d8eb1534","date":1401906364,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene45DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":["11a746437bc5c0a0b3df0337ed249c387c812871"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ae889c32f4f301251f60804d7082a520e0594c6","date":1402924441,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new DiskDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"282412d91b33b1a7f2efd2610399fe03045d7d2c","date":1403134999,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ce5e7f280a7b3f0f96f2623d9f0ce70f742b793","date":1408030244,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene410DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene49DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbaae1c00d39df2c872bbe043af26d02d3818313","date":1409657064,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene410DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new FSTPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new FSTOrdPulsing41PostingsFormat(1 + random.nextInt(20)),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        // add pulsing again with (usually) different parameters\n        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new NestedPulsingPostingsFormat(),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene410DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e49088db00ea6cb232fbde9c8c646c721d4d049f","date":1411433559,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new Ords41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucene41Postings(),                \n        new MockRandomPostingsFormat(random),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        new Lucene410DocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99eb4a732d1a908f4636ace52928876136bf1896","date":1413829552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new Ords41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new Ords41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new Lucene41WithOrds(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new Lucene41VarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cbd49d01e70938f9b96aab93ccf87d92ef5e807","date":1417114695,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        new SimpleTextPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new MemoryDocValuesFormat(),\n        new SimpleTextDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a805e30270d7d1412d49b047fe16cc92b127dcce","date":1456795791,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24df944aceb57e67b2594b585cf004783054b5b2","date":1458934816,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fa276a5c7dfd1abf1616f5db0be689202f5bf50","date":1461491921,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 4.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71488d7f5786ae87541276121ecb69705a11a295","date":1465498138,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10005c6013abbd1102f2463cf95604d4c8774c99","date":1469460814,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0567940defa1ea6eb8a039d9d36e3682063f8a4","date":1469815320,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        random.nextInt(10) == 0 ? new SimpleTextPostingsFormat() : TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        random.nextInt(10) == 0 ? new SimpleTextDocValuesFormat() : TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f89e8a6aac05753cde4c83d62a74356098200d","date":1525768331,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat(),\n        new MemoryPostingsFormat(true, random.nextFloat()),\n        new MemoryPostingsFormat(false, random.nextFloat()));\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        new MemoryDocValuesFormat(),\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938935e3efe6aaecb925448d7f992783247366de","date":1554389977,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock,\n            RandomPicks.randomFrom(random, Lucene50PostingsFormat.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68ba24d6f9380e2463dbe5130d27502647f64904","date":1554881362,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock,\n            RandomPicks.randomFrom(random, Lucene50PostingsFormat.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f18fb78980c55a781fd9fdc505634171059b1d","date":1567674462,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n        new DirectDocValuesFormat(), // maybe not a great idea...\n        TestUtil.getDefaultDocValuesFormat(),\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb77022ef17ff655c519a3f6ecd393747ac88bcf","date":1578579386,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06ab276a5660cb79daae8c5ede063531c700a03a","date":1578587874,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08a5168e06e037794c0aba7f94f76ff3c09704d2","date":1579264785,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new FSTOrdPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomCodec#RandomCodec(Random,Set[String]).mjava","sourceNew":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new FSTPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","sourceOld":"  public RandomCodec(Random random, Set<String> avoidCodecs) {\n    this.perFieldSeed = random.nextInt();\n    this.avoidCodecs = avoidCodecs;\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    int lowFreqCutoff = TestUtil.nextInt(random, 2, 100);\n\n    maxPointsInLeafNode = TestUtil.nextInt(random, 16, 2048);\n    maxMBSortInHeap = 5.0 + (3*random.nextDouble());\n    bkdSplitRandomSeed = random.nextInt();\n\n    add(avoidCodecs,\n        TestUtil.getDefaultPostingsFormat(minItemsPerBlock, maxItemsPerBlock, RandomPicks.randomFrom(random, BlockTreeTermsReader.FSTLoadMode.values())),\n        new FSTPostingsFormat(),\n        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),\n                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),\n        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucenePostings to be constructed \n        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing \n        //with such \"wrapper\" classes?\n        new TestBloomFilteredLucenePostings(),                \n        new MockRandomPostingsFormat(random),\n        new BlockTreeOrdsPostingsFormat(minItemsPerBlock, maxItemsPerBlock),\n        new LuceneFixedGap(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapFixedInterval(TestUtil.nextInt(random, 1, 1000)),\n        new LuceneVarGapDocFreqInterval(TestUtil.nextInt(random, 1, 100), TestUtil.nextInt(random, 1, 1000)),\n        TestUtil.getDefaultPostingsFormat(),\n        new AssertingPostingsFormat());\n    \n    addDocValues(avoidCodecs,\n        TestUtil.getDefaultDocValuesFormat(),\n\n        new AssertingDocValuesFormat());\n\n    Collections.shuffle(formats, random);\n    Collections.shuffle(dvFormats, random);\n\n    // Avoid too many open files:\n    if (formats.size() > 4) {\n      formats = formats.subList(0, 4);\n    }\n    if (dvFormats.size() > 4) {\n      dvFormats = dvFormats.subList(0, 4);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"001b25b42373b22a52f399dbf072f1224632e8e6":["d6f074e73200c07d54f242d3880a8da5a35ff97b","f1175de689f57b0cb8a2604ba4a6874ae32e112d"],"56df73d43b6fc340f5332322862382c7e30f4368":["e6904bcc97d8afa27bd72ee29ac01e525e327ad4"],"af2638813028b254a88b418ebeafb541afb49653":["4cbd49d01e70938f9b96aab93ccf87d92ef5e807","a805e30270d7d1412d49b047fe16cc92b127dcce"],"e49088db00ea6cb232fbde9c8c646c721d4d049f":["fbaae1c00d39df2c872bbe043af26d02d3818313"],"9f2be786bbf3746ffcd9720e0b473f4b121c4228":["59d00acb12c9809438e21de7c24f016356973d46"],"91d86ebcdb45ce6a1b2584e2603f76db47523d0a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["24df944aceb57e67b2594b585cf004783054b5b2","2fa276a5c7dfd1abf1616f5db0be689202f5bf50"],"0274c27988a26cb0cda3a0d15b282221b1b453f0":["3da87ae09fdb5c01fbaf2cdb982c63db67843d1b"],"5a6a338194ed0a2e9eef3247ffe4a535203aac09":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","f15adb143a3097f2342f07eb0929f6ce1877ad7e"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["08a5168e06e037794c0aba7f94f76ff3c09704d2"],"75b4d037d2c8fd7d68c07be61d25c0260cf8091e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["02e8faf10211a6fbcdd8675af75977da20199190","3da87ae09fdb5c01fbaf2cdb982c63db67843d1b"],"cf8086c7e11dc41303ef1b8050bd355ddfaee76d":["400c694e5772b60e1a176127d6b1349bf6b6380e"],"24f89e8a6aac05753cde4c83d62a74356098200d":["b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"f1175de689f57b0cb8a2604ba4a6874ae32e112d":["0274c27988a26cb0cda3a0d15b282221b1b453f0"],"74f18fb78980c55a781fd9fdc505634171059b1d":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"edb74c83fff94196b864e08ca033d92823252cb7":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"0ce5e7f280a7b3f0f96f2623d9f0ce70f742b793":["282412d91b33b1a7f2efd2610399fe03045d7d2c"],"d7a738ebbf9537051521dcc7e49f69208f91e2fc":["73b923fc833f1cce9fb09dfe2ced037c9d55fd43"],"2f948dd442d23baa6cbb28daf77c8db78b351329":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","56df73d43b6fc340f5332322862382c7e30f4368"],"8f06b860886fc48ea071171354835b8aed8a94de":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"a45bec74b98f6fc05f52770cfb425739e6563960":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"2fa276a5c7dfd1abf1616f5db0be689202f5bf50":["24df944aceb57e67b2594b585cf004783054b5b2"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534","6ae889c32f4f301251f60804d7082a520e0594c6"],"f15adb143a3097f2342f07eb0929f6ce1877ad7e":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"3128e6d07d9fef0d1aa24f58b07133c9293131b2":["02e8faf10211a6fbcdd8675af75977da20199190"],"fbaae1c00d39df2c872bbe043af26d02d3818313":["0ce5e7f280a7b3f0f96f2623d9f0ce70f742b793"],"c7492bcb52be51e55d596134b95b2e53cc4ffb91":["400c694e5772b60e1a176127d6b1349bf6b6380e","6616b1fd222bb5a60f7f7856ace312252bc97890"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["c7492bcb52be51e55d596134b95b2e53cc4ffb91","9f2be786bbf3746ffcd9720e0b473f4b121c4228"],"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e":["8f06b860886fc48ea071171354835b8aed8a94de"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["edb74c83fff94196b864e08ca033d92823252cb7","3128e6d07d9fef0d1aa24f58b07133c9293131b2"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","0274c27988a26cb0cda3a0d15b282221b1b453f0"],"e6904bcc97d8afa27bd72ee29ac01e525e327ad4":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"06ab276a5660cb79daae8c5ede063531c700a03a":["cb77022ef17ff655c519a3f6ecd393747ac88bcf"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["68ba24d6f9380e2463dbe5130d27502647f64904"],"24df944aceb57e67b2594b585cf004783054b5b2":["af2638813028b254a88b418ebeafb541afb49653"],"cb77022ef17ff655c519a3f6ecd393747ac88bcf":["74f18fb78980c55a781fd9fdc505634171059b1d"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["11a746437bc5c0a0b3df0337ed249c387c812871"],"10005c6013abbd1102f2463cf95604d4c8774c99":["71488d7f5786ae87541276121ecb69705a11a295"],"73b923fc833f1cce9fb09dfe2ced037c9d55fd43":["c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"282412d91b33b1a7f2efd2610399fe03045d7d2c":["6ae889c32f4f301251f60804d7082a520e0594c6"],"11a746437bc5c0a0b3df0337ed249c387c812871":["a45bec74b98f6fc05f52770cfb425739e6563960"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["d7a738ebbf9537051521dcc7e49f69208f91e2fc"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["75b4d037d2c8fd7d68c07be61d25c0260cf8091e"],"68ba24d6f9380e2463dbe5130d27502647f64904":["938935e3efe6aaecb925448d7f992783247366de"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["3128e6d07d9fef0d1aa24f58b07133c9293131b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"400c694e5772b60e1a176127d6b1349bf6b6380e":["f1175de689f57b0cb8a2604ba4a6874ae32e112d"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3da87ae09fdb5c01fbaf2cdb982c63db67843d1b"],"3da87ae09fdb5c01fbaf2cdb982c63db67843d1b":["172cf08877d0e6738a51edd238c4dc5ffc088345"],"59d00acb12c9809438e21de7c24f016356973d46":["3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e"],"5eb2511ababf862ea11e10761c70ee560cd84510":["6613659748fe4411a7dcf85266e55db1f95f7315","91d86ebcdb45ce6a1b2584e2603f76db47523d0a"],"6616b1fd222bb5a60f7f7856ace312252bc97890":["cf8086c7e11dc41303ef1b8050bd355ddfaee76d"],"99eb4a732d1a908f4636ace52928876136bf1896":["e49088db00ea6cb232fbde9c8c646c721d4d049f"],"6613659748fe4411a7dcf85266e55db1f95f7315":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["5a6a338194ed0a2e9eef3247ffe4a535203aac09","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"938935e3efe6aaecb925448d7f992783247366de":["24f89e8a6aac05753cde4c83d62a74356098200d"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["400c694e5772b60e1a176127d6b1349bf6b6380e","c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"71488d7f5786ae87541276121ecb69705a11a295":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"02e8faf10211a6fbcdd8675af75977da20199190":["edb74c83fff94196b864e08ca033d92823252cb7"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a45bec74b98f6fc05f52770cfb425739e6563960","e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","0274c27988a26cb0cda3a0d15b282221b1b453f0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"a805e30270d7d1412d49b047fe16cc92b127dcce":["4cbd49d01e70938f9b96aab93ccf87d92ef5e807"],"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["91d86ebcdb45ce6a1b2584e2603f76db47523d0a"],"08a5168e06e037794c0aba7f94f76ff3c09704d2":["06ab276a5660cb79daae8c5ede063531c700a03a"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["e49088db00ea6cb232fbde9c8c646c721d4d049f","99eb4a732d1a908f4636ace52928876136bf1896"],"4cbd49d01e70938f9b96aab93ccf87d92ef5e807":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"6ae889c32f4f301251f60804d7082a520e0594c6":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["71488d7f5786ae87541276121ecb69705a11a295","10005c6013abbd1102f2463cf95604d4c8774c99"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d08973aa47f2cf98a588293a53af4e948952ccfb","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"]},"commit2Childs":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["24f89e8a6aac05753cde4c83d62a74356098200d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"001b25b42373b22a52f399dbf072f1224632e8e6":[],"56df73d43b6fc340f5332322862382c7e30f4368":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"af2638813028b254a88b418ebeafb541afb49653":["24df944aceb57e67b2594b585cf004783054b5b2"],"e49088db00ea6cb232fbde9c8c646c721d4d049f":["99eb4a732d1a908f4636ace52928876136bf1896","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"9f2be786bbf3746ffcd9720e0b473f4b121c4228":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"91d86ebcdb45ce6a1b2584e2603f76db47523d0a":["5eb2511ababf862ea11e10761c70ee560cd84510","8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["71488d7f5786ae87541276121ecb69705a11a295","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0274c27988a26cb0cda3a0d15b282221b1b453f0":["f1175de689f57b0cb8a2604ba4a6874ae32e112d","d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab"],"5a6a338194ed0a2e9eef3247ffe4a535203aac09":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["a45bec74b98f6fc05f52770cfb425739e6563960","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"75b4d037d2c8fd7d68c07be61d25c0260cf8091e":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cf8086c7e11dc41303ef1b8050bd355ddfaee76d":["6616b1fd222bb5a60f7f7856ace312252bc97890"],"24f89e8a6aac05753cde4c83d62a74356098200d":["938935e3efe6aaecb925448d7f992783247366de"],"f1175de689f57b0cb8a2604ba4a6874ae32e112d":["001b25b42373b22a52f399dbf072f1224632e8e6","400c694e5772b60e1a176127d6b1349bf6b6380e"],"74f18fb78980c55a781fd9fdc505634171059b1d":["cb77022ef17ff655c519a3f6ecd393747ac88bcf"],"edb74c83fff94196b864e08ca033d92823252cb7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","02e8faf10211a6fbcdd8675af75977da20199190"],"0ce5e7f280a7b3f0f96f2623d9f0ce70f742b793":["fbaae1c00d39df2c872bbe043af26d02d3818313"],"d7a738ebbf9537051521dcc7e49f69208f91e2fc":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"2f948dd442d23baa6cbb28daf77c8db78b351329":["6613659748fe4411a7dcf85266e55db1f95f7315"],"8f06b860886fc48ea071171354835b8aed8a94de":["3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e"],"a45bec74b98f6fc05f52770cfb425739e6563960":["11a746437bc5c0a0b3df0337ed249c387c812871","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"2fa276a5c7dfd1abf1616f5db0be689202f5bf50":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"f15adb143a3097f2342f07eb0929f6ce1877ad7e":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"3128e6d07d9fef0d1aa24f58b07133c9293131b2":["fe33227f6805edab2036cbb80645cc4e2d1fa424","172cf08877d0e6738a51edd238c4dc5ffc088345"],"fbaae1c00d39df2c872bbe043af26d02d3818313":["e49088db00ea6cb232fbde9c8c646c721d4d049f"],"c7492bcb52be51e55d596134b95b2e53cc4ffb91":["d4d69c535930b5cce125cff868d40f6373dc27d4","73b923fc833f1cce9fb09dfe2ced037c9d55fd43","db4fdbf3d262768eabc027cd8321edca0cd11fa8"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ddbb72a33557d2b5bc22ee95daf3281c43560502","f15adb143a3097f2342f07eb0929f6ce1877ad7e"],"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e":["59d00acb12c9809438e21de7c24f016356973d46"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["001b25b42373b22a52f399dbf072f1224632e8e6"],"e6904bcc97d8afa27bd72ee29ac01e525e327ad4":["56df73d43b6fc340f5332322862382c7e30f4368"],"06ab276a5660cb79daae8c5ede063531c700a03a":["08a5168e06e037794c0aba7f94f76ff3c09704d2"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["74f18fb78980c55a781fd9fdc505634171059b1d"],"24df944aceb57e67b2594b585cf004783054b5b2":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","2fa276a5c7dfd1abf1616f5db0be689202f5bf50"],"cb77022ef17ff655c519a3f6ecd393747ac88bcf":["06ab276a5660cb79daae8c5ede063531c700a03a"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"73b923fc833f1cce9fb09dfe2ced037c9d55fd43":["d7a738ebbf9537051521dcc7e49f69208f91e2fc"],"282412d91b33b1a7f2efd2610399fe03045d7d2c":["0ce5e7f280a7b3f0f96f2623d9f0ce70f742b793"],"11a746437bc5c0a0b3df0337ed249c387c812871":["e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["8f06b860886fc48ea071171354835b8aed8a94de"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"68ba24d6f9380e2463dbe5130d27502647f64904":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["75b4d037d2c8fd7d68c07be61d25c0260cf8091e"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["3da87ae09fdb5c01fbaf2cdb982c63db67843d1b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["5a6a338194ed0a2e9eef3247ffe4a535203aac09"],"400c694e5772b60e1a176127d6b1349bf6b6380e":["cf8086c7e11dc41303ef1b8050bd355ddfaee76d","c7492bcb52be51e55d596134b95b2e53cc4ffb91","db4fdbf3d262768eabc027cd8321edca0cd11fa8"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"3da87ae09fdb5c01fbaf2cdb982c63db67843d1b":["0274c27988a26cb0cda3a0d15b282221b1b453f0","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"59d00acb12c9809438e21de7c24f016356973d46":["9f2be786bbf3746ffcd9720e0b473f4b121c4228"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"6616b1fd222bb5a60f7f7856ace312252bc97890":["c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"99eb4a732d1a908f4636ace52928876136bf1896":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"6613659748fe4411a7dcf85266e55db1f95f7315":["91d86ebcdb45ce6a1b2584e2603f76db47523d0a","5eb2511ababf862ea11e10761c70ee560cd84510"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["e6904bcc97d8afa27bd72ee29ac01e525e327ad4"],"938935e3efe6aaecb925448d7f992783247366de":["68ba24d6f9380e2463dbe5130d27502647f64904"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":[],"02e8faf10211a6fbcdd8675af75977da20199190":["aba371508186796cc6151d8223a5b4e16d02e26e","3128e6d07d9fef0d1aa24f58b07133c9293131b2"],"71488d7f5786ae87541276121ecb69705a11a295":["10005c6013abbd1102f2463cf95604d4c8774c99","d08973aa47f2cf98a588293a53af4e948952ccfb"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["2f948dd442d23baa6cbb28daf77c8db78b351329","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a805e30270d7d1412d49b047fe16cc92b127dcce":["af2638813028b254a88b418ebeafb541afb49653"],"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["edb74c83fff94196b864e08ca033d92823252cb7"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","6ae889c32f4f301251f60804d7082a520e0594c6"],"08a5168e06e037794c0aba7f94f76ff3c09704d2":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["4cbd49d01e70938f9b96aab93ccf87d92ef5e807"],"4cbd49d01e70938f9b96aab93ccf87d92ef5e807":["af2638813028b254a88b418ebeafb541afb49653","a805e30270d7d1412d49b047fe16cc92b127dcce"],"6ae889c32f4f301251f60804d7082a520e0594c6":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","282412d91b33b1a7f2efd2610399fe03045d7d2c"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["b0567940defa1ea6eb8a039d9d36e3682063f8a4","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","c6f080a2ab37c464dd98db173f6cbf10dc74f211","5eb2511ababf862ea11e10761c70ee560cd84510","db4fdbf3d262768eabc027cd8321edca0cd11fa8","8fd5be977c105554c6a7b68afcdbc511439723ab","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}