{"path":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#assertNoExtraSegments().mjava","commits":[{"id":"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753","date":1416999434,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#assertNoExtraSegments().mjava","pathOld":"/dev/null","sourceNew":"    // Make sure we deleted all parallel indices for segments that are no longer in the main index: \n    private void assertNoExtraSegments() throws IOException {\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : SegmentInfos.readLatestCommit(indexDir)) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      // At this point (closing) the only segments in closedSegments should be the still-live ones:\n      for(SegmentIDAndGen segIDGen : closedSegments) {\n        assertTrue(liveIDs.contains(segIDGen.segID));\n      }\n\n      boolean fail = false;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(segsPath)) {\n          for (Path path : stream) {\n            SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n            if (liveIDs.contains(segIDGen.segID) == false) {\n              if (DEBUG) System.out.println(\"TEST: fail seg=\" + path.getFileName() + \" is not live but still has a parallel index\");\n              fail = true;\n            }\n          }\n        }\n      assertFalse(fail);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22989c36ff05c657df26dd3377b37c9ad35859bc","date":1424477375,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#assertNoExtraSegments().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#assertNoExtraSegments().mjava","sourceNew":"    // Make sure we deleted all parallel indices for segments that are no longer in the main index: \n    private void assertNoExtraSegments() throws IOException {\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : SegmentInfos.readLatestCommit(indexDir)) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      // At this point (closing) the only segments in closedSegments should be the still-live ones:\n      for(SegmentIDAndGen segIDGen : closedSegments) {\n        assertTrue(liveIDs.contains(segIDGen.segID));\n      }\n\n      boolean fail = false;\n      for(Path path : segSubDirs(segsPath)) {\n        SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n        if (liveIDs.contains(segIDGen.segID) == false) {\n          if (DEBUG) System.out.println(\"TEST: fail seg=\" + path.getFileName() + \" is not live but still has a parallel index\");\n          fail = true;\n        }\n      }\n      assertFalse(fail);\n    }\n\n","sourceOld":"    // Make sure we deleted all parallel indices for segments that are no longer in the main index: \n    private void assertNoExtraSegments() throws IOException {\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : SegmentInfos.readLatestCommit(indexDir)) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      // At this point (closing) the only segments in closedSegments should be the still-live ones:\n      for(SegmentIDAndGen segIDGen : closedSegments) {\n        assertTrue(liveIDs.contains(segIDGen.segID));\n      }\n\n      boolean fail = false;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(segsPath)) {\n          for (Path path : stream) {\n            SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n            if (liveIDs.contains(segIDGen.segID) == false) {\n              if (DEBUG) System.out.println(\"TEST: fail seg=\" + path.getFileName() + \" is not live but still has a parallel index\");\n              fail = true;\n            }\n          }\n        }\n      assertFalse(fail);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22989c36ff05c657df26dd3377b37c9ad35859bc":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22989c36ff05c657df26dd3377b37c9ad35859bc"]},"commit2Childs":{"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}