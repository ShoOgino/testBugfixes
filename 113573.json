{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","commits":[{"id":"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","date":1550598742,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfe04a006c42318f41df58bdd061cc1065b5f688","date":1574780842,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e34d3c0017401c7997e17f8bccf776f69616876b","date":1591946214,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new CorruptIndexException(\"invalid input type \" + t, in);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput metaIn, DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(metaIn, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (metaIn.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = metaIn.readVInt();\n      emptyBytes.copyBytes(metaIn, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = metaIn.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new CorruptIndexException(\"invalid input type \" + t, in);\n    }\n    startNode = metaIn.readVLong();\n\n    long numBytes = metaIn.readVLong();\n    this.fstStore.init(in, numBytes);\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads formats VERSION_START up to VERSION_CURRENT; we don't have\n    // back-compat promise for FSTs (they are experimental), but we are sometimes able to offer it\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new CorruptIndexException(\"invalid input type \" + t, in);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["e34d3c0017401c7997e17f8bccf776f69616876b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e34d3c0017401c7997e17f8bccf776f69616876b":["cfe04a006c42318f41df58bdd061cc1065b5f688"],"f8061ddd97f3352007d927dae445884a6f3d857b":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"],"cfe04a006c42318f41df58bdd061cc1065b5f688":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cfe04a006c42318f41df58bdd061cc1065b5f688"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"e34d3c0017401c7997e17f8bccf776f69616876b":["99f06f5dd087b1829e7b4139e4d014c786b92572"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"cfe04a006c42318f41df58bdd061cc1065b5f688":["e34d3c0017401c7997e17f8bccf776f69616876b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}