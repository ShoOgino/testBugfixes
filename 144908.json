{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","commits":[{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0a901a44015dae0c92704489092290caf37c40e","date":1456918243,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74afd3206df44c6b7fc46faaac8bf5c7a080ff23","date":1468332864,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a178ac3dec643551e66363c457a9074f55545f86","date":1496133188,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new LegacyIntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LegacyLongField(\"trieLong\", (long) id, Field.Store.NO));\n\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n\n    doc.add(new IntPoint(\"intPoint1d\", id));\n    doc.add(new IntPoint(\"intPoint2d\", id, 2*id));\n    doc.add(new FloatPoint(\"floatPoint1d\", (float) id));\n    doc.add(new FloatPoint(\"floatPoint2d\", (float) id, (float) 2*id));\n    doc.add(new LongPoint(\"longPoint1d\", id));\n    doc.add(new LongPoint(\"longPoint2d\", id, 2*id));\n    doc.add(new DoublePoint(\"doublePoint1d\", (double) id));\n    doc.add(new DoublePoint(\"doublePoint2d\", (double) id, (double) 2*id));\n    doc.add(new BinaryPoint(\"binaryPoint1d\", bytes));\n    doc.add(new BinaryPoint(\"binaryPoint2d\", bytes, bytes));\n    \n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a178ac3dec643551e66363c457a9074f55545f86":["74afd3206df44c6b7fc46faaac8bf5c7a080ff23"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["74afd3206df44c6b7fc46faaac8bf5c7a080ff23","a178ac3dec643551e66363c457a9074f55545f86"],"74afd3206df44c6b7fc46faaac8bf5c7a080ff23":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","b0a901a44015dae0c92704489092290caf37c40e"],"770342641f7b505eaa8dccdc666158bff2419109":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["74afd3206df44c6b7fc46faaac8bf5c7a080ff23","a178ac3dec643551e66363c457a9074f55545f86"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","74afd3206df44c6b7fc46faaac8bf5c7a080ff23"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cc45c615dbb82bf79d5f9550286098367874fbf"],"b0a901a44015dae0c92704489092290caf37c40e":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"a178ac3dec643551e66363c457a9074f55545f86":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"74afd3206df44c6b7fc46faaac8bf5c7a080ff23":["a178ac3dec643551e66363c457a9074f55545f86","e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cc45c615dbb82bf79d5f9550286098367874fbf","402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["74afd3206df44c6b7fc46faaac8bf5c7a080ff23","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"770342641f7b505eaa8dccdc666158bff2419109":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","b0a901a44015dae0c92704489092290caf37c40e"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b0a901a44015dae0c92704489092290caf37c40e":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["770342641f7b505eaa8dccdc666158bff2419109"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}