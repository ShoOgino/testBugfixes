{"path":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","commits":[{"id":"3ee067e27d1cce6d2d5d64280007410c2e1a38d8","date":1001438945,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Stemms the given term to an unique <tt>discriminator</tt>.\n\t *\n\t * @param word  The term that should be stemmed.\n\t * @return      Discriminator for <tt>term</tt>\n\t */\n\tprotected String stem( String term ) {\n\t\tif ( !isStemmable( term ) ) {\n\t\t\treturn term;\n\t\t}\n\t\t// Mark a possible noun.\n\t\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t\t\tuppercase = true;\n\t\t}\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\tsb = substitute( sb );\n\t\t// Nouns have only seven possible suffixes.\n\t\tif ( uppercase && sb.length() > 3 ) {\n\t\t\tif ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 3, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\t// Additional step for female plurals of professions and inhabitants.\n\t\t\tif ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\t\t\tsb.deleteCharAt( sb.length() -1 );\n\t\t\t}\n\t\t\t// Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t\t\tif ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\t\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t\t\t}\n\t\t}\n\t\t// Check the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" for all\n\t\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t\t// possible suffixes.\n\t\telse {\n\t\t\t// Strip base suffixes as long as enough characters remain.\n\t\t\tboolean doMore = true;\n\t\t\twhile ( sb.length() > 3 && doMore ) {\n\t\t\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoMore = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !uppercase ) {\n\t\t\tsb = removeParticleDenotion( sb );\n\t\t}\n\t\tsb = resubstitute( sb );\n\t\treturn sb.toString();\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b027969b494a02d6f7a03a43537cc6935afce2a","date":1008019104,"type":3,"author":"gschwarz","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"\t/**\n\t * Stemms the given term to an unique <tt>discriminator</tt>.\n\t *\n\t * @param term  The term that should be stemmed.\n\t * @return      Discriminator for <tt>term</tt>\n\t */\n\tprotected String stem( String term ) {\n\t\tif ( !isStemmable( term ) ) {\n\t\t\treturn term;\n\t\t}\n\t\t// Mark a possible noun.\n\t\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t\t\tuppercase = true;\n\t\t}\n\t\telse {\n\t\t\tuppercase = false;\n\t\t}\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\tsb = substitute( sb );\n\t\t// Nouns have only seven possible suffixes.\n\t\tif ( uppercase && sb.length() > 3 ) {\n\t\t\tif ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 3, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\t// Additional step for female plurals of professions and inhabitants.\n\t\t\tif ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\t\t\tsb.deleteCharAt( sb.length() -1 );\n\t\t\t}\n\t\t\t// Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t\t\tif ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\t\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t\t\t}\n\t\t}\n\t\t// Strip the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" from all\n\t\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t\t// possible suffixes, stripping only the characters from they are build\n\t\t// does mostly the same\n\t\telse {\n\t\t\t// Strip base suffixes as long as enough characters remain.\n\t\t\tboolean doMore = true;\n\t\t\twhile ( sb.length() > 3 && doMore ) {\n\t\t\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoMore = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb = resubstitute( sb );\n\t\tif ( !uppercase ) {\n\t\t\tsb = removeParticleDenotion( sb );\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n","sourceOld":"\t/**\n\t * Stemms the given term to an unique <tt>discriminator</tt>.\n\t *\n\t * @param word  The term that should be stemmed.\n\t * @return      Discriminator for <tt>term</tt>\n\t */\n\tprotected String stem( String term ) {\n\t\tif ( !isStemmable( term ) ) {\n\t\t\treturn term;\n\t\t}\n\t\t// Mark a possible noun.\n\t\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t\t\tuppercase = true;\n\t\t}\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\tsb = substitute( sb );\n\t\t// Nouns have only seven possible suffixes.\n\t\tif ( uppercase && sb.length() > 3 ) {\n\t\t\tif ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 3, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\t// Additional step for female plurals of professions and inhabitants.\n\t\t\tif ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\t\t\tsb.deleteCharAt( sb.length() -1 );\n\t\t\t}\n\t\t\t// Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t\t\tif ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\t\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t\t\t}\n\t\t}\n\t\t// Check the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" for all\n\t\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t\t// possible suffixes.\n\t\telse {\n\t\t\t// Strip base suffixes as long as enough characters remain.\n\t\t\tboolean doMore = true;\n\t\t\twhile ( sb.length() > 3 && doMore ) {\n\t\t\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoMore = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !uppercase ) {\n\t\t\tsb = removeParticleDenotion( sb );\n\t\t}\n\t\tsb = resubstitute( sb );\n\t\treturn sb.toString();\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc6774a9d78ca86ed9a37e4192c8b43410eb38a3","date":1013649547,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term ) {\n\tif ( !isStemmable( term ) ) {\n\t    return term;\n\t}\n\t// Mark a possible noun.\n\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t    uppercase = true;\n\t}\n\telse {\n\t    uppercase = false;\n\t}\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\tsb = substitute( sb );\n\t// Nouns have only seven possible suffixes.\n\tif ( uppercase && sb.length() > 3 ) {\n\t    if ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\tsb.delete( sb.length() - 3, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    // Additional step for female plurals of professions and inhabitants.\n\t    if ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\tsb.deleteCharAt( sb.length() -1 );\n\t    }\n\t    // Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t    if ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t    }\n\t}\n\t// Strip the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" from all\n\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t// possible suffixes, stripping only the characters from they are build\n\t// does mostly the same\n\telse {\n\t    // Strip base suffixes as long as enough characters remain.\n\t    boolean doMore = true;\n\t    while ( sb.length() > 3 && doMore ) {\n\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse {\n\t\t    doMore = false;\n\t\t}\n\t    }\n\t}\n\tsb = resubstitute( sb );\n\tif ( !uppercase ) {\n\t    sb = removeParticleDenotion( sb );\n\t}\n\treturn sb.toString();\n    }\n\n","sourceOld":"\t/**\n\t * Stemms the given term to an unique <tt>discriminator</tt>.\n\t *\n\t * @param term  The term that should be stemmed.\n\t * @return      Discriminator for <tt>term</tt>\n\t */\n\tprotected String stem( String term ) {\n\t\tif ( !isStemmable( term ) ) {\n\t\t\treturn term;\n\t\t}\n\t\t// Mark a possible noun.\n\t\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t\t\tuppercase = true;\n\t\t}\n\t\telse {\n\t\t\tuppercase = false;\n\t\t}\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\tsb = substitute( sb );\n\t\t// Nouns have only seven possible suffixes.\n\t\tif ( uppercase && sb.length() > 3 ) {\n\t\t\tif ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 3, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t}\n\t\t\t// Additional step for female plurals of professions and inhabitants.\n\t\t\tif ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\t\t\tsb.deleteCharAt( sb.length() -1 );\n\t\t\t}\n\t\t\t// Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t\t\tif ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\t\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t\t\t}\n\t\t}\n\t\t// Strip the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" from all\n\t\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t\t// possible suffixes, stripping only the characters from they are build\n\t\t// does mostly the same\n\t\telse {\n\t\t\t// Strip base suffixes as long as enough characters remain.\n\t\t\tboolean doMore = true;\n\t\t\twhile ( sb.length() > 3 && doMore ) {\n\t\t\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t\t\t\tsb.delete( sb.length() - 2, sb.length() );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t\t\t\tsb.deleteCharAt( sb.length() - 1 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoMore = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb = resubstitute( sb );\n\t\tif ( !uppercase ) {\n\t\t\tsb = removeParticleDenotion( sb );\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2cf2d6a8aa527ae2d11b26630eee5c9296d8d74e","date":1027293369,"type":3,"author":"gschwarz","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term ) {\n\t\t// Mark a possible noun.\n\t\tuppercase = Character.isUpperCase( term.charAt( 0 ) );\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\tif ( !isStemmable( term ) ) return term;\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\t// Stemming starts here...\n\t\tsubstitute( sb );\n\t\tstrip( sb );\n\t\toptimize( sb );\n\t\tresubstitute( sb );\n\t\tremoveParticleDenotion( sb );\n\t\treturn sb.toString();\n    }\n\n","sourceOld":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term ) {\n\tif ( !isStemmable( term ) ) {\n\t    return term;\n\t}\n\t// Mark a possible noun.\n\tif ( Character.isUpperCase( term.charAt( 0 ) ) ) {\n\t    uppercase = true;\n\t}\n\telse {\n\t    uppercase = false;\n\t}\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\tsb = substitute( sb );\n\t// Nouns have only seven possible suffixes.\n\tif ( uppercase && sb.length() > 3 ) {\n\t    if ( sb.substring( sb.length() - 3, sb.length() ).equals( \"ern\" ) ) {\n\t\tsb.delete( sb.length() - 3, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"en\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.substring( sb.length() - 2, sb.length() ).equals( \"es\" ) ) {\n\t\tsb.delete( sb.length() - 2, sb.length() );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    else if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\tsb.deleteCharAt( sb.length() - 1 );\n\t    }\n\t    // Additional step for female plurals of professions and inhabitants.\n\t    if ( sb.length() > 5 && sb.substring( sb.length() - 3, sb.length() ).equals( \"erin*\" ) ) {\n\t\tsb.deleteCharAt( sb.length() -1 );\n\t    }\n\t    // Additional step for irregular plural nouns like \"Matrizen -> Matrix\".\n\t    if ( sb.charAt( sb.length() - 1 ) == ( 'z' ) ) {\n\t\tsb.setCharAt( sb.length() - 1, 'x' );\n\t    }\n\t}\n\t// Strip the 7 \"base\" suffixes: \"e\", \"s\", \"n\", \"t\", \"em\", \"er\", \"nd\" from all\n\t// other terms. Adjectives, Verbs and Adverbs have a total of 52 different\n\t// possible suffixes, stripping only the characters from they are build\n\t// does mostly the same\n\telse {\n\t    // Strip base suffixes as long as enough characters remain.\n\t    boolean doMore = true;\n\t    while ( sb.length() > 3 && doMore ) {\n\t\tif ( ( sb.length() + substCount > 5 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"nd\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"er\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( ( sb.length() + substCount > 4 ) && sb.substring( sb.length() - 2, sb.length() ).equals( \"em\" ) ) {\n\t\t    sb.delete( sb.length() - 2, sb.length() );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 't' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 'n' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 's' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse if ( sb.charAt( sb.length() - 1 ) == 'e' ) {\n\t\t    sb.deleteCharAt( sb.length() - 1 );\n\t\t}\n\t\telse {\n\t\t    doMore = false;\n\t\t}\n\t    }\n\t}\n\tsb = resubstitute( sb );\n\tif ( !uppercase ) {\n\t    sb = removeParticleDenotion( sb );\n\t}\n\treturn sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1b51af49aa8e1c86a2453fc1d1b618effb6ec8e","date":1029691996,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n\t// Mark a possible noun.\n\tuppercase = Character.isUpperCase( term.charAt( 0 ) );\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\tif ( !isStemmable( term ) )\n\t    return term;\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\t// Stemming starts here...\n\tsubstitute( sb );\n\tstrip( sb );\n\toptimize( sb );\n\tresubstitute( sb );\n\tremoveParticleDenotion( sb );\n\treturn sb.toString();\n    }\n\n","sourceOld":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term ) {\n\t\t// Mark a possible noun.\n\t\tuppercase = Character.isUpperCase( term.charAt( 0 ) );\n\t\t// Use lowercase for medium stemming.\n\t\tterm = term.toLowerCase();\n\t\tif ( !isStemmable( term ) ) return term;\n\t\t// Reset the StringBuffer.\n\t\tsb.delete( 0, sb.length() );\n\t\tsb.insert( 0, term );\n\t\t// Stemming starts here...\n\t\tsubstitute( sb );\n\t\tstrip( sb );\n\t\toptimize( sb );\n\t\tresubstitute( sb );\n\t\tremoveParticleDenotion( sb );\n\t\treturn sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4230eef3a047e2a85e989e7ced62bf7fd4a9f859","date":1080661498,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\tif ( !isStemmable( term ) )\n\t    return term;\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\t// Stemming starts here...\n\tsubstitute( sb );\n\tstrip( sb );\n\toptimize( sb );\n\tresubstitute( sb );\n\tremoveParticleDenotion( sb );\n\treturn sb.toString();\n    }\n\n","sourceOld":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n\t// Mark a possible noun.\n\tuppercase = Character.isUpperCase( term.charAt( 0 ) );\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\tif ( !isStemmable( term ) )\n\t    return term;\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\t// Stemming starts here...\n\tsubstitute( sb );\n\tstrip( sb );\n\toptimize( sb );\n\tresubstitute( sb );\n\tremoveParticleDenotion( sb );\n\treturn sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d195ac4f5f0fd16249e88707973706feb1214df0","date":1080662088,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n      // Use lowercase for medium stemming.\n      term = term.toLowerCase();\n      if ( !isStemmable( term ) )\n        return term;\n      // Reset the StringBuffer.\n      sb.delete( 0, sb.length() );\n      sb.insert( 0, term );\n      // Stemming starts here...\n      substitute( sb );\n      strip( sb );\n      optimize( sb );\n      resubstitute( sb );\n      removeParticleDenotion( sb );\n      return sb.toString();\n    }\n\n","sourceOld":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n\t// Use lowercase for medium stemming.\n\tterm = term.toLowerCase();\n\tif ( !isStemmable( term ) )\n\t    return term;\n\t// Reset the StringBuffer.\n\tsb.delete( 0, sb.length() );\n\tsb.insert( 0, term );\n\t// Stemming starts here...\n\tsubstitute( sb );\n\tstrip( sb );\n\toptimize( sb );\n\tresubstitute( sb );\n\tremoveParticleDenotion( sb );\n\treturn sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb502dc71e908fb2c30e64b73e1f7e7b6238f5a2","date":1092688309,"type":4,"author":"Daniel Naber","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/de/GermanStemmer#stem(String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Stemms the given term to an unique <tt>discriminator</tt>.\n     *\n     * @param term  The term that should be stemmed.\n     * @return      Discriminator for <tt>term</tt>\n     */\n    protected String stem( String term )\n    {\n      // Use lowercase for medium stemming.\n      term = term.toLowerCase();\n      if ( !isStemmable( term ) )\n        return term;\n      // Reset the StringBuffer.\n      sb.delete( 0, sb.length() );\n      sb.insert( 0, term );\n      // Stemming starts here...\n      substitute( sb );\n      strip( sb );\n      optimize( sb );\n      resubstitute( sb );\n      removeParticleDenotion( sb );\n      return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3ee067e27d1cce6d2d5d64280007410c2e1a38d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eb502dc71e908fb2c30e64b73e1f7e7b6238f5a2":["d195ac4f5f0fd16249e88707973706feb1214df0"],"4230eef3a047e2a85e989e7ced62bf7fd4a9f859":["f1b51af49aa8e1c86a2453fc1d1b618effb6ec8e"],"d195ac4f5f0fd16249e88707973706feb1214df0":["4230eef3a047e2a85e989e7ced62bf7fd4a9f859"],"f1b51af49aa8e1c86a2453fc1d1b618effb6ec8e":["2cf2d6a8aa527ae2d11b26630eee5c9296d8d74e"],"bc6774a9d78ca86ed9a37e4192c8b43410eb38a3":["9b027969b494a02d6f7a03a43537cc6935afce2a"],"9b027969b494a02d6f7a03a43537cc6935afce2a":["3ee067e27d1cce6d2d5d64280007410c2e1a38d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2cf2d6a8aa527ae2d11b26630eee5c9296d8d74e":["bc6774a9d78ca86ed9a37e4192c8b43410eb38a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eb502dc71e908fb2c30e64b73e1f7e7b6238f5a2"]},"commit2Childs":{"3ee067e27d1cce6d2d5d64280007410c2e1a38d8":["9b027969b494a02d6f7a03a43537cc6935afce2a"],"eb502dc71e908fb2c30e64b73e1f7e7b6238f5a2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4230eef3a047e2a85e989e7ced62bf7fd4a9f859":["d195ac4f5f0fd16249e88707973706feb1214df0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ee067e27d1cce6d2d5d64280007410c2e1a38d8"],"d195ac4f5f0fd16249e88707973706feb1214df0":["eb502dc71e908fb2c30e64b73e1f7e7b6238f5a2"],"f1b51af49aa8e1c86a2453fc1d1b618effb6ec8e":["4230eef3a047e2a85e989e7ced62bf7fd4a9f859"],"bc6774a9d78ca86ed9a37e4192c8b43410eb38a3":["2cf2d6a8aa527ae2d11b26630eee5c9296d8d74e"],"9b027969b494a02d6f7a03a43537cc6935afce2a":["bc6774a9d78ca86ed9a37e4192c8b43410eb38a3"],"2cf2d6a8aa527ae2d11b26630eee5c9296d8d74e":["f1b51af49aa8e1c86a2453fc1d1b618effb6ec8e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}