{"path":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"d7c1e9928d771e4e47fc17bc23aa91a2454b133a","date":1199894278,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException, ParseException, InstantiationException, IllegalAccessException \n  {\n    ResponseBuilder builder = new ResponseBuilder();\n    req.getContext().put( RESPONSE_BUILDER_CONTEXT_KEY, builder );\n    \n    if( components == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"SearchHandler not initialized properly.  No components registered.\" );\n    }\n    \n    // The semantics of debugging vs not debugging are distinct enough \n    // to justify two control loops\n    if( !req.getParams().getBool( CommonParams.DEBUG_QUERY, false ) ) {\n      // Prepare\n      for( SearchComponent c : components ) {\n        c.prepare( req, rsp );\n      }\n  \n      // Process\n      for( SearchComponent c : components ) {\n        c.process( req, rsp );\n      }\n    }\n    else {\n      builder.setDebug( true );\n      RTimer timer = new RTimer();\n      \n      // Prepare\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.prepare( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n  \n      // Process\n      subt = timer.sub( \"process\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.process( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n      timer.stop();\n      \n      // add the timing info\n      builder.addDebugInfo( \"timing\", timer.asNamedList() );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException, ParseException, InstantiationException, IllegalAccessException \n  {\n    ResponseBuilder builder = new ResponseBuilder();\n    req.getContext().put( RESPONSE_BUILDER_CONTEXT_KEY, builder );\n    \n    if( components == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"SearchHandler not initialized properly.  No components registered.\" );\n    }\n    \n    // The semantics of debugging vs not debugging are distinct enough \n    // to justify two control loops\n    if( !req.getParams().getBool( CommonParams.DEBUG_QUERY, false ) ) {\n      // Prepare\n      for( SearchComponent c : components ) {\n        c.prepare( req, rsp );\n      }\n  \n      // Process\n      for( SearchComponent c : components ) {\n        c.process( req, rsp );\n      }\n    }\n    else {\n      builder.setDebug( true );\n      RTimer timer = new RTimer();\n      \n      // Prepare\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.prepare( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n  \n      // Process\n      subt = timer.sub( \"process\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.process( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n      timer.stop();\n      \n      // add the timing info\n      builder.addDebugInfo( \"timing\", timer.asNamedList() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException, ParseException, InstantiationException, IllegalAccessException \n  {\n    ResponseBuilder builder = new ResponseBuilder();\n    req.getContext().put( RESPONSE_BUILDER_CONTEXT_KEY, builder );\n    \n    if( components == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"SearchHandler not initialized properly.  No components registered.\" );\n    }\n    \n    // The semantics of debugging vs not debugging are distinct enough \n    // to justify two control loops\n    if( !req.getParams().getBool( CommonParams.DEBUG_QUERY, false ) ) {\n      // Prepare\n      for( SearchComponent c : components ) {\n        c.prepare( req, rsp );\n      }\n  \n      // Process\n      for( SearchComponent c : components ) {\n        c.process( req, rsp );\n      }\n    }\n    else {\n      builder.setDebug( true );\n      RTimer timer = new RTimer();\n      \n      // Prepare\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.prepare( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n  \n      // Process\n      subt = timer.sub( \"process\" );\n      for( SearchComponent c : components ) {\n        builder.setTimer( subt.sub( c.getName() ) );\n        c.process( req, rsp );\n        builder.getTimer().stop();\n      }\n      subt.stop();\n      timer.stop();\n      \n      // add the timing info\n      builder.addDebugInfo( \"timing\", timer.asNamedList() );\n    }\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"18da05e3b71bc8fa9a63493f568c3a3cf8b67a93","date":1209660047,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ff676ea3919c34f30df120b9fa469cd439203ec","date":1211576148,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9bc4ab67b0522d4299b21b88dd188b4b3b39c42b","date":1213223646,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = sreq.params;\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6c6e4e06160d2ad231072e8743988a623ab14c9","date":1213500516,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(\"shards\");      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(\"echoParams\");\n              params.set(\"isShard\", true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(\"shards.qt\");\n              if (shardHandler == null) {\n                params.remove(\"qt\");\n              } else {\n                params.set(\"qt\", shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e69935771ba8cb2303a86bf8a42be7861eaf1da","date":1216694040,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.exception != null) {\n              comm.cancelAll();\n              if (srsp.exception instanceof SolrException) {\n                throw (SolrException)srsp.exception;\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.exception);\n              }\n            }\n\n            rb.finished.add(srsp.req);\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.req);\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c79e84313497146a1eb431df8994acaa6c8516d1","date":1218002449,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    rsp.setHttpCaching(true);\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c326251ad5954dfc310c6f7a9888cd4757fdb99","date":1218817264,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.severe(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.severe(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5ff676ea3919c34f30df120b9fa469cd439203ec":["18da05e3b71bc8fa9a63493f568c3a3cf8b67a93"],"c79e84313497146a1eb431df8994acaa6c8516d1":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"a6c6e4e06160d2ad231072e8743988a623ab14c9":["9bc4ab67b0522d4299b21b88dd188b4b3b39c42b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["1c326251ad5954dfc310c6f7a9888cd4757fdb99"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["d7c1e9928d771e4e47fc17bc23aa91a2454b133a"],"1c326251ad5954dfc310c6f7a9888cd4757fdb99":["c79e84313497146a1eb431df8994acaa6c8516d1"],"18da05e3b71bc8fa9a63493f568c3a3cf8b67a93":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"d7c1e9928d771e4e47fc17bc23aa91a2454b133a":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"9bc4ab67b0522d4299b21b88dd188b4b3b39c42b":["5ff676ea3919c34f30df120b9fa469cd439203ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["a6c6e4e06160d2ad231072e8743988a623ab14c9"],"ad94625fb8d088209f46650c8097196fec67f00c":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5ff676ea3919c34f30df120b9fa469cd439203ec":["9bc4ab67b0522d4299b21b88dd188b4b3b39c42b"],"c79e84313497146a1eb431df8994acaa6c8516d1":["1c326251ad5954dfc310c6f7a9888cd4757fdb99"],"a6c6e4e06160d2ad231072e8743988a623ab14c9":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d7c1e9928d771e4e47fc17bc23aa91a2454b133a"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["ad94625fb8d088209f46650c8097196fec67f00c"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["18da05e3b71bc8fa9a63493f568c3a3cf8b67a93"],"18da05e3b71bc8fa9a63493f568c3a3cf8b67a93":["5ff676ea3919c34f30df120b9fa469cd439203ec"],"1c326251ad5954dfc310c6f7a9888cd4757fdb99":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"d7c1e9928d771e4e47fc17bc23aa91a2454b133a":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"9bc4ab67b0522d4299b21b88dd188b4b3b39c42b":["a6c6e4e06160d2ad231072e8743988a623ab14c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["c79e84313497146a1eb431df8994acaa6c8516d1"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}