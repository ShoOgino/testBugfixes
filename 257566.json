{"path":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E]).mjava","commits":[{"id":"52754a40a1550056d5637c8992b4076b5ed77328","date":1151345693,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E]).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * @param <E> \n     * @param componentClass\n     * @throws RegistryException\n     */\n    @SuppressWarnings(\"unchecked\")\n    public  <E extends ServerComponent> void  registerComponent(final Class<E> componentClass)\n            throws RegistryException {\n        \n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n  \n        if(!checkImplementsServerComponent(componentClass))\n            throw new RegistryException(\"can not register component. the given class does not implement ServerComponent interface -- \"+componentClass.getName());\n        try {\n\n            Component annotation =  componentClass.getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n            \n            this.componentMap.put(type, bean);\n\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"303ca293666286b4ae2b0b4dbf10d3bf60ed727c","date":1153866181,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E]).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invokation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!checkSuperType(componentClass, ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOGGER.isInfoEnabled())\n                    LOGGER.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (checkSuperType(componentClass, ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * @param <E> \n     * @param componentClass\n     * @throws RegistryException\n     */\n    @SuppressWarnings(\"unchecked\")\n    public  <E extends ServerComponent> void  registerComponent(final Class<E> componentClass)\n            throws RegistryException {\n        \n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n  \n        if(!checkImplementsServerComponent(componentClass))\n            throw new RegistryException(\"can not register component. the given class does not implement ServerComponent interface -- \"+componentClass.getName());\n        try {\n\n            Component annotation =  componentClass.getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n            \n            this.componentMap.put(type, bean);\n\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["52754a40a1550056d5637c8992b4076b5ed77328"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"52754a40a1550056d5637c8992b4076b5ed77328":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["52754a40a1550056d5637c8992b4076b5ed77328"],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"52754a40a1550056d5637c8992b4076b5ed77328":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}