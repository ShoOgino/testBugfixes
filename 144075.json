{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestDimensionalQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    if (Math.abs(rect.minLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.minLon-pointLon) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLon-pointLon) < POLY_TOLERANCE) {\n      // The poly check quantizes slightly differently, so we allow for boundary cases to disagree\n      return null;\n    } else {\n      return rectContainsPoint(rect, pointLat, pointLon);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    if (Math.abs(rect.minLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.minLon-pointLon) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLon-pointLon) < POLY_TOLERANCE) {\n      // The poly check quantizes slightly differently, so we allow for boundary cases to disagree\n      return null;\n    } else {\n      return rectContainsPoint(rect, pointLat, pointLon);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04995b00da1e08edb88b14c5a9789d741de5c51d","date":1453863716,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    return rectContainsPoint(rect, pointLat, pointLon);\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    if (Math.abs(rect.minLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.minLon-pointLon) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLon-pointLon) < POLY_TOLERANCE) {\n      // The poly check quantizes slightly differently, so we allow for boundary cases to disagree\n      return null;\n    } else {\n      return rectContainsPoint(rect, pointLat, pointLon);\n    }\n  }\n\n","bugFix":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    return rectContainsPoint(rect, pointLat, pointLon);\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    if (Math.abs(rect.minLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLat-pointLat) < POLY_TOLERANCE ||\n        Math.abs(rect.minLon-pointLon) < POLY_TOLERANCE ||\n        Math.abs(rect.maxLon-pointLon) < POLY_TOLERANCE) {\n      // The poly check quantizes slightly differently, so we allow for boundary cases to disagree\n      return null;\n    } else {\n      return rectContainsPoint(rect, pointLat, pointLon);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2331aada47d7da50e6835b59445dadc1bd456c39","date":1456778709,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    return rectContainsPoint(rect, pointLat, pointLon);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    return rectContainsPoint(rect, pointLat, pointLon);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"568cf24035bbe4e7fe2891439e8c9f1abc688b2c","date":1458612112,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    \n    // note: logic must be slightly different than rectContainsPoint, to satisfy\n    // insideness for cases exactly on boundaries.\n    \n    assert Double.isNaN(pointLat) == false;\n    assert rect.crossesDateline() == false;\n    double y[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };\n    double x[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };\n\n    // TODO: separately test this method is 100% correct, here treat it like a black box (like haversin)\n    return GeoRelationUtils.pointInPolygon(x, y, pointLat, pointLon);\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n\n    assert Double.isNaN(pointLat) == false;\n\n    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test\n    // still fails if we remove this evil \"return null\":\n    \n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    \n    // note: logic must be slightly different than rectContainsPoint, to satisfy\n    // insideness for cases exactly on boundaries.\n    \n    assert Double.isNaN(pointLat) == false;\n    assert rect.crossesDateline() == false;\n    double polyLats[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };\n    double polyLons[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };\n\n    // TODO: separately test this method is 100% correct, here treat it like a black box (like haversin)\n    return GeoRelationUtils.pointInPolygon(polyLats, polyLons, pointLat, pointLon);\n  }\n\n","sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    \n    // note: logic must be slightly different than rectContainsPoint, to satisfy\n    // insideness for cases exactly on boundaries.\n    \n    assert Double.isNaN(pointLat) == false;\n    assert rect.crossesDateline() == false;\n    double y[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };\n    double x[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };\n\n    // TODO: separately test this method is 100% correct, here treat it like a black box (like haversin)\n    return GeoRelationUtils.pointInPolygon(x, y, pointLat, pointLon);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3","date":1458680048,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#polyRectContainsPoint(GeoRect,double,double).mjava","sourceNew":null,"sourceOld":"  @Override\n  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    // TODO write better random polygon tests\n    \n    // note: logic must be slightly different than rectContainsPoint, to satisfy\n    // insideness for cases exactly on boundaries.\n    \n    assert Double.isNaN(pointLat) == false;\n    assert rect.crossesDateline() == false;\n    double polyLats[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };\n    double polyLons[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };\n\n    // TODO: separately test this method is 100% correct, here treat it like a black box (like haversin)\n    return GeoRelationUtils.pointInPolygon(polyLats, polyLons, pointLat, pointLon);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["04995b00da1e08edb88b14c5a9789d741de5c51d","2331aada47d7da50e6835b59445dadc1bd456c39"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["568cf24035bbe4e7fe2891439e8c9f1abc688b2c"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"568cf24035bbe4e7fe2891439e8c9f1abc688b2c":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["2331aada47d7da50e6835b59445dadc1bd456c39"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","04995b00da1e08edb88b14c5a9789d741de5c51d"],"2331aada47d7da50e6835b59445dadc1bd456c39":["04995b00da1e08edb88b14c5a9789d741de5c51d"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","04995b00da1e08edb88b14c5a9789d741de5c51d"],"568cf24035bbe4e7fe2891439e8c9f1abc688b2c":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"94ee361295fb38310ac4d53cb4773d1622423d68":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"2331aada47d7da50e6835b59445dadc1bd456c39":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["568cf24035bbe4e7fe2891439e8c9f1abc688b2c"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["af2638813028b254a88b418ebeafb541afb49653","1e6acbaae7af722f17204ceccf0f7db5753eccf3","2331aada47d7da50e6835b59445dadc1bd456c39"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}