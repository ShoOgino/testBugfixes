{"path":"solr/core/src/java/org/apache/solr/util/SpatialUtils#parsePoint(String,SpatialContext).mjava","commits":[{"id":"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003","date":1390592414,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SpatialUtils#parsePoint(String,SpatialContext).mjava","pathOld":"/dev/null","sourceNew":"  /** Parses either \"lat, lon\" (spaces optional on either comma side) or \"x y\" style formats. Spaces can be basically\n   * anywhere.  And not any whitespace, just the space char.\n   *\n   * @param str Non-null; may have leading or trailing spaces\n   * @param ctx Non-null\n   * @return Non-null\n   * @throws InvalidShapeException If for any reason there was a problem parsing the string or creating the point.\n   */\n  public static Point parsePoint(String str, SpatialContext ctx) throws InvalidShapeException {\n    //note we don't do generic whitespace, just a literal space char detection\n    //TODO: decide on if we should pick one format decided by ctx.isGeo()\n    //          Perhaps 5x use isGeo; 4x use either?\n    try {\n      double x, y;\n      str = str.trim();//TODO use findIndexNotSpace instead?\n      int commaIdx = str.indexOf(',');\n      if (commaIdx == -1) {\n        //  \"x y\" format\n        int spaceIdx = str.indexOf(' ');\n        if (spaceIdx == -1)\n          throw new InvalidShapeException(\"Point must be in 'lat, lon' or 'x y' format: \" + str);\n        int middleEndIdx = findIndexNotSpace(str, spaceIdx + 1, +1);\n        x = Double.parseDouble(str.substring(0, spaceIdx));\n        y = Double.parseDouble(str.substring(middleEndIdx));\n      } else {\n        // \"lat, lon\" format\n        int middleStartIdx = findIndexNotSpace(str, commaIdx - 1, -1);\n        int middleEndIdx = findIndexNotSpace(str, commaIdx + 1, +1);\n        y = Double.parseDouble(str.substring(0, middleStartIdx + 1));\n        x = Double.parseDouble(str.substring(middleEndIdx));\n      }\n\n      x = ctx.normX(x);//by default norm* methods do nothing but perhaps it's been customized\n      y = ctx.normY(y);\n      return ctx.makePoint(x, y);//will verify x & y fit in boundary\n    } catch (InvalidShapeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new InvalidShapeException(e.toString(), e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59d82b0be40ecfcc2c94c776b324e0903a62b844","date":1423535462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SpatialUtils#parsePoint(String,SpatialContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SpatialUtils#parsePoint(String,SpatialContext).mjava","sourceNew":"  /** Parses either \"lat, lon\" (spaces optional on either comma side) or \"x y\" style formats. Spaces can be basically\n   * anywhere.  And not any whitespace, just the space char.\n   *\n   * @param str Non-null; may have leading or trailing spaces\n   * @param ctx Non-null\n   * @return Non-null\n   * @throws InvalidShapeException If for any reason there was a problem parsing the string or creating the point.\n   */\n  public static Point parsePoint(String str, SpatialContext ctx) throws InvalidShapeException {\n    //note we don't do generic whitespace, just a literal space char detection\n    try {\n      double x, y;\n      str = str.trim();//TODO use findIndexNotSpace instead?\n      int commaIdx = str.indexOf(',');\n      if (commaIdx == -1) {\n        //  \"x y\" format\n        int spaceIdx = str.indexOf(' ');\n        if (spaceIdx == -1)\n          throw new InvalidShapeException(\"Point must be in 'lat, lon' or 'x y' format: \" + str);\n        int middleEndIdx = findIndexNotSpace(str, spaceIdx + 1, +1);\n        x = Double.parseDouble(str.substring(0, spaceIdx));\n        y = Double.parseDouble(str.substring(middleEndIdx));\n      } else {\n        // \"lat, lon\" format\n        int middleStartIdx = findIndexNotSpace(str, commaIdx - 1, -1);\n        int middleEndIdx = findIndexNotSpace(str, commaIdx + 1, +1);\n        y = Double.parseDouble(str.substring(0, middleStartIdx + 1));\n        x = Double.parseDouble(str.substring(middleEndIdx));\n      }\n\n      x = ctx.normX(x);//by default norm* methods do nothing but perhaps it's been customized\n      y = ctx.normY(y);\n      return ctx.makePoint(x, y);//will verify x & y fit in boundary\n    } catch (InvalidShapeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new InvalidShapeException(e.toString(), e);\n    }\n  }\n\n","sourceOld":"  /** Parses either \"lat, lon\" (spaces optional on either comma side) or \"x y\" style formats. Spaces can be basically\n   * anywhere.  And not any whitespace, just the space char.\n   *\n   * @param str Non-null; may have leading or trailing spaces\n   * @param ctx Non-null\n   * @return Non-null\n   * @throws InvalidShapeException If for any reason there was a problem parsing the string or creating the point.\n   */\n  public static Point parsePoint(String str, SpatialContext ctx) throws InvalidShapeException {\n    //note we don't do generic whitespace, just a literal space char detection\n    //TODO: decide on if we should pick one format decided by ctx.isGeo()\n    //          Perhaps 5x use isGeo; 4x use either?\n    try {\n      double x, y;\n      str = str.trim();//TODO use findIndexNotSpace instead?\n      int commaIdx = str.indexOf(',');\n      if (commaIdx == -1) {\n        //  \"x y\" format\n        int spaceIdx = str.indexOf(' ');\n        if (spaceIdx == -1)\n          throw new InvalidShapeException(\"Point must be in 'lat, lon' or 'x y' format: \" + str);\n        int middleEndIdx = findIndexNotSpace(str, spaceIdx + 1, +1);\n        x = Double.parseDouble(str.substring(0, spaceIdx));\n        y = Double.parseDouble(str.substring(middleEndIdx));\n      } else {\n        // \"lat, lon\" format\n        int middleStartIdx = findIndexNotSpace(str, commaIdx - 1, -1);\n        int middleEndIdx = findIndexNotSpace(str, commaIdx + 1, +1);\n        y = Double.parseDouble(str.substring(0, middleStartIdx + 1));\n        x = Double.parseDouble(str.substring(middleEndIdx));\n      }\n\n      x = ctx.normX(x);//by default norm* methods do nothing but perhaps it's been customized\n      y = ctx.normY(y);\n      return ctx.makePoint(x, y);//will verify x & y fit in boundary\n    } catch (InvalidShapeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new InvalidShapeException(e.toString(), e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59d82b0be40ecfcc2c94c776b324e0903a62b844":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59d82b0be40ecfcc2c94c776b324e0903a62b844"]},"commit2Childs":{"59d82b0be40ecfcc2c94c776b324e0903a62b844":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["59d82b0be40ecfcc2c94c776b324e0903a62b844"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}