{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","commits":[{"id":"4522ffca5a1f420c6a02198c9332d7c596a30ca5","date":1457270822,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set((int) idValues.get(docBase+docID));\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set((int) idValues.get(docBase+docID));\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set((int) idValues.get(docBase+docID));\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set((int) idValues.get(docBase+docID));\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set((int) idValues.get(docBase+docID));\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set((int) idValues.get(docBase+docID));\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set((int) idValues.get(docBase+docID));\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set((int) idValues.get(docBase+docID));\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"367f57e2ee85b7f7e28cfe73370a22cf67624f65","date":1476778467,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues();\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue(\"field\");\n        byte[] leafMaxValues = dimValues.getMaxPackedValue(\"field\");\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(\"field\", new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set((int) idValues.get(docBase+docID));\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                //System.out.println(\"visit check docID=\" + docID + \" id=\" + idValues.get(docID));\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set((int) idValues.get(docBase+docID));\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + idValues.get(docID));\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMinValues[dim], 0) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, docValues[ord][dim], 0, expectedMaxValues[dim], 0) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          if (StringHelper.compare(numBytesPerDim, leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (StringHelper.compare(numBytesPerDim, leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                      StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                             StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    verify(dir, docValues, ids, numDims, numDims, numBytesPerDim, expectExceptions);\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        doc.add(new BinaryPoint(\"field\", docValues[ord]));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          xdoc.add(new BinaryPoint(\"field\", docValues[ord]));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":4,"author":"Nicholas Knize","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,boolean).mjava","sourceNew":null,"sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    verify(dir, docValues, ids, numDims, numDims, numBytesPerDim, expectExceptions);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4522ffca5a1f420c6a02198c9332d7c596a30ca5","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["4522ffca5a1f420c6a02198c9332d7c596a30ca5","367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["41f60ea1802fda42d3c91d023406066d00ddb5f8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}