{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","commits":[{"id":"8af24f206736d88373229e8c83ddb84a433e57f3","date":1520362563,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (ScheduledTrigger.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get()) {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n\n          try {\n            if (replay) {\n              TriggerEvent event;\n              // peek first without removing - we may crash before calling the listener\n              while ((event = queue.peekEvent()) != null) {\n                // override REPLAYING=true\n                event.getProperties().put(TriggerEvent.REPLAYING, true);\n                if (!trigger.getProcessor().process(event)) {\n                  log.error(\"Failed to re-play event, discarding: \" + event);\n                }\n                queue.pollEvent(); // always remove it from queue\n              }\n              // now restore saved state to possibly generate new events from old state on the first run\n              try {\n                trigger.restoreState();\n              } catch (Exception e) {\n                // log but don't throw - see below\n                log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n              }\n              replay = false;\n            }\n          } catch (AlreadyClosedException e) {\n            \n          } catch (Exception e) {\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          }\n          try {\n            trigger.run();\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","bugFix":["15ba547dfc0dd0b670e678cb3db8e5d27c694420","009caa80830ac6369c42e5f6515405d686eabfee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get()) {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n\n          try {\n            if (replay) {\n              TriggerEvent event;\n              // peek first without removing - we may crash before calling the listener\n              while ((event = queue.peekEvent()) != null) {\n                // override REPLAYING=true\n                event.getProperties().put(TriggerEvent.REPLAYING, true);\n                if (!trigger.getProcessor().process(event)) {\n                  log.error(\"Failed to re-play event, discarding: {}\", event);\n                }\n                queue.pollEvent(); // always remove it from queue\n              }\n              // now restore saved state to possibly generate new events from old state on the first run\n              try {\n                trigger.restoreState();\n              } catch (Exception e) {\n                // log but don't throw - see below\n                log.error(\"Error restoring trigger state {}\", trigger.getName(), e);\n              }\n              replay = false;\n            }\n          } catch (AlreadyClosedException e) {\n            \n          } catch (Exception e) {\n            log.error(\"Unexpected exception from trigger: {}\", trigger.getName(), e);\n          }\n          try {\n            trigger.run();\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: {}\", trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get()) {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n\n          try {\n            if (replay) {\n              TriggerEvent event;\n              // peek first without removing - we may crash before calling the listener\n              while ((event = queue.peekEvent()) != null) {\n                // override REPLAYING=true\n                event.getProperties().put(TriggerEvent.REPLAYING, true);\n                if (!trigger.getProcessor().process(event)) {\n                  log.error(\"Failed to re-play event, discarding: \" + event);\n                }\n                queue.pollEvent(); // always remove it from queue\n              }\n              // now restore saved state to possibly generate new events from old state on the first run\n              try {\n                trigger.restoreState();\n              } catch (Exception e) {\n                // log but don't throw - see below\n                log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n              }\n              replay = false;\n            }\n          } catch (AlreadyClosedException e) {\n            \n          } catch (Exception e) {\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          }\n          try {\n            trigger.run();\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","sourceNew":null,"sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get()) {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n\n          try {\n            if (replay) {\n              TriggerEvent event;\n              // peek first without removing - we may crash before calling the listener\n              while ((event = queue.peekEvent()) != null) {\n                // override REPLAYING=true\n                event.getProperties().put(TriggerEvent.REPLAYING, true);\n                if (!trigger.getProcessor().process(event)) {\n                  log.error(\"Failed to re-play event, discarding: {}\", event);\n                }\n                queue.pollEvent(); // always remove it from queue\n              }\n              // now restore saved state to possibly generate new events from old state on the first run\n              try {\n                trigger.restoreState();\n              } catch (Exception e) {\n                // log but don't throw - see below\n                log.error(\"Error restoring trigger state {}\", trigger.getName(), e);\n              }\n              replay = false;\n            }\n          } catch (AlreadyClosedException e) {\n            \n          } catch (Exception e) {\n            log.error(\"Unexpected exception from trigger: {}\", trigger.getName(), e);\n          }\n          try {\n            trigger.run();\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: {}\", trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["e35f2dde06b35aa9904949a3a93fabd090371077"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8af24f206736d88373229e8c83ddb84a433e57f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8af24f206736d88373229e8c83ddb84a433e57f3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e35f2dde06b35aa9904949a3a93fabd090371077":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e35f2dde06b35aa9904949a3a93fabd090371077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8af24f206736d88373229e8c83ddb84a433e57f3"],"8af24f206736d88373229e8c83ddb84a433e57f3":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e35f2dde06b35aa9904949a3a93fabd090371077":["3f504512a03d978990cbff30db0522b354e846db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}