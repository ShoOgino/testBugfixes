{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","commits":[{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert BasicOperations.isDeterministic(a);\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c8cfaac638acc80d26d08288440ede37e6539e9","date":1402678000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert BasicOperations.isDeterministic(a);\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert BasicOperations.isDeterministic(a);\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert BasicOperations.isDeterministic(a);\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"0c8cfaac638acc80d26d08288440ede37e6539e9":["75ac8571c2d82c574e446c3729251b994c69a55c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["75ac8571c2d82c574e446c3729251b994c69a55c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"0c8cfaac638acc80d26d08288440ede37e6539e9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}