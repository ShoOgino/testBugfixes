{"path":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet#union(Collection[WAH8DocIdSet],int).mjava","commits":[{"id":"794214a4691ccb0a156a9ea0dfd8663ab9f05bb4","date":1373484264,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet#union(Collection[WAH8DocIdSet],int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute the union of the provided sets. This method is much faster than\n   * computing the union manually since it operates directly at the byte level.\n   */\n  public static WAH8DocIdSet union(Collection<WAH8DocIdSet> docIdSets, int indexInterval) {\n    switch (docIdSets.size()) {\n      case 0:\n        return EMPTY;\n      case 1:\n        return docIdSets.iterator().next();\n    }\n    // The logic below is very similar to DisjunctionScorer\n    final int numSets = docIdSets.size();\n    final PriorityQueue<Iterator> iterators = new PriorityQueue<WAH8DocIdSet.Iterator>(numSets) {\n      @Override\n      protected boolean lessThan(Iterator a, Iterator b) {\n        return a.wordNum < b.wordNum;\n      }\n    };\n    for (WAH8DocIdSet set : docIdSets) {\n      Iterator iterator = set.iterator();\n      iterator.nextWord();\n      iterators.add(iterator);\n    }\n\n    Iterator top = iterators.top();\n    if (top.wordNum == Integer.MAX_VALUE) {\n      return EMPTY;\n    }\n    int wordNum = top.wordNum;\n    byte word = top.word;\n    final WordBuilder builder = new WordBuilder().setIndexInterval(indexInterval);\n    while (true) {\n      top.nextWord();\n      iterators.updateTop();\n      top = iterators.top();\n      if (top.wordNum == wordNum) {\n        word |= top.word;\n      } else {\n        builder.addWord(wordNum, word);\n        if (top.wordNum == Integer.MAX_VALUE) {\n          break;\n        }\n        wordNum = top.wordNum;\n        word = top.word;\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet#union(Collection[WAH8DocIdSet],int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute the union of the provided sets. This method is much faster than\n   * computing the union manually since it operates directly at the byte level.\n   */\n  public static WAH8DocIdSet union(Collection<WAH8DocIdSet> docIdSets, int indexInterval) {\n    switch (docIdSets.size()) {\n      case 0:\n        return EMPTY;\n      case 1:\n        return docIdSets.iterator().next();\n    }\n    // The logic below is very similar to DisjunctionScorer\n    final int numSets = docIdSets.size();\n    final PriorityQueue<Iterator> iterators = new PriorityQueue<WAH8DocIdSet.Iterator>(numSets) {\n      @Override\n      protected boolean lessThan(Iterator a, Iterator b) {\n        return a.wordNum < b.wordNum;\n      }\n    };\n    for (WAH8DocIdSet set : docIdSets) {\n      Iterator iterator = set.iterator();\n      iterator.nextWord();\n      iterators.add(iterator);\n    }\n\n    Iterator top = iterators.top();\n    if (top.wordNum == Integer.MAX_VALUE) {\n      return EMPTY;\n    }\n    int wordNum = top.wordNum;\n    byte word = top.word;\n    final WordBuilder builder = new WordBuilder().setIndexInterval(indexInterval);\n    while (true) {\n      top.nextWord();\n      iterators.updateTop();\n      top = iterators.top();\n      if (top.wordNum == wordNum) {\n        word |= top.word;\n      } else {\n        builder.addWord(wordNum, word);\n        if (top.wordNum == Integer.MAX_VALUE) {\n          break;\n        }\n        wordNum = top.wordNum;\n        word = top.word;\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8","date":1412674810,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet#union(Collection[WAH8DocIdSet],int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Compute the union of the provided sets. This method is much faster than\n   * computing the union manually since it operates directly at the byte level.\n   */\n  public static WAH8DocIdSet union(Collection<WAH8DocIdSet> docIdSets, int indexInterval) {\n    switch (docIdSets.size()) {\n      case 0:\n        return EMPTY;\n      case 1:\n        return docIdSets.iterator().next();\n    }\n    // The logic below is very similar to DisjunctionScorer\n    final int numSets = docIdSets.size();\n    final PriorityQueue<Iterator> iterators = new PriorityQueue<WAH8DocIdSet.Iterator>(numSets) {\n      @Override\n      protected boolean lessThan(Iterator a, Iterator b) {\n        return a.wordNum < b.wordNum;\n      }\n    };\n    for (WAH8DocIdSet set : docIdSets) {\n      Iterator iterator = set.iterator();\n      iterator.nextWord();\n      iterators.add(iterator);\n    }\n\n    Iterator top = iterators.top();\n    if (top.wordNum == Integer.MAX_VALUE) {\n      return EMPTY;\n    }\n    int wordNum = top.wordNum;\n    byte word = top.word;\n    final WordBuilder builder = new WordBuilder().setIndexInterval(indexInterval);\n    while (true) {\n      top.nextWord();\n      iterators.updateTop();\n      top = iterators.top();\n      if (top.wordNum == wordNum) {\n        word |= top.word;\n      } else {\n        builder.addWord(wordNum, word);\n        if (top.wordNum == Integer.MAX_VALUE) {\n          break;\n        }\n        wordNum = top.wordNum;\n        word = top.word;\n      }\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet#union(Collection[WAH8DocIdSet],int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Compute the union of the provided sets. This method is much faster than\n   * computing the union manually since it operates directly at the byte level.\n   */\n  public static WAH8DocIdSet union(Collection<WAH8DocIdSet> docIdSets, int indexInterval) {\n    switch (docIdSets.size()) {\n      case 0:\n        return EMPTY;\n      case 1:\n        return docIdSets.iterator().next();\n    }\n    // The logic below is very similar to DisjunctionScorer\n    final int numSets = docIdSets.size();\n    final PriorityQueue<Iterator> iterators = new PriorityQueue<WAH8DocIdSet.Iterator>(numSets) {\n      @Override\n      protected boolean lessThan(Iterator a, Iterator b) {\n        return a.wordNum < b.wordNum;\n      }\n    };\n    for (WAH8DocIdSet set : docIdSets) {\n      Iterator iterator = set.iterator();\n      iterator.nextWord();\n      iterators.add(iterator);\n    }\n\n    Iterator top = iterators.top();\n    if (top.wordNum == Integer.MAX_VALUE) {\n      return EMPTY;\n    }\n    int wordNum = top.wordNum;\n    byte word = top.word;\n    final WordBuilder builder = new WordBuilder().setIndexInterval(indexInterval);\n    while (true) {\n      top.nextWord();\n      iterators.updateTop();\n      top = iterators.top();\n      if (top.wordNum == wordNum) {\n        word |= top.word;\n      } else {\n        builder.addWord(wordNum, word);\n        if (top.wordNum == Integer.MAX_VALUE) {\n          break;\n        }\n        wordNum = top.wordNum;\n        word = top.word;\n      }\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"794214a4691ccb0a156a9ea0dfd8663ab9f05bb4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55980207f1977bd1463465de1659b821347e2fa8":["794214a4691ccb0a156a9ea0dfd8663ab9f05bb4","0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","794214a4691ccb0a156a9ea0dfd8663ab9f05bb4"],"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8":["794214a4691ccb0a156a9ea0dfd8663ab9f05bb4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"]},"commit2Childs":{"794214a4691ccb0a156a9ea0dfd8663ab9f05bb4":["55980207f1977bd1463465de1659b821347e2fa8","37a0f60745e53927c4c876cfe5b5a58170f0646c","0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"],"55980207f1977bd1463465de1659b821347e2fa8":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["794214a4691ccb0a156a9ea0dfd8663ab9f05bb4","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}