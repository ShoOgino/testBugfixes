{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = stateProvider.resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"813335f324f8bd40ae4d83d8391674b42b536cc0","date":1555591986,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","date":1571071547,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839","date":1575929518,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"993b0c7dda6341b437fe5685d35c6cc35eaac420","date":1575985950,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    @SuppressWarnings({\"rawtypes\"})\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    @SuppressWarnings({\"rawtypes\"})\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25726728867b518829d762aa00b696cbfa96818c","date":1595801885,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String, List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    String routeField = (routeFieldDeprecated != null) ? routeFieldDeprecated :\n        (col.getRouter().getRouteField(col) == null) ? ID : col.getRouter().getRouteField(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, routeField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, routeField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    @SuppressWarnings({\"rawtypes\"})\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    @SuppressWarnings({\"rawtypes\"})\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    } else {\n      params = new ModifiableSolrParams();\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias. Updates to multi-collection aliases are ok as long\n    // as they are routed aliases\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    if (getClusterStateProvider().isRoutedAlias(collection) || aliasedCollections.size() == 1) {\n      collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Update request to non-routed multi-collection alias not supported: \"\n        + collection + \" -> \" + aliasedCollections);\n    }\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    ReplicaListTransformer replicaListTransformer = requestRLTGenerator.getReplicaListTransformer(params);\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col, replicaListTransformer);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    @SuppressWarnings({\"rawtypes\"})\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    @SuppressWarnings({\"rawtypes\"})\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25726728867b518829d762aa00b696cbfa96818c":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["25726728867b518829d762aa00b696cbfa96818c"],"b0b597c65628ca9e73913a07e81691f8229bae35":["813335f324f8bd40ae4d83d8391674b42b536cc0","23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"]},"commit2Childs":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["993b0c7dda6341b437fe5685d35c6cc35eaac420","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839","b0b597c65628ca9e73913a07e81691f8229bae35"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":[],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["25726728867b518829d762aa00b696cbfa96818c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"25726728867b518829d762aa00b696cbfa96818c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","b0b597c65628ca9e73913a07e81691f8229bae35"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["993b0c7dda6341b437fe5685d35c6cc35eaac420","0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["993b0c7dda6341b437fe5685d35c6cc35eaac420","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}