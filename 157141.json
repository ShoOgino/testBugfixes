{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","commits":[{"id":"d960f1bec0365fa24a5d945b09511e4448ff2c6c","date":1340258737,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(queryCenter, distRange[0]*0.99, 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(queryCenter, distRange[1]*1.01, points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(queryCenter, queryDist, ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(queryCenter, distRange[0]*0.99, 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(queryCenter, distRange[1]*1.01, points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(queryCenter, queryDist, ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85ac3534293008a0b7704f8ba54592d51fd29fa5","date":1346435585,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(q(queryCenter, distRange[0]*0.99), 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(q(queryCenter, distRange[1]*1.01), points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(q(queryCenter, queryDist), ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(queryCenter, distRange[0]*0.99, 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(queryCenter, distRange[1]*1.01, points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(queryCenter, queryDist, ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d1f90e969803cc84174589b5e4a39b7935fecd","date":1346584861,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(q(queryCenter, distRange[0]*0.99), 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(q(queryCenter, distRange[1]*1.01), points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(q(queryCenter, queryDist), ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(queryCenter, distRange[0]*0.99, 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(queryCenter, distRange[1]*1.01, points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(queryCenter, queryDist, ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(0,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt() * 360, ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg*0.99), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{new PointImpl(0,0), new PointImpl(0,90),new PointImpl(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallDegrees = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallDegrees < 1;\n      double largeDegrees = 20d;//good large size; don't use >=45 for this test code to work\n      double[] sideDegrees = {largeDegrees,smallDegrees};\n      for (double sideDegree : sideDegrees) {\n        //3. Index random points in this cluster box\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          double x = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getX();\n          double y = random().nextDouble()*sideDegree - sideDegree/2 + clusterCenter.getY();\n          final Point pt = normPointXY(x, y);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use 4 query centers. Each is radially out from each corner of cluster box by twice distance to box edge.\n        for(double qcXoff : new double[]{sideDegree,-sideDegree}) {//query-center X offset from cluster center\n          for(double qcYoff : new double[]{sideDegree,-sideDegree}) {//query-center Y offset from cluster center\n            Point queryCenter = normPointXY(qcXoff + clusterCenter.getX(),\n                qcYoff + clusterCenter.getY());\n            double[] distRange = calcDistRange(queryCenter,clusterCenter,sideDegree);\n            //4.1 query a small box getting nothing\n            checkHits(q(queryCenter, distRange[0]*0.99), 0, null);\n            //4.2 Query a large box enclosing the cluster, getting everything\n            checkHits(q(queryCenter, distRange[1]*1.01), points.size(), null);\n            //4.3 Query a medium box getting some (calculate the correct solution and verify)\n            double queryDist = distRange[0] + (distRange[1]-distRange[0])/2;//average\n\n            //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n            int[] ids = new int[points.size()];\n            int ids_sz = 0;\n            for (int i = 0; i < points.size(); i++) {\n              Point point = points.get(i);\n              if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n                ids[ids_sz++] = i;\n            }\n            ids = Arrays.copyOf(ids, ids_sz);\n            //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n            checkHits(q(queryCenter, queryDist), ids.length, ids);\n          }\n        }\n\n      }//for sideDegree\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":["2f523d3a740ac2a3ac6810ccebfd60ae45e113f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa37f9ae919f4d1075800c86705ad33ad8dcff65","date":1346862292,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test @Ignore /* LUCENE-4351 ignore this test until I figure out why it failed (as reported by Jenkins) */\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(0,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt() * 360, ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg*0.99), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(0,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt() * 360, ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg*0.99), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c4caeb9a775636c7f33b0626840399f5fef1082","date":1347129009,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test @Ignore /* LUCENE-4351 ignore this test until I figure out why it failed (as reported by Jenkins) */\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(0,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt() * 360, ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg*0.99), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f523d3a740ac2a3ac6810ccebfd60ae45e113f1","date":1347136103,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3 + smallRadius/2), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3*1.01), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":["da956410d7a790f567af4e7e94584fb0930212f2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3 + smallRadius/2), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<Point>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3 + smallRadius/2), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f54c29b684839e16d0a7ffd41ee8a1e93e905184","date":1395120410,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy#geohashRecursiveRandom().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void geohashRecursiveRandom() throws IOException {\n    init(12);\n\n    //1. Iterate test with the cluster at some worldly point of interest\n    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};\n    for (Point clusterCenter : clusterCenters) {\n      //2. Iterate on size of cluster (a really small one and a large one)\n      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);\n      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)\n      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision\n      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);\n      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());\n      assert smallRadius < 1;\n      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work\n      double[] radiusDegs = {largeRadius,smallRadius};\n      for (double radiusDeg : radiusDegs) {\n        //3. Index random points in this cluster circle\n        deleteAll();\n        List<Point> points = new ArrayList<>();\n        for(int i = 0; i < 20; i++) {\n          //Note that this will not result in randomly distributed points in the\n          // circle, they will be concentrated towards the center a little. But\n          // it's good enough.\n          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);\n          pt = alignGeohash(pt);\n          points.add(pt);\n          addDocument(newDoc(\"\" + i, pt));\n        }\n        commit();\n\n        //3. Use some query centers. Each is twice the cluster's radius away.\n        for(int ri = 0; ri < 4; ri++) {\n          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,\n              radiusDeg*2, random().nextInt(360), ctx, null);\n          queryCenter = alignGeohash(queryCenter);\n          //4.1 Query a small box getting nothing\n          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);\n          //4.2 Query a large box enclosing the cluster, getting everything\n          checkHits(q(queryCenter, radiusDeg*3 + smallRadius/2), points.size(), null);\n          //4.3 Query a medium box getting some (calculate the correct solution and verify)\n          double queryDist = radiusDeg * 2;\n\n          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.\n          int[] ids = new int[points.size()];\n          int ids_sz = 0;\n          for (int i = 0; i < points.size(); i++) {\n            Point point = points.get(i);\n            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)\n              ids[ids_sz++] = i;\n          }\n          ids = Arrays.copyOf(ids, ids_sz);\n          //assert ids_sz > 0 (can't because randomness keeps us from being able to)\n\n          checkHits(q(queryCenter, queryDist), ids.length, ids);\n        }\n\n      }//for radiusDeg\n\n    }//for clusterCenter\n\n  }//randomTest()\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2f523d3a740ac2a3ac6810ccebfd60ae45e113f1"],"d0d1f90e969803cc84174589b5e4a39b7935fecd":["d960f1bec0365fa24a5d945b09511e4448ff2c6c","85ac3534293008a0b7704f8ba54592d51fd29fa5"],"85ac3534293008a0b7704f8ba54592d51fd29fa5":["d960f1bec0365fa24a5d945b09511e4448ff2c6c"],"fa37f9ae919f4d1075800c86705ad33ad8dcff65":["da956410d7a790f567af4e7e94584fb0930212f2"],"7c4caeb9a775636c7f33b0626840399f5fef1082":["fa37f9ae919f4d1075800c86705ad33ad8dcff65"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d960f1bec0365fa24a5d945b09511e4448ff2c6c"],"da956410d7a790f567af4e7e94584fb0930212f2":["85ac3534293008a0b7704f8ba54592d51fd29fa5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d960f1bec0365fa24a5d945b09511e4448ff2c6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"2f523d3a740ac2a3ac6810ccebfd60ae45e113f1":["7c4caeb9a775636c7f33b0626840399f5fef1082"]},"commit2Childs":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"d0d1f90e969803cc84174589b5e4a39b7935fecd":[],"85ac3534293008a0b7704f8ba54592d51fd29fa5":["d0d1f90e969803cc84174589b5e4a39b7935fecd","da956410d7a790f567af4e7e94584fb0930212f2"],"fa37f9ae919f4d1075800c86705ad33ad8dcff65":["7c4caeb9a775636c7f33b0626840399f5fef1082"],"7c4caeb9a775636c7f33b0626840399f5fef1082":["2f523d3a740ac2a3ac6810ccebfd60ae45e113f1"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"da956410d7a790f567af4e7e94584fb0930212f2":["fa37f9ae919f4d1075800c86705ad33ad8dcff65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d960f1bec0365fa24a5d945b09511e4448ff2c6c"],"d960f1bec0365fa24a5d945b09511e4448ff2c6c":["d0d1f90e969803cc84174589b5e4a39b7935fecd","85ac3534293008a0b7704f8ba54592d51fd29fa5","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2f523d3a740ac2a3ac6810ccebfd60ae45e113f1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d0d1f90e969803cc84174589b5e4a39b7935fecd","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}