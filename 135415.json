{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPathsExact(Automaton,FST[T]).mjava","commits":[{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPathsExact(Automaton,FST[T]).mjava","pathOld":"/dev/null","sourceNew":"  /** Enumerates all paths in the automaton that also\n   *  intersect the FST, accumulating the FST end node and\n   *  output for each path. */\n  public static<T> List<Path<T>> intersectPrefixPathsExact(Automaton a, FST<T> fst) throws IOException {\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n\n    queue.add(new Path<T>(a.getInitialState(),\n                          fst.getFirstArc(new FST.Arc<T>()),       \n                          fst.outputs.getNoOutput(),\n                          new IntsRef()));\n\n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    //System.out.println(\"fst/a intersect\");\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size()-1);\n      //System.out.println(\"  cycle path=\" + path);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n      }\n\n      IntsRef currentInput = path.input;\n      for(Transition t : path.state.getTransitions()) {\n        // TODO: we can fix this if necessary:\n        if (t.getMin() != t.getMax()) {\n          throw new IllegalStateException(\"can only handle Transitions that match one character\");\n        }\n\n        //System.out.println(\"    t=\" + (char) t.getMin());\n\n        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);\n        if (nextArc != null) {\n          //System.out.println(\"      fst matches\");\n          // Path continues:\n          IntsRef newInput = new IntsRef(currentInput.length + 1);\n          newInput.copyInts(currentInput);\n          newInput.ints[currentInput.length] = t.getMin();\n          newInput.length = currentInput.length + 1;\n\n          queue.add(new Path<T>(t.getDest(),\n                                new FST.Arc<T>().copyFrom(nextArc),\n                                fst.outputs.add(path.output, nextArc.output),\n                                newInput));\n        }\n      }\n    }\n\n    return endNodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","date":1350576194,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPathsExact(Automaton,FST[T]).mjava","sourceNew":null,"sourceOld":"  /** Enumerates all paths in the automaton that also\n   *  intersect the FST, accumulating the FST end node and\n   *  output for each path. */\n  public static<T> List<Path<T>> intersectPrefixPathsExact(Automaton a, FST<T> fst) throws IOException {\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n\n    queue.add(new Path<T>(a.getInitialState(),\n                          fst.getFirstArc(new FST.Arc<T>()),       \n                          fst.outputs.getNoOutput(),\n                          new IntsRef()));\n\n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    //System.out.println(\"fst/a intersect\");\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size()-1);\n      //System.out.println(\"  cycle path=\" + path);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n      }\n\n      IntsRef currentInput = path.input;\n      for(Transition t : path.state.getTransitions()) {\n        // TODO: we can fix this if necessary:\n        if (t.getMin() != t.getMax()) {\n          throw new IllegalStateException(\"can only handle Transitions that match one character\");\n        }\n\n        //System.out.println(\"    t=\" + (char) t.getMin());\n\n        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);\n        if (nextArc != null) {\n          //System.out.println(\"      fst matches\");\n          // Path continues:\n          IntsRef newInput = new IntsRef(currentInput.length + 1);\n          newInput.copyInts(currentInput);\n          newInput.ints[currentInput.length] = t.getMin();\n          newInput.length = currentInput.length + 1;\n\n          queue.add(new Path<T>(t.getDest(),\n                                new FST.Arc<T>().copyFrom(nextArc),\n                                fst.outputs.add(path.output, nextArc.output),\n                                newInput));\n        }\n      }\n    }\n\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cc41b743423981e7ec17a024ce7e107096e472fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"cc41b743423981e7ec17a024ce7e107096e472fe":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cc41b743423981e7ec17a024ce7e107096e472fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}