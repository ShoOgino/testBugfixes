{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int,boolean).mjava","commits":[{"id":"d4e0095ef720d1b8e7406847147af69f19af3ab6","date":1383131477,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","sourceNew":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   * @param preservePositionIncrements Whether position holes\n   *   should appear in the automata\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n      boolean preservePositionIncrements) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    this.preservePositionIncrements = preservePositionIncrements;\n  }\n\n","sourceOld":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    preservePositionIncrements = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   * @param preservePositionIncrements Whether position holes\n   *   should appear in the automata\n   */\n  public AnalyzingSuggester(Directory tempDir, String tempFileNamePrefix, Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n      boolean preservePositionIncrements) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    this.preservePositionIncrements = preservePositionIncrements;\n    this.tempDir = tempDir;\n    this.tempFileNamePrefix = tempFileNamePrefix;\n  }\n\n","sourceOld":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   * @param preservePositionIncrements Whether position holes\n   *   should appear in the automata\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n      boolean preservePositionIncrements) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    this.preservePositionIncrements = preservePositionIncrements;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["867e3d9153fb761456b54a9dcce566e1545c5ef6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}