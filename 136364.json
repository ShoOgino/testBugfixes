{"path":"lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler#testChangeMaxMergeCountyWhileForceMerge().mjava","commits":[{"id":"737e811ac4583c640a0680e784121677f311a8af","date":1587558614,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler#testChangeMaxMergeCountyWhileForceMerge().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * This test tries to produce 2 merges running concurrently with 2 segments per merge. While these\n   * merges run we kick off a forceMerge that puts a pending merge in the queue but waits for things to happen.\n   * While we do this we reduce maxMergeCount to 1. If concurrency in CMS is not right the forceMerge will wait forever\n   * since none of the currently running merges picks up the pending merge. This test fails every time.\n   */\n  public void testChangeMaxMergeCountyWhileForceMerge() throws IOException, InterruptedException {\n    int numIters = TEST_NIGHTLY ? 100 : 10;\n    for (int iters = 0; iters < numIters; iters++) {\n      LogDocMergePolicy mp = new LogDocMergePolicy();\n      mp.setMergeFactor(2);\n      CountDownLatch forceMergeWaits = new CountDownLatch(1);\n      CountDownLatch mergeThreadsStartAfterWait = new CountDownLatch(1);\n      CountDownLatch mergeThreadsArrived = new CountDownLatch(2);\n      InfoStream stream = new InfoStream() {\n        @Override\n        public void message(String component, String message) {\n          if (\"TP\".equals(component) && \"mergeMiddleStart\".equals(message)) {\n            mergeThreadsArrived.countDown();\n            try {\n              mergeThreadsStartAfterWait.await();\n            } catch (InterruptedException e) {\n              throw new AssertionError(e);\n            }\n          } else if (\"TP\".equals(component) && \"forceMergeBeforeWait\".equals(message)) {\n            forceMergeWaits.countDown();\n          }\n        }\n\n        @Override\n        public boolean isEnabled(String component) {\n          return \"TP\".equals(component);\n        }\n\n        @Override\n        public void close() {\n        }\n      };\n      try (Directory dir = newDirectory();\n           IndexWriter writer = new IndexWriter(dir,\n               new IndexWriterConfig().setMergeScheduler(new ConcurrentMergeScheduler())\n                   .setMergePolicy(mp).setInfoStream(stream)) {\n             @Override\n             protected boolean isEnableTestPoints() {\n               return true;\n             }\n           }) {\n        Thread t = new Thread(() -> {\n          try {\n            writer.forceMerge(1);\n          } catch (IOException e) {\n            throw new AssertionError(e);\n          }\n        });\n        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler();\n        cms.setMaxMergesAndThreads(2, 2);\n        try {\n          for (int i = 0; i < 4; i++) {\n            Document document = new Document();\n            document.add(new TextField(\"foo\", \"the quick brown fox jumps over the lazy dog\", Field.Store.YES));\n            document.add(new TextField(\"bar\", RandomStrings.randomRealisticUnicodeOfLength(random(), 20), Field.Store.YES));\n            writer.addDocument(document);\n            writer.flush();\n          }\n          assertEquals(writer.cloneSegmentInfos().toString(), 4, writer.getSegmentCount());\n          mergeThreadsArrived.await();\n          t.start();\n          forceMergeWaits.await();\n          cms.setMaxMergesAndThreads(1, 1);\n        } finally {\n          mergeThreadsStartAfterWait.countDown();\n        }\n\n        while (t.isAlive()) {\n          t.join(10);\n          if (cms.mergeThreadCount() == 0 && writer.hasPendingMerges()) {\n            fail(\"writer has pending merges but no CMS threads are running\");\n          }\n        }\n        assertEquals(1, writer.getSegmentCount());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"737e811ac4583c640a0680e784121677f311a8af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["737e811ac4583c640a0680e784121677f311a8af"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["737e811ac4583c640a0680e784121677f311a8af"],"737e811ac4583c640a0680e784121677f311a8af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}