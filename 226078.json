{"path":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","commits":[{"id":"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0","date":1446511397,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n    \n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' must be <lst/>\");\n          }\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' has unexpected 'exclude' sub-param(s): '\"\n                                    + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                  \"' contains unexpected child param(s): '\" +\n                                  selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR, \"Init params do not specify anything to clone, please supply either \"\n      + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for CloneFieldUpdateProcessorFactory for further details.\");\n    }\n    \n    if (d instanceof NamedList) {\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n      \n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' are both mandatoryand can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n                                + destList.getName(0) + \"'\");\n      }\n      \n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n                                \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n        \n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n                              \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n                              PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(@SuppressWarnings({\"rawtypes\"})NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n    \n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' must be <lst/>\");\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' has unexpected 'exclude' sub-param(s): '\"\n                                    + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                  \"' contains unexpected child param(s): '\" +\n                                  selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR, \"Init params do not specify anything to clone, please supply either \"\n      + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for CloneFieldUpdateProcessorFactory for further details.\");\n    }\n    \n    if (d instanceof NamedList) {\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n      \n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' are both mandatoryand can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n                                + destList.getName(0) + \"'\");\n      }\n      \n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n                                \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n        \n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n                              \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n                              PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n    \n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' child 'exclude' must be <lst/>\");\n          }\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                    \"' has unexpected 'exclude' sub-param(s): '\"\n                                    + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                                  \"' contains unexpected child param(s): '\" +\n                                  selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR, \"Init params do not specify anything to clone, please supply either \"\n      + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for CloneFieldUpdateProcessorFactory for further details.\");\n    }\n    \n    if (d instanceof NamedList) {\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n      \n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' are both mandatoryand can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n                                PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n                                \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n                                + destList.getName(0) + \"'\");\n      }\n      \n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n                                \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n        \n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n                              \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n                              PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}