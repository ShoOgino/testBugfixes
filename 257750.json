{"path":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","commits":[{"id":"8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2","date":1331803866,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TermGroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields = multipleFacetValuesPerDocument? new Field[2 + random.nextInt(6)] : new Field[1];\n    for (int i = 0; i < facetFields.length; i++) {\n      facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[i]);\n      docNoGroup.add(facetFields[i]);\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setStringValue(facetValue);\n          facetVals.add(facetValue);\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2"],"8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}