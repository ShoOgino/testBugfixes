{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"212912761d471e5bfe06cf8027bad27e60a37695","date":1335188643,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#open() \n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b374d78db8148ec6796fdf37148b33897ab40a8c","date":1351606544,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.\n\n    // Now look for already loaded swappable cores.\n    synchronized (swappableCores) {\n      core = swappableCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no swappable core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isSwappable()) {\n        registerLazyCore(name, core, false);    // This is a swappable core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name= checkDefault(name);\n    synchronized(cores) {\n      SolrCore core = cores.get(name);\n      if (core != null)\n        core.open();  // increment the ref count while still synchronized\n      return core;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b4b8d3d62eadaf42f3c2c0a23230275892d374","date":1355937334,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.\n\n    // Now look for already loaded swappable cores.\n    synchronized (swappableCores) {\n      core = swappableCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no swappable core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isSwappable()) {\n        registerLazyCore(name, core, false);    // This is a swappable core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.\n\n    // Now look for already loaded swappable cores.\n    synchronized (swappableCores) {\n      core = swappableCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no swappable core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isSwappable()) {\n        registerLazyCore(name, core, false);    // This is a swappable core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33399cc2618223f11ba493f9a3a2026fe05b579","date":1356813042,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any transient cores, so we're done.\n\n    // Now look for already loaded transient cores.\n    synchronized (transientCores) {\n      core = transientCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isTransient()) {\n        registerLazyCore(name, core, false);    // This is a transient core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.\n\n    // Now look for already loaded swappable cores.\n    synchronized (swappableCores) {\n      core = swappableCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no swappable core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isSwappable()) {\n        registerLazyCore(name, core, false);    // This is a swappable core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any transient cores, so we're done.\n\n    // Now look for already loaded transient cores.\n    synchronized (transientCores) {\n      core = transientCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isTransient()) {\n        registerLazyCore(name, core, false);    // This is a transient core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.\n\n    // Now look for already loaded swappable cores.\n    synchronized (swappableCores) {\n      core = swappableCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no swappable core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isSwappable()) {\n        registerLazyCore(name, core, false);    // This is a swappable core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1168477e46f783205c6fb94c21c32307926814","date":1358297289,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = getCoreFromAnyList(name);\n\n    if (core != null) return core;\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    // Keep multiple threads from loading the same core at the same time.\n    try {\n      boolean isPending;\n      synchronized (pendingDynamicCoreLoads) {\n        isPending = pendingDynamicCoreLoads.contains(name);\n        if (! isPending) {\n          pendingDynamicCoreLoads.add(name);\n        }\n      }\n\n      while (isPending) {\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          return null; // Seems best not to do anything at all if the thread is interrupted\n        }\n\n        synchronized (pendingDynamicCoreLoads) {\n          if (!pendingDynamicCoreLoads.contains(name)) {\n            // NOTE: If, for some reason, the load failed, we'll return null here and presumably the log will show\n            // why. We'll fail all over again next time if the problem isn't corrected.\n            return getCoreFromAnyList(name);\n          }\n        }\n      }\n      try {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        if (desc.isTransient()) {\n          registerLazyCore(name, core, false);    // This is a transient core\n        } else {\n          register(name, core, false); // This is a \"permanent\", although deferred-load core\n        }\n      } catch (Exception ex) {\n        throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n      }\n    } finally {\n      pendingDynamicCoreLoads.remove(name);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any transient cores, so we're done.\n\n    // Now look for already loaded transient cores.\n    synchronized (transientCores) {\n      core = transientCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isTransient()) {\n        registerLazyCore(name, core, false);    // This is a transient core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = getCoreFromAnyList(name);\n\n    if (core != null) return core;\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    // Keep multiple threads from loading the same core at the same time.\n    try {\n      boolean isPending;\n      synchronized (pendingDynamicCoreLoads) {\n        isPending = pendingDynamicCoreLoads.contains(name);\n        if (! isPending) {\n          pendingDynamicCoreLoads.add(name);\n        }\n      }\n\n      while (isPending) {\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          return null; // Seems best not to do anything at all if the thread is interrupted\n        }\n\n        synchronized (pendingDynamicCoreLoads) {\n          if (!pendingDynamicCoreLoads.contains(name)) {\n            // NOTE: If, for some reason, the load failed, we'll return null here and presumably the log will show\n            // why. We'll fail all over again next time if the problem isn't corrected.\n            return getCoreFromAnyList(name);\n          }\n        }\n      }\n      try {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        if (desc.isTransient()) {\n          registerLazyCore(name, core, false);    // This is a transient core\n        } else {\n          register(name, core, false); // This is a \"permanent\", although deferred-load core\n        }\n      } catch (Exception ex) {\n        throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n      }\n    } finally {\n      pendingDynamicCoreLoads.remove(name);\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core;\n\n    synchronized (cores) {\n      core = cores.get(name);\n      if (core != null) {\n        core.open();    // increment the ref count while still synchronized\n        return core;\n      }\n    }\n\n    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any transient cores, so we're done.\n\n    // Now look for already loaded transient cores.\n    synchronized (transientCores) {\n      core = transientCores.get(name);\n      if (core != null) {\n        core.open();\n        return core;\n      }\n    }\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n    try {\n      core = create(desc); // This should throw an error if it fails.\n      core.open();\n      if (desc.isTransient()) {\n        registerLazyCore(name, core, false);    // This is a transient core\n      } else {\n        register(name, core, false); // This is a \"permanent\", although deferred-load core\n      }\n    } catch (Exception ex) {\n      throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) return core;\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    core = coreMaps.waitPendingCoreOps(name); // This will put an entry in pending core ops if the core isn't loaded\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n\n    if (core == null) {\n      try {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } catch (Exception ex) {\n        throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n      } finally {\n        coreMaps.releasePending(name);\n      }\n    }\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = getCoreFromAnyList(name);\n\n    if (core != null) return core;\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc =  dynamicDescriptors.get(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    // Keep multiple threads from loading the same core at the same time.\n    try {\n      boolean isPending;\n      synchronized (pendingDynamicCoreLoads) {\n        isPending = pendingDynamicCoreLoads.contains(name);\n        if (! isPending) {\n          pendingDynamicCoreLoads.add(name);\n        }\n      }\n\n      while (isPending) {\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          return null; // Seems best not to do anything at all if the thread is interrupted\n        }\n\n        synchronized (pendingDynamicCoreLoads) {\n          if (!pendingDynamicCoreLoads.contains(name)) {\n            // NOTE: If, for some reason, the load failed, we'll return null here and presumably the log will show\n            // why. We'll fail all over again next time if the problem isn't corrected.\n            return getCoreFromAnyList(name);\n          }\n        }\n      }\n      try {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        if (desc.isTransient()) {\n          registerLazyCore(name, core, false);    // This is a transient core\n        } else {\n          register(name, core, false); // This is a \"permanent\", although deferred-load core\n        }\n      } catch (Exception ex) {\n        throw recordAndThrow(name, \"Unable to create core\" + name, ex);\n      }\n    } finally {\n      pendingDynamicCoreLoads.remove(name);\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245","date":1363106546,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) return core;\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    core = coreMaps.waitPendingCoreOps(name); // This will put an entry in pending core ops if the core isn't loaded\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n\n    if (core == null) {\n      try {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } catch (Exception ex) {\n        throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n      } finally {\n        coreMaps.releasePending(name);\n      }\n    }\n    return core;\n  }\n\n","bugFix":null,"bugIntro":["004ec9e26487ae9b6205e790f8f77ef5e98d8daf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab17cf116fd02ca93b83a5e65b242da418ec1181","date":1365450976,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** Gets a core by name and increase its refcount.\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":["49998598398261debaeb6b3e59d6e06bec3c1ffd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0cf46558b3f7708ed3a21e174b9e11cd30e26be","date":1365551184,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    if (cfg != null) { // Get this out of here sometime, this is test-code only stuff!\n      String badMsg = cfg.getBadCoreMessage(name);\n      if (badMsg != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, badMsg);\n      }\n    }\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3278df77f7f499b55fdb79861c0641450444e7d0","date":1366238988,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    if (cfg != null) { // Get this out of here sometime, this is test-code only stuff!\n      String badMsg = cfg.getBadConfigCoreMessage(name);\n      if (badMsg != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, badMsg);\n      }\n    }\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    if (cfg != null) { // Get this out of here sometime, this is test-code only stuff!\n      String badMsg = cfg.getBadCoreMessage(name);\n      if (badMsg != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, badMsg);\n      }\n    }\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9409650933cc688e77e565092a25e58adfc2e18d","date":1366663164,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    if (cfg != null) { // Get this out of here sometime, this is test-code only stuff!\n      String badMsg = cfg.getBadConfigCoreMessage(name);\n      if (badMsg != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, badMsg);\n      }\n    }\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = coreMaps.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = coreMaps.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = coreMaps.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      coreMaps.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1","date":1369336666,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce","date":1370818281,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86184cf8c7654ee1badea2a629b8bc0487c7f690","date":1372190237,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name);\n\n    if (core != null) {\n      core.open();\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d275f25d46bec8d215cc9d810169af5bf57ff35a","date":1383462494,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f763a1acdb27217b4799d1ca51c816739835a3e0","date":1387388124,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future\n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future\n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /** \n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close() \n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n      \n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future \n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85032ab568b3f50eabd577aaa994ba197db93758","date":1404157267,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          preRegisterInZk(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n        registerCore(desc.isTransient(), name, core, false);\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      // remains to be seen how transient cores and such\n      // will work in SolrCloud mode, but just to be future\n      // proof...\n      /*if (isZooKeeperAware()) {\n        try {\n          getZkController().unregister(name, desc);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          SolrException.log(log, null, e);\n        } catch (KeeperException e) {\n          SolrException.log(log, null, e);\n        }\n      }*/\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d629ca62e3b8ab6e29a127aebe213163d490413","date":1405524223,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      Exception e = getCoreInitFailures().get(name);\n      if (null != e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                e.getMessage(), e);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n        core.open();\n      } else {\n        core.open();\n      }\n    } catch(Exception ex){\n      throw recordAndThrow(name, \"Unable to create core: \" + name, ex);\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":["49998598398261debaeb6b3e59d6e06bec3c1ffd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd44bec977a26a118d9e809e2de6f7edb5ca0f39","date":1421673929,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    name = checkDefault(name);\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3","date":1448892165,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d528fd7ae22865015b756e0a03832e2051de2a9c","date":1476721105,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initalizing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"359aab8d0284ad77917fc39712289950b39edbec","date":1490727391,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrCoreInitializationException(name, loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49998598398261debaeb6b3e59d6e06bec3c1ffd","date":1490873946,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrCoreInitializationException(name, loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore '\" + name +\n                                \"' is not available due to init failure: \" +\n                                loadFailure.exception.getMessage(), loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":["ab17cf116fd02ca93b83a5e65b242da418ec1181","2d629ca62e3b8ab6e29a127aebe213163d490413"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrCoreInitializationException(name, loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    if (core != null) {\n      return core;\n    }\n\n    // OK, it's not presently in any list, is it in the list of dynamic cores but not loaded yet? If so, load it.\n    CoreDescriptor desc = solrCores.getDynamicDescriptor(name);\n    if (desc == null) { //Nope, no transient core with this name\n\n      // if there was an error initializing this core, throw a 500\n      // error with the details for clients attempting to access it.\n      CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n      if (null != loadFailure) {\n        throw new SolrCoreInitializationException(name, loadFailure.exception);\n      }\n      // otherwise the user is simply asking for something that doesn't exist.\n      return null;\n    }\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n                                 // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and \n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n    \n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd7a2b4785d366164d3cd69f9948de6ff34d23a1","date":1500527874,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d301cb76d81de80d07b44735622a04d49ed938eb","date":1500536382,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = create(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"004ec9e26487ae9b6205e790f8f77ef5e98d8daf","date":1506366751,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a","date":1506410441,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @see SolrCore#close()\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @exception SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    }\n    finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc1087854af39c9b439f47d913fd3ac1d85ac5c","date":1599523122,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  public SolrCore getCore(String name) {\n    return getCore(name, null);\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938fe8fd4d30ae70161827366f67c2382985e446","date":1600050178,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":"  public SolrCore getCore(String name) {\n    return getCore(name, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e451e492cce54699988e2ce0aea55e3ff170cb0","date":1600305561,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String).mjava","sourceNew":"  public SolrCore getCore(String name) {\n    return getCore(name, null);\n  }\n\n","sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a":["d301cb76d81de80d07b44735622a04d49ed938eb","004ec9e26487ae9b6205e790f8f77ef5e98d8daf"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce","86184cf8c7654ee1badea2a629b8bc0487c7f690"],"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["9409650933cc688e77e565092a25e58adfc2e18d"],"d275f25d46bec8d215cc9d810169af5bf57ff35a":["86184cf8c7654ee1badea2a629b8bc0487c7f690"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"359aab8d0284ad77917fc39712289950b39edbec":["d528fd7ae22865015b756e0a03832e2051de2a9c"],"ab17cf116fd02ca93b83a5e65b242da418ec1181":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"d6b4b8d3d62eadaf42f3c2c0a23230275892d374":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"004ec9e26487ae9b6205e790f8f77ef5e98d8daf":["d301cb76d81de80d07b44735622a04d49ed938eb"],"a0cf46558b3f7708ed3a21e174b9e11cd30e26be":["ab17cf116fd02ca93b83a5e65b242da418ec1181"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["359aab8d0284ad77917fc39712289950b39edbec"],"d301cb76d81de80d07b44735622a04d49ed938eb":["28288370235ed02234a64753cdbf0c6ec096304a","bd7a2b4785d366164d3cd69f9948de6ff34d23a1"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["936cdd5882761db3b844afd6f84ab81cbb011a75","9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"86184cf8c7654ee1badea2a629b8bc0487c7f690":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["d275f25d46bec8d215cc9d810169af5bf57ff35a","f763a1acdb27217b4799d1ca51c816739835a3e0"],"0158ced21948b6626f733c1c42c1e18d94449789":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3"],"49998598398261debaeb6b3e59d6e06bec3c1ffd":["d528fd7ae22865015b756e0a03832e2051de2a9c"],"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["a837c064b67fa63a9394136e31218b908cdcf783"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["49998598398261debaeb6b3e59d6e06bec3c1ffd"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b374d78db8148ec6796fdf37148b33897ab40a8c","c33399cc2618223f11ba493f9a3a2026fe05b579"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ad1168477e46f783205c6fb94c21c32307926814"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["d6b4b8d3d62eadaf42f3c2c0a23230275892d374"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3","0158ced21948b6626f733c1c42c1e18d94449789"],"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","a513b6a92751e54c76fb5447948c9e7d437163a7"],"9409650933cc688e77e565092a25e58adfc2e18d":["3278df77f7f499b55fdb79861c0641450444e7d0"],"3278df77f7f499b55fdb79861c0641450444e7d0":["a0cf46558b3f7708ed3a21e174b9e11cd30e26be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b374d78db8148ec6796fdf37148b33897ab40a8c":["212912761d471e5bfe06cf8027bad27e60a37695"],"ad1168477e46f783205c6fb94c21c32307926814":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"bd7a2b4785d366164d3cd69f9948de6ff34d23a1":["28288370235ed02234a64753cdbf0c6ec096304a"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["938fe8fd4d30ae70161827366f67c2382985e446"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["e9017cf144952056066919f1ebc7897ff9bd71b1","d301cb76d81de80d07b44735622a04d49ed938eb"],"212912761d471e5bfe06cf8027bad27e60a37695":["c26f00b574427b55127e869b935845554afde1fa"],"d528fd7ae22865015b756e0a03832e2051de2a9c":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"28288370235ed02234a64753cdbf0c6ec096304a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3","d528fd7ae22865015b756e0a03832e2051de2a9c"],"f763a1acdb27217b4799d1ca51c816739835a3e0":["d275f25d46bec8d215cc9d810169af5bf57ff35a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"2d629ca62e3b8ab6e29a127aebe213163d490413":["85032ab568b3f50eabd577aaa994ba197db93758"],"938fe8fd4d30ae70161827366f67c2382985e446":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a837c064b67fa63a9394136e31218b908cdcf783":["ad1168477e46f783205c6fb94c21c32307926814"],"85032ab568b3f50eabd577aaa994ba197db93758":["f763a1acdb27217b4799d1ca51c816739835a3e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e451e492cce54699988e2ce0aea55e3ff170cb0"]},"commit2Childs":{"9efa9c0fcd87863d1a86eed29d4304c11bc7d50a":["6240b74b884c5587f2a4062dd27d6c32bf228889","2668c99990e4c94a78bac005aa682b7c5986d23a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce":["37a0f60745e53927c4c876cfe5b5a58170f0646c","86184cf8c7654ee1badea2a629b8bc0487c7f690"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce"],"d275f25d46bec8d215cc9d810169af5bf57ff35a":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","f763a1acdb27217b4799d1ca51c816739835a3e0"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["936cdd5882761db3b844afd6f84ab81cbb011a75"],"359aab8d0284ad77917fc39712289950b39edbec":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"ab17cf116fd02ca93b83a5e65b242da418ec1181":["a0cf46558b3f7708ed3a21e174b9e11cd30e26be"],"d6b4b8d3d62eadaf42f3c2c0a23230275892d374":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"004ec9e26487ae9b6205e790f8f77ef5e98d8daf":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a"],"a0cf46558b3f7708ed3a21e174b9e11cd30e26be":["3278df77f7f499b55fdb79861c0641450444e7d0"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["74aea047dff7f7c38a2d766827bd20d356f98c6a","28288370235ed02234a64753cdbf0c6ec096304a","a513b6a92751e54c76fb5447948c9e7d437163a7"],"d301cb76d81de80d07b44735622a04d49ed938eb":["9efa9c0fcd87863d1a86eed29d4304c11bc7d50a","004ec9e26487ae9b6205e790f8f77ef5e98d8daf","936cdd5882761db3b844afd6f84ab81cbb011a75"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"86184cf8c7654ee1badea2a629b8bc0487c7f690":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d275f25d46bec8d215cc9d810169af5bf57ff35a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"49998598398261debaeb6b3e59d6e06bec3c1ffd":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["ab17cf116fd02ca93b83a5e65b242da418ec1181"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"c26f00b574427b55127e869b935845554afde1fa":["212912761d471e5bfe06cf8027bad27e60a37695"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ad1168477e46f783205c6fb94c21c32307926814"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["938fe8fd4d30ae70161827366f67c2382985e446"],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["d528fd7ae22865015b756e0a03832e2051de2a9c"],"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3":["0158ced21948b6626f733c1c42c1e18d94449789","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"9409650933cc688e77e565092a25e58adfc2e18d":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3278df77f7f499b55fdb79861c0641450444e7d0":["9409650933cc688e77e565092a25e58adfc2e18d"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["d6b4b8d3d62eadaf42f3c2c0a23230275892d374","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"ad1168477e46f783205c6fb94c21c32307926814":["c4015cd39dff8d4dec562d909f9766debac53aa6","a837c064b67fa63a9394136e31218b908cdcf783"],"bd7a2b4785d366164d3cd69f9948de6ff34d23a1":["d301cb76d81de80d07b44735622a04d49ed938eb"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"212912761d471e5bfe06cf8027bad27e60a37695":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"d528fd7ae22865015b756e0a03832e2051de2a9c":["359aab8d0284ad77917fc39712289950b39edbec","49998598398261debaeb6b3e59d6e06bec3c1ffd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"28288370235ed02234a64753cdbf0c6ec096304a":["d301cb76d81de80d07b44735622a04d49ed938eb","bd7a2b4785d366164d3cd69f9948de6ff34d23a1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"f763a1acdb27217b4799d1ca51c816739835a3e0":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","85032ab568b3f50eabd577aaa994ba197db93758"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"2d629ca62e3b8ab6e29a127aebe213163d490413":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"938fe8fd4d30ae70161827366f67c2382985e446":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a837c064b67fa63a9394136e31218b908cdcf783":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"85032ab568b3f50eabd577aaa994ba197db93758":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6240b74b884c5587f2a4062dd27d6c32bf228889","74f45af4339b0daf7a95c820ab88c1aea74fbce0","c4015cd39dff8d4dec562d909f9766debac53aa6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}