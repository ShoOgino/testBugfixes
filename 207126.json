{"path":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","commits":[{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"/dev/null","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.DOC_VALUES), false);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4681a68f42605af5014dd08a03a253e804a4d80"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4af732a9bb4cfe62634ba159e581c6eb45ceb280","date":1323232497,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.DOC_VALUES), false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4681a68f42605af5014dd08a03a253e804a4d80","date":1323260341,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.DOC_VALUES), false);\n      }\n    }\n  }\n\n","bugFix":["06584e6e98d592b34e1329b384182f368d2025e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23c3a6c2ecb0c99396936e72e8998df877ea9ad5","date":1323268151,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          IndexDocValues docValues = reader.docValues(dvName);\n          merged.setDocValues(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValues(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValues() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValues(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054","date":1323283758,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.DOC_VALUES), false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05","date":1323284809,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          IndexDocValues docValues = reader.docValues(dvName);\n          merged.setDocValuesType(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          IndexDocValues docValues = reader.docValues(dvName);\n          merged.setDocValues(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValues(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValues() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValues(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          DocValues docValues = reader.docValues(dvName);\n          merged.setDocValuesType(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          IndexDocValues docValues = reader.docValues(dvName);\n          merged.setDocValuesType(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          DocValues docValues = reader.docValues(dvName);\n          merged.setDocValuesType(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          mergeState.fieldInfos.add(fi);\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06","date":1326148180,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fi : readerFieldInfos) {\n        FieldInfo merged = mergeState.fieldInfos.add(fi);\n        // update the type promotion mapping for this reader\n        if (fi.hasDocValues()) {\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      if (reader instanceof SegmentReader) {\n        SegmentReader segmentReader = (SegmentReader) reader;\n        FieldInfos readerFieldInfos = segmentReader.fieldInfos();\n        for (FieldInfo fi : readerFieldInfos) {\n          FieldInfo merged = mergeState.fieldInfos.add(fi);\n          // update the type promotion mapping for this reader\n          if (fi.hasDocValues()) {\n            TypePromoter previous = docValuesTypes.get(merged);\n            docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n          }\n        }\n      } else {\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);\n        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);\n        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);\n        mergeState.fieldInfos.addOrUpdate(dvNames, false);\n        for (String dvName : dvNames) {\n          FieldInfo merged = mergeState.fieldInfos.fieldInfo(dvName);\n          DocValues docValues = reader.docValues(dvName);\n          merged.setDocValuesType(docValues.type());\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, docValues));\n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e8d5a6ffbfa3405d234a87c833741eabed98d13","date":1326725835,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    mergeDocValuesAndNormsFieldInfos();\n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat()\n        .getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    // mapping from all docvalues fields found to their promoted types\n    // this is because FieldInfos does not store the valueSize\n    Map<FieldInfo,TypePromoter> docValuesTypes = new HashMap<FieldInfo,TypePromoter>();\n\n    for (MergeState.IndexReaderAndLiveDocs readerAndLiveDocs : mergeState.readers) {\n      final IndexReader reader = readerAndLiveDocs.reader;\n      FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fi : readerFieldInfos) {\n        FieldInfo merged = mergeState.fieldInfos.add(fi);\n        // update the type promotion mapping for this reader\n        if (fi.hasDocValues()) {\n          TypePromoter previous = docValuesTypes.get(merged);\n          docValuesTypes.put(merged, mergeDocValuesType(previous, reader.docValues(fi.name))); \n        }\n      }\n    }\n    \n    // update any promoted doc values types:\n    for (Map.Entry<FieldInfo,TypePromoter> e : docValuesTypes.entrySet()) {\n      FieldInfo fi = e.getKey();\n      TypePromoter promoter = e.getValue();\n      if (promoter == null) {\n        fi.resetDocValuesType(null);\n      } else {\n        assert promoter != TypePromoter.getIdentityPromoter();\n        if (fi.getDocValuesType() != promoter.type()) {\n          // reset the type if we got promoted\n          fi.resetDocValuesType(promoter.type());\n        }\n      }\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeFieldInfos().mjava","sourceNew":"  private void mergeFieldInfos() throws IOException {\n    mergeDocValuesAndNormsFieldInfos();\n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat()\n        .getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","sourceOld":"  private void mergeFieldInfos() throws IOException {\n    mergeDocValuesAndNormsFieldInfos();\n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat()\n        .getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"d4681a68f42605af5014dd08a03a253e804a4d80":["06584e6e98d592b34e1329b384182f368d2025e8"],"06584e6e98d592b34e1329b384182f368d2025e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4af732a9bb4cfe62634ba159e581c6eb45ceb280":["06584e6e98d592b34e1329b384182f368d2025e8"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["d4681a68f42605af5014dd08a03a253e804a4d80","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"9e8d5a6ffbfa3405d234a87c833741eabed98d13":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054":["06584e6e98d592b34e1329b384182f368d2025e8","d4681a68f42605af5014dd08a03a253e804a4d80"],"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["23c3a6c2ecb0c99396936e72e8998df877ea9ad5"],"23c3a6c2ecb0c99396936e72e8998df877ea9ad5":["4af732a9bb4cfe62634ba159e581c6eb45ceb280"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4681a68f42605af5014dd08a03a253e804a4d80":["d638301ad1cfcae567b681b893bc8781f0ee48a5","69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054"],"06584e6e98d592b34e1329b384182f368d2025e8":["d4681a68f42605af5014dd08a03a253e804a4d80","4af732a9bb4cfe62634ba159e581c6eb45ceb280","69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054"],"4af732a9bb4cfe62634ba159e581c6eb45ceb280":["23c3a6c2ecb0c99396936e72e8998df877ea9ad5"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["3321cfbf7f8aba27e37e7a4d6901531a97ac2b06"],"9e8d5a6ffbfa3405d234a87c833741eabed98d13":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06584e6e98d592b34e1329b384182f368d2025e8"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054":[],"3321cfbf7f8aba27e37e7a4d6901531a97ac2b06":["9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"23c3a6c2ecb0c99396936e72e8998df877ea9ad5":["ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["69e6e5a85de57ea8b642c0b8c9e15a2d7d2d0054","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}