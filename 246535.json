{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","commits":[{"id":"77aad0f26236c97028aecb0fcc76de2b13edf1a0","date":1441298393,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","pathOld":"/dev/null","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54","date":1446047031,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe","date":1452379366,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3088cdaa24ffe3ef44713ac9484114bd56eca2af","date":1453441194,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.forceUpdateCollection(collectionName);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bf3bb51868790b9ae23c224583047716308a017","date":1473233468,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":null,"sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.forceUpdateCollection(collectionName);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":null,"sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.forceUpdateCollection(collectionName);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":null,"sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.forceUpdateCollection(collectionName);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterBase#testCollectionCreateSearchDelete(String).mjava","sourceNew":null,"sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n            cloudSolrClient);\n        assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n           ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.forceUpdateCollection(collectionName);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n\n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3bf3bb51868790b9ae23c224583047716308a017":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe"],"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","89424def13674ea17829b41c5883c54ecc31a132"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["77aad0f26236c97028aecb0fcc76de2b13edf1a0"],"77aad0f26236c97028aecb0fcc76de2b13edf1a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"89424def13674ea17829b41c5883c54ecc31a132":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","3bf3bb51868790b9ae23c224583047716308a017"]},"commit2Childs":{"3bf3bb51868790b9ae23c224583047716308a017":["89424def13674ea17829b41c5883c54ecc31a132"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["77aad0f26236c97028aecb0fcc76de2b13edf1a0"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe"],"77aad0f26236c97028aecb0fcc76de2b13edf1a0":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["3bf3bb51868790b9ae23c224583047716308a017","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}