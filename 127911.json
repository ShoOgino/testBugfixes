{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","commits":[{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"/dev/null","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // get a global number for this field\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          DocValuesType currentDVType = fi.getDocValuesType();\n          if (currentDVType == null) {\n            fi.setDocValuesType(docValues);\n          } else if (currentDVType != docValues) {\n            throw new IllegalArgumentException(\"cannot change DocValues type from \" + currentDVType + \" to \" + docValues + \" for field \\\"\" + name + \"\\\"\");\n          }\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          DocValuesType currentDVType = fi.getNormType();\n          if (currentDVType == null) {\n            fi.setNormValueType(docValues);\n          } else if (currentDVType != normType) {\n            throw new IllegalArgumentException(\"cannot change Norm type from \" + currentDVType + \" to \" + normType + \" for field \\\"\" + name + \"\\\"\");\n          }\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"552b8f2e274f44903adb7d9a00ef296674883ad2","date":1359422293,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // get a global number for this field\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // get a global number for this field\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          DocValuesType currentDVType = fi.getDocValuesType();\n          if (currentDVType == null) {\n            fi.setDocValuesType(docValues);\n          } else if (currentDVType != docValues) {\n            throw new IllegalArgumentException(\"cannot change DocValues type from \" + currentDVType + \" to \" + docValues + \" for field \\\"\" + name + \"\\\"\");\n          }\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          DocValuesType currentDVType = fi.getNormType();\n          if (currentDVType == null) {\n            fi.setNormValueType(docValues);\n          } else if (currentDVType != normType) {\n            throw new IllegalArgumentException(\"cannot change Norm type from \" + currentDVType + \" to \" + normType + \" for field \\\"\" + name + \"\\\"\");\n          }\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50110fe9088380a4f557899cce4a52f1257c8494","date":1359751675,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // get a global number for this field\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":["ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"/dev/null","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38ce5b474ddbd109acee85ba3a311201df474822","date":1377775364,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n          // must also update docValuesType map so it's aware of this field's DocValueType \n          globalFieldNumbers.docValuesType.put(name, docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b","date":1377860967,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n          // must also update docValuesType map so it's aware of this field's DocValueType \n          globalFieldNumbers.docValuesType.put(name, docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":["38ce5b474ddbd109acee85ba3a311201df474822","0837ab0472feecb3a54260729d845f839e1cbd72"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          fi.setDocValuesType(docValues);\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71","date":1400675008,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":["50110fe9088380a4f557899cce4a52f1257c8494"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71","05da2d758a6089e737cdfc230e57a51b472b94b6"],"38ce5b474ddbd109acee85ba3a311201df474822":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b"],"aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b":["38ce5b474ddbd109acee85ba3a311201df474822"],"b7605579001505896d48b07160075a5c8b8e128e":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"552b8f2e274f44903adb7d9a00ef296674883ad2":["0837ab0472feecb3a54260729d845f839e1cbd72"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","50110fe9088380a4f557899cce4a52f1257c8494"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"0837ab0472feecb3a54260729d845f839e1cbd72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"50110fe9088380a4f557899cce4a52f1257c8494":["552b8f2e274f44903adb7d9a00ef296674883ad2"],"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["05da2d758a6089e737cdfc230e57a51b472b94b6"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":[],"38ce5b474ddbd109acee85ba3a311201df474822":["aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"aaa86402ba0af2f3b16f9dcdc836c27130e8fc4b":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"b7605579001505896d48b07160075a5c8b8e128e":[],"552b8f2e274f44903adb7d9a00ef296674883ad2":["50110fe9088380a4f557899cce4a52f1257c8494"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["38ce5b474ddbd109acee85ba3a311201df474822","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4d69c535930b5cce125cff868d40f6373dc27d4","0837ab0472feecb3a54260729d845f839e1cbd72"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["552b8f2e274f44903adb7d9a00ef296674883ad2"],"50110fe9088380a4f557899cce4a52f1257c8494":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}