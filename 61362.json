{"path":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","date":1327846543,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicIndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicIndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicIndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6d5ac19a80d65b1e864251f155d30960353b7e","date":1327881054,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicIndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicIndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicIndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["7b91922b55d15444d554721b352861d028eb8278"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["7b91922b55d15444d554721b352861d028eb8278","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["0e7c2454a6a8237bfd0e953f5b940838408c9055","da6d5ac19a80d65b1e864251f155d30960353b7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}