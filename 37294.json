{"path":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    DocValuesField groupDc = new DocValuesField(\"group\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new DocValuesField(\"facet\", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":["8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = !\"Lucene3x\".equals(writer.w.getConfig().getCodec().getName());\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newField(\"facet\", \"\", StringField.TYPE_UNSTORED);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newField(\"content\", \"\", StringField.TYPE_UNSTORED);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":["8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2","369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"854f97cd3613b9579fba83755c80b697e2f3993f","date":1353527621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46bf1a48fd33bf34430ade646b7dd67b984be2a8","date":1358725746,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedBytesDocValuesField(\"group\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedBytesDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = null;\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","8b89f8e2c44ce7efaf10978b9e5c6b95a31706b2","369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97d4692d0c601ff773f0a2231967312428a904e4","date":1366026608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<String>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<String>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<String>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d138de075f63ca3be0fce7c1404cd919229b277","date":1399829699,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    boolean canUseDV = true;\n    boolean useDv = canUseDV && !multipleFacetValuesPerDocument && random.nextBoolean();\n\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group_dv\", new BytesRef());\n    if (useDv) {\n      doc.add(groupDc);\n      docNoFacet.add(groupDc);\n    }\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (useDv) {\n      assert !multipleFacetValuesPerDocument;\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet_dv\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = newStringField(\"facet\", \"\", Field.Store.NO);\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        if (useDv) {\n          groupValue = \"\";\n        } else {\n          groupValue = null;\n        }\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (useDv || random.nextInt(24) != 18) {\n        if (useDv) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetFields[0].setStringValue(facetValue);\n          facetFields[1].setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        } else {\n          for (Field facetField : facetFields) {\n            String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n            uniqueFacetValues.add(facetValue);\n            if (!facetToGroups.containsKey(facetValue)) {\n              facetToGroups.put(facetValue, new HashSet<String>());\n            }\n            Set<String> groupsInFacet = facetToGroups.get(facetValue);\n            groupsInFacet.add(groupValue);\n            if (groupsInFacet.size() > facetWithMostGroups) {\n              facetWithMostGroups = groupsInFacet.size();\n            }\n            facetField.setStringValue(facetValue);\n            facetVals.add(facetValue);\n          }\n        }\n      } else {\n        uniqueFacetValues.add(null);\n        if (!facetToGroups.containsKey(null)) {\n          facetToGroups.put(null, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(null);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        if (useDv) {\n          groupDc.setBytesValue(new BytesRef(groupValue));\n        }\n        group.setStringValue(groupValue);\n      } else if (useDv) {\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random))\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(\n            TEST_VERSION_CURRENT,\n            new MockAnalyzer(random)\n        )\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest#createIndexContext(boolean).mjava","sourceNew":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random))\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.close();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","sourceOld":"  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {\n    final Random random = random();\n    final int numDocs = TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;\n    final int numGroups = TestUtil.nextInt(random, 1, numDocs / 4);\n    final int numFacets = TestUtil.nextInt(random, 1, numDocs / 6);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n    }\n\n    final List<String> groups = new ArrayList<>();\n    for (int i = 0; i < numGroups; i++) {\n      groups.add(generateRandomNonEmptyString());\n    }\n    final List<String> facetValues = new ArrayList<>();\n    for (int i = 0; i < numFacets; i++) {\n      facetValues.add(generateRandomNonEmptyString());\n    }\n    final String[] contentBrs = new String[TestUtil.nextInt(random, 2, 20)];\n    if (VERBOSE) {\n      System.out.println(\"TEST: create fake content\");\n    }\n    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {\n      contentBrs[contentIDX] = generateRandomNonEmptyString();\n      if (VERBOSE) {\n        System.out.println(\"  content=\" + contentBrs[contentIDX]);\n      }\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random))\n    );\n    Document doc = new Document();\n    Document docNoGroup = new Document();\n    Document docNoFacet = new Document();\n    Document docNoGroupNoFacet = new Document();\n    Field group = newStringField(\"group\", \"\", Field.Store.NO);\n    Field groupDc = new SortedDocValuesField(\"group\", new BytesRef());\n    doc.add(groupDc);\n    docNoFacet.add(groupDc);\n    doc.add(group);\n    docNoFacet.add(group);\n    Field[] facetFields;\n    if (multipleFacetValuesPerDocument == false) {\n      facetFields = new Field[2];\n      facetFields[0] = newStringField(\"facet\", \"\", Field.Store.NO);\n      doc.add(facetFields[0]);\n      docNoGroup.add(facetFields[0]);\n      facetFields[1] = new SortedDocValuesField(\"facet\", new BytesRef());\n      doc.add(facetFields[1]);\n      docNoGroup.add(facetFields[1]);\n    } else {\n      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];\n      for (int i = 0; i < facetFields.length; i++) {\n        facetFields[i] = new SortedSetDocValuesField(\"facet\", new BytesRef());\n        doc.add(facetFields[i]);\n        docNoGroup.add(facetFields[i]);\n      }\n    }\n    Field content = newStringField(\"content\", \"\", Field.Store.NO);\n    doc.add(content);\n    docNoGroup.add(content);\n    docNoFacet.add(content);\n    docNoGroupNoFacet.add(content);\n\n    NavigableSet<String> uniqueFacetValues = new TreeSet<>(new Comparator<String>() {\n\n      @Override\n      public int compare(String a, String b) {\n        if (a == b) {\n          return 0;\n        } else if (a == null) {\n          return -1;\n        } else if (b == null) {\n          return 1;\n        } else {\n          return a.compareTo(b);\n        }\n      }\n\n    });\n    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<>();\n    int facetWithMostGroups = 0;\n    for (int i = 0; i < numDocs; i++) {\n      final String groupValue;\n      if (random.nextInt(24) == 17) {\n        // So we test the \"doc doesn't have the group'd\n        // field\" case:\n        groupValue = \"\";\n      } else {\n        groupValue = groups.get(random.nextInt(groups.size()));\n      }\n\n      String contentStr = contentBrs[random.nextInt(contentBrs.length)];\n      if (!searchTermToFacetToGroups.containsKey(contentStr)) {\n        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());\n      }\n      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);\n\n      List<String> facetVals = new ArrayList<>();\n      if (multipleFacetValuesPerDocument == false) {\n        String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n        uniqueFacetValues.add(facetValue);\n        if (!facetToGroups.containsKey(facetValue)) {\n          facetToGroups.put(facetValue, new HashSet<String>());\n        }\n        Set<String> groupsInFacet = facetToGroups.get(facetValue);\n        groupsInFacet.add(groupValue);\n        if (groupsInFacet.size() > facetWithMostGroups) {\n          facetWithMostGroups = groupsInFacet.size();\n        }\n        facetFields[0].setStringValue(facetValue);\n        facetFields[1].setBytesValue(new BytesRef(facetValue));\n        facetVals.add(facetValue);\n      } else {\n        for (Field facetField : facetFields) {\n          String facetValue = facetValues.get(random.nextInt(facetValues.size()));\n          uniqueFacetValues.add(facetValue);\n          if (!facetToGroups.containsKey(facetValue)) {\n            facetToGroups.put(facetValue, new HashSet<String>());\n          }\n          Set<String> groupsInFacet = facetToGroups.get(facetValue);\n          groupsInFacet.add(groupValue);\n          if (groupsInFacet.size() > facetWithMostGroups) {\n            facetWithMostGroups = groupsInFacet.size();\n          }\n          facetField.setBytesValue(new BytesRef(facetValue));\n          facetVals.add(facetValue);\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  doc content=\" + contentStr + \" group=\" + (groupValue == null ? \"null\" : groupValue) + \" facetVals=\" + facetVals);\n      }\n\n      if (groupValue != null) {\n        groupDc.setBytesValue(new BytesRef(groupValue));\n        group.setStringValue(groupValue);\n      } else {\n        // TODO: not true\n        // DV cannot have missing values:\n        groupDc.setBytesValue(new BytesRef());\n      }\n      content.setStringValue(contentStr);\n      if (groupValue == null && facetVals.isEmpty()) {\n        writer.addDocument(docNoGroupNoFacet);\n      } else if (facetVals.isEmpty()) {\n        writer.addDocument(docNoFacet);\n      } else if (groupValue == null) {\n        writer.addDocument(docNoGroup);\n      } else {\n        writer.addDocument(doc);\n      }\n    }\n\n    DirectoryReader reader = writer.getReader();\n    writer.shutdown();\n\n    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["854f97cd3613b9579fba83755c80b697e2f3993f","7530de27b87b961b51f01bd1299b7004d46e8823"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"1d138de075f63ca3be0fce7c1404cd919229b277":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["97d4692d0c601ff773f0a2231967312428a904e4"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"46bf1a48fd33bf34430ade646b7dd67b984be2a8":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["7530de27b87b961b51f01bd1299b7004d46e8823","423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","1d138de075f63ca3be0fce7c1404cd919229b277"],"97d4692d0c601ff773f0a2231967312428a904e4":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["46bf1a48fd33bf34430ade646b7dd67b984be2a8"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"854f97cd3613b9579fba83755c80b697e2f3993f":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0ef034a4f10871667ae75181537775ddcf8ade4"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["46bf1a48fd33bf34430ade646b7dd67b984be2a8"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"1d138de075f63ca3be0fce7c1404cd919229b277":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"04f07771a2a7dd3a395700665ed839c3dae2def2":["854f97cd3613b9579fba83755c80b697e2f3993f","7530de27b87b961b51f01bd1299b7004d46e8823"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"46bf1a48fd33bf34430ade646b7dd67b984be2a8":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["97d4692d0c601ff773f0a2231967312428a904e4"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","56572ec06f1407c066d6b7399413178b33176cd8"],"97d4692d0c601ff773f0a2231967312428a904e4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["1d138de075f63ca3be0fce7c1404cd919229b277","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"854f97cd3613b9579fba83755c80b697e2f3993f":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}