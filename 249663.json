{"path":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","commits":[{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashConsumerPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashConsumerPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashConsumerPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.getDocCount();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a0a50d2d14aaee1e635bbec914468551f7f9a2","date":1482234306,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState,Sorter.DocMap).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state, Sorter.DocMap sortMap) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumer#flush(Map[String,TermsHashPerField],SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  @Override\n  void flush(Map<String, TermsHashPerField> fieldsToFlush, final SegmentWriteState state) throws IOException {\n    if (writer != null) {\n      int numDocs = state.segmentInfo.maxDoc();\n      assert numDocs > 0;\n      // At least one doc in this run had term vectors enabled\n      try {\n        fill(numDocs);\n        assert state.segmentInfo != null;\n        writer.finish(state.fieldInfos, numDocs);\n      } finally {\n        IOUtils.close(writer);\n        writer = null;\n        lastDocID = 0;\n        hasVectors = false;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3394716f52b34ab259ad5247e7595d9f9db6e935":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","52c7e49be259508735752fba88085255014a6ecf"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["3394716f52b34ab259ad5247e7595d9f9db6e935","b0267c69e2456a3477a1ad785723f2135da3117e"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3394716f52b34ab259ad5247e7595d9f9db6e935"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["b0267c69e2456a3477a1ad785723f2135da3117e","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"b06445ae1731e049327712db0454e5643ca9b7fe":["3394716f52b34ab259ad5247e7595d9f9db6e935","b0267c69e2456a3477a1ad785723f2135da3117e"],"b0267c69e2456a3477a1ad785723f2135da3117e":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["b0267c69e2456a3477a1ad785723f2135da3117e"],"52c7e49be259508735752fba88085255014a6ecf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86a0a50d2d14aaee1e635bbec914468551f7f9a2"]},"commit2Childs":{"3394716f52b34ab259ad5247e7595d9f9db6e935":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","b06445ae1731e049327712db0454e5643ca9b7fe","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3394716f52b34ab259ad5247e7595d9f9db6e935","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","52c7e49be259508735752fba88085255014a6ecf"],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b06445ae1731e049327712db0454e5643ca9b7fe","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b06445ae1731e049327712db0454e5643ca9b7fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}