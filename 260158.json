{"path":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","commits":[{"id":"5270fb4f55a1b77663dda53cb8090c083f0a23b3","date":1305050821,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"/dev/null","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        //nocommit is IOContext.DEFAULT the right thing to do here?\n        final SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          //nocommit is IOContext.DEFAULT the right thing to do here?\n          SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          //nocommit is IOContext.DEFAULT the right thing to do here?\n          SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        //nocommit is IOContext.DEFAULT the right thing to do here?\n        final SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          //nocommit is IOContext.DEFAULT the right thing to do here?\n          SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c162b4b9ef005383c38e0912c16267584dc40de5","date":1310021443,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          //nocommit is IOContext.DEFAULT the right thing to do here?\n          SegmentReader reader = readerPool.get(info, false, IOContext.DEFAULT);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2","date":1311898374,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream != null) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream != null) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader, IOContext.Context.READ);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false, IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader, IOContext.Context.READ);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01cb549dce822ce8a82b6ce2754b5a63181a44ca","date":1326996973,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccad4bab070f323ce610caa0040346d4a87213dc","date":1327747432,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31","date":1327836826,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["06584e6e98d592b34e1329b384182f368d2025e8"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"06584e6e98d592b34e1329b384182f368d2025e8":["9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["9ce667c6d3400b22523701c549c0d35e26da8b46","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["c162b4b9ef005383c38e0912c16267584dc40de5","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a3776dccca01c11e7046323cfad46a3b4a471233","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"01cb549dce822ce8a82b6ce2754b5a63181a44ca":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"c162b4b9ef005383c38e0912c16267584dc40de5":["b6f9be74ca7baaef11857ad002cad40419979516"],"9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["817d8435e9135b756f08ce6710ab0baac51bdf88","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["9ce667c6d3400b22523701c549c0d35e26da8b46","ccad4bab070f323ce610caa0040346d4a87213dc"],"ccad4bab070f323ce610caa0040346d4a87213dc":["01cb549dce822ce8a82b6ce2754b5a63181a44ca"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2"],"06584e6e98d592b34e1329b384182f368d2025e8":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"01cb549dce822ce8a82b6ce2754b5a63181a44ca":["ccad4bab070f323ce610caa0040346d4a87213dc"],"c162b4b9ef005383c38e0912c16267584dc40de5":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2":["06584e6e98d592b34e1329b384182f368d2025e8"],"a3776dccca01c11e7046323cfad46a3b4a471233":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5270fb4f55a1b77663dda53cb8090c083f0a23b3","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"b6f9be74ca7baaef11857ad002cad40419979516":["c162b4b9ef005383c38e0912c16267584dc40de5"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fd92b8bcc88e969302510acf77bd6970da3994c4"],"ccad4bab070f323ce610caa0040346d4a87213dc":["c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["fd92b8bcc88e969302510acf77bd6970da3994c4","01cb549dce822ce8a82b6ce2754b5a63181a44ca","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","5d004d0e0b3f65bb40da76d476d659d7888270e8","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}