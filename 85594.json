{"path":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","commits":[{"id":"b566f203e5d31fbdd07a258540e841abaaf52bcc","date":1227879002,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String field = params.get(TermsParams.TERMS_FIELD);\n      if (field != null) {\n        Term lowerTerm = new Term(field, lower);\n        TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        int i = 0;\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        Term upperTerm = upper != null ? new Term(field, upper) : null;\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean hasMore = true;\n        if (lowerIncl == false) {\n          hasMore = termEnum.next();\n        }\n        if (hasMore == true) {\n          do {\n            Term theTerm = termEnum.term();\n            String theText = theTerm.text();\n            int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n            if (theTerm != null && theTerm.field().equals(field)\n                    && ((upperIncl == true && upperCmp <= 0) ||\n                    (upperIncl == false && upperCmp < 0))) {\n              terms.add(theText, String.valueOf(termEnum.docFreq()));\n            } else {//we're done\n              break;\n            }\n            i++;\n          }\n          while (i < rows && termEnum.next());\n        }\n        termEnum.close();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bc5a8a11b89d99d34540a17eed8d994f640c3d7","date":1227891189,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String field = params.get(TermsParams.TERMS_FIELD);\n      if (field != null) {\n        Term lowerTerm = new Term(field, lower);\n        TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        int i = 0;\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        Term upperTerm = upper != null ? new Term(field, upper) : null;\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean hasMore = true;\n        if (lowerIncl == false) {\n          hasMore = termEnum.next();\n        }\n        if (hasMore == true) {\n          do {\n            Term theTerm = termEnum.term();\n            String theText = theTerm.text();\n            int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n            if (theTerm != null && theTerm.field().equals(field)\n                    && ((upperIncl == true && upperCmp <= 0) ||\n                    (upperIncl == false && upperCmp < 0))) {\n              terms.add(theText, termEnum.docFreq());\n            } else {//we're done\n              break;\n            }\n            i++;\n          }\n          while (i < rows && termEnum.next());\n        }\n        termEnum.close();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String field = params.get(TermsParams.TERMS_FIELD);\n      if (field != null) {\n        Term lowerTerm = new Term(field, lower);\n        TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        int i = 0;\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        Term upperTerm = upper != null ? new Term(field, upper) : null;\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean hasMore = true;\n        if (lowerIncl == false) {\n          hasMore = termEnum.next();\n        }\n        if (hasMore == true) {\n          do {\n            Term theTerm = termEnum.term();\n            String theText = theTerm.text();\n            int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n            if (theTerm != null && theTerm.field().equals(field)\n                    && ((upperIncl == true && upperCmp <= 0) ||\n                    (upperIncl == false && upperCmp < 0))) {\n              terms.add(theText, String.valueOf(termEnum.docFreq()));\n            } else {//we're done\n              break;\n            }\n            i++;\n          }\n          while (i < rows && termEnum.next());\n        }\n        termEnum.close();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9826f1e89aa6389d20cb52f7f7ca7454c66ab676","date":1227962457,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          String upper = params.get(TermsParams.TERMS_UPPER);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n          boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n          boolean hasMore = true;\n          if (lowerIncl == false) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))) {\n                fieldTerms.add(theText, termEnum.docFreq());\n              } else {//we're done\n                break;\n              }\n              i++;\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String field = params.get(TermsParams.TERMS_FIELD);\n      if (field != null) {\n        Term lowerTerm = new Term(field, lower);\n        TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        int i = 0;\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        Term upperTerm = upper != null ? new Term(field, upper) : null;\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean hasMore = true;\n        if (lowerIncl == false) {\n          hasMore = termEnum.next();\n        }\n        if (hasMore == true) {\n          do {\n            Term theTerm = termEnum.term();\n            String theText = theTerm.text();\n            int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n            if (theTerm != null && theTerm.field().equals(field)\n                    && ((upperIncl == true && upperCmp <= 0) ||\n                    (upperIncl == false && upperCmp < 0))) {\n              terms.add(theText, termEnum.docFreq());\n            } else {//we're done\n              break;\n            }\n            i++;\n          }\n          while (i < rows && termEnum.next());\n        }\n        termEnum.close();\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8735269939bbb2e67365b93dac83a85bf21a345","date":1227966716,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        if (rows < 0){\n          rows = Integer.MAX_VALUE;\n        }\n\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || theText.startsWith(prefix))\n                      ) {\n                fieldTerms.add(theText, termEnum.docFreq());\n              } else {//we're done\n                break;\n              }\n              i++;\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          String upper = params.get(TermsParams.TERMS_UPPER);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n          boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n          boolean hasMore = true;\n          if (lowerIncl == false) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))) {\n                fieldTerms.add(theText, termEnum.docFreq());\n              } else {//we're done\n                break;\n              }\n              i++;\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e63c913b8b0e2cc3c4f8994c4d976a664af7297","date":1228572582,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        if (rows < 0) {\n          rows = Integer.MAX_VALUE;\n        }\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || theText.startsWith(prefix))\n                      ) {\n                int docFreq = termEnum.docFreq();\n                if (docFreq >= freqmin && (freqmax == UNLIMITED_MAX_COUNT || (docFreq <= freqmax))) {\n                  fieldTerms.add(theText, docFreq);\n                  i++;\n                }\n              } else {//we're done\n                break;\n              }\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        if (rows < 0){\n          rows = Integer.MAX_VALUE;\n        }\n\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || theText.startsWith(prefix))\n                      ) {\n                fieldTerms.add(theText, termEnum.docFreq());\n              } else {//we're done\n                break;\n              }\n              i++;\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"725326303b39157323796ef620a9ad99eb185f11","date":1241874089,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (rows < 0) {\n          rows = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          String lower = lowerStr==null ? \"\" : ft.toInternal(lowerStr);\n          String upper = upperStr==null ? null : ft.toInternal(upperStr);\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String indexedText = theTerm.text();\n              String readableText = ft.indexedToReadable(indexedText);\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || readableText.startsWith(prefix))\n                      ) {\n                int docFreq = termEnum.docFreq();\n                if (docFreq >= freqmin && (freqmax == UNLIMITED_MAX_COUNT || (docFreq <= freqmax))) {\n                  fieldTerms.add(readableText, docFreq);\n                  i++;\n                }\n              } else {//we're done\n                break;\n              }\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lower = params.get(TermsParams.TERMS_LOWER, \"\");\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_ROWS, params.getInt(CommonParams.ROWS, 10));\n        if (rows < 0) {\n          rows = Integer.MAX_VALUE;\n        }\n        String upper = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String theText = theTerm.text();\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || theText.startsWith(prefix))\n                      ) {\n                int docFreq = termEnum.docFreq();\n                if (docFreq >= freqmin && (freqmax == UNLIMITED_MAX_COUNT || (docFreq <= freqmax))) {\n                  fieldTerms.add(theText, docFreq);\n                  i++;\n                }\n              } else {//we're done\n                break;\n              }\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c187751aedf55353d45d0c4b91d819ea3be5cc9","date":1241918954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j].intern();\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              fieldTerms.add(label, docFreq);\n              i++;\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int rows = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (rows < 0) {\n          rows = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j];\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          String lower = lowerStr==null ? \"\" : ft.toInternal(lowerStr);\n          String upper = upperStr==null ? null : ft.toInternal(upperStr);\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper != null ? new Term(field, upper) : null;\n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm);//this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          boolean hasMore = true;\n          Term lowerTestTerm = termEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && lowerTestTerm.field().equals(field) == true && lowerTestTerm.text().equals(lower)) {\n            hasMore = termEnum.next();\n          }\n          if (hasMore == true) {\n            do {\n              Term theTerm = termEnum.term();\n              String indexedText = theTerm.text();\n              String readableText = ft.indexedToReadable(indexedText);\n              int upperCmp = upperTerm != null ? theTerm.compareTo(upperTerm) : -1;\n              if (theTerm != null && theTerm.field().equals(field)\n                      && ((upperIncl == true && upperCmp <= 0) ||\n                      (upperIncl == false && upperCmp < 0))\n                      && (prefix == null || readableText.startsWith(prefix))\n                      ) {\n                int docFreq = termEnum.docFreq();\n                if (docFreq >= freqmin && (freqmax == UNLIMITED_MAX_COUNT || (docFreq <= freqmax))) {\n                  fieldTerms.add(readableText, docFreq);\n                  i++;\n                }\n              } else {//we're done\n                break;\n              }\n            }\n            while (i < rows && termEnum.next());\n          }\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ce664c39aec5f3a923284c202061999768425db","date":1249649666,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              fieldTerms.add(label, docFreq);\n              i++;\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = fields[j].intern();\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              fieldTerms.add(label, docFreq);\n              i++;\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67522804713e97a3b2085fc409aeb8abe67c304d","date":1251129392,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              fieldTerms.add(label, docFreq);\n              i++;\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f32b2ee79afc1b38d7aa7cba0cc0840e3a5bc3c","date":1260522208,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"8bc5a8a11b89d99d34540a17eed8d994f640c3d7":["b566f203e5d31fbdd07a258540e841abaaf52bcc"],"67522804713e97a3b2085fc409aeb8abe67c304d":["6ce664c39aec5f3a923284c202061999768425db"],"9826f1e89aa6389d20cb52f7f7ca7454c66ab676":["8bc5a8a11b89d99d34540a17eed8d994f640c3d7"],"b566f203e5d31fbdd07a258540e841abaaf52bcc":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"2f32b2ee79afc1b38d7aa7cba0cc0840e3a5bc3c":["67522804713e97a3b2085fc409aeb8abe67c304d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"725326303b39157323796ef620a9ad99eb185f11":["6e63c913b8b0e2cc3c4f8994c4d976a664af7297"],"9c187751aedf55353d45d0c4b91d819ea3be5cc9":["725326303b39157323796ef620a9ad99eb185f11"],"a8735269939bbb2e67365b93dac83a85bf21a345":["9826f1e89aa6389d20cb52f7f7ca7454c66ab676"],"ad94625fb8d088209f46650c8097196fec67f00c":["2f32b2ee79afc1b38d7aa7cba0cc0840e3a5bc3c"],"6e63c913b8b0e2cc3c4f8994c4d976a664af7297":["a8735269939bbb2e67365b93dac83a85bf21a345"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6ce664c39aec5f3a923284c202061999768425db":["9c187751aedf55353d45d0c4b91d819ea3be5cc9"]},"commit2Childs":{"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["b566f203e5d31fbdd07a258540e841abaaf52bcc"],"8bc5a8a11b89d99d34540a17eed8d994f640c3d7":["9826f1e89aa6389d20cb52f7f7ca7454c66ab676"],"67522804713e97a3b2085fc409aeb8abe67c304d":["2f32b2ee79afc1b38d7aa7cba0cc0840e3a5bc3c"],"9826f1e89aa6389d20cb52f7f7ca7454c66ab676":["a8735269939bbb2e67365b93dac83a85bf21a345"],"b566f203e5d31fbdd07a258540e841abaaf52bcc":["8bc5a8a11b89d99d34540a17eed8d994f640c3d7"],"2f32b2ee79afc1b38d7aa7cba0cc0840e3a5bc3c":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"725326303b39157323796ef620a9ad99eb185f11":["9c187751aedf55353d45d0c4b91d819ea3be5cc9"],"9c187751aedf55353d45d0c4b91d819ea3be5cc9":["6ce664c39aec5f3a923284c202061999768425db"],"a8735269939bbb2e67365b93dac83a85bf21a345":["6e63c913b8b0e2cc3c4f8994c4d976a664af7297"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"6e63c913b8b0e2cc3c4f8994c4d976a664af7297":["725326303b39157323796ef620a9ad99eb185f11"],"6ce664c39aec5f3a923284c202061999768425db":["67522804713e97a3b2085fc409aeb8abe67c304d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}