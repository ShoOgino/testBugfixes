{"path":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","commits":[{"id":"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0","date":1446511397,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //    \n    // ...as top level elements, with no other config options specified\n    \n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" + \n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n    \n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n    \n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n                              REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n                              DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n                              PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n                              \"' to be combined with other options.\");\n    }\n    \n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    \n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n                              \" is not a valid regex pattern: \" + patt, pe);\n      \n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(@SuppressWarnings({\"rawtypes\"})NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //    \n    // ...as top level elements, with no other config options specified\n    \n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" + \n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n    \n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n    \n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n                              REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n                              DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n                              PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n                              \"' to be combined with other options.\");\n    }\n    \n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    \n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n                              \" is not a valid regex pattern: \" + patt, pe);\n      \n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","sourceOld":"  /**\n   * init helper method that should only be called when we know for certain that both the \n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //    \n    // ...as top level elements, with no other config options specified\n    \n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" + \n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n    \n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n    \n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n                              REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n                              DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n                              PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n                              \"' to be combined with other options.\");\n    }\n    \n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    \n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n                              \" is not a valid regex pattern: \" + patt, pe);\n      \n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}