{"path":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","commits":[{"id":"e9e1499c5d26c936238506df90a3c02c76707722","date":1434449920,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public void add(Term term, int position) {\n      term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes())); // be defensive\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["860d9cc0c963b5c0db351fb0473b6894b1d96020","457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7","date":1438271815,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","sourceNew":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public Builder add(Term term, int position) {\n      term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes())); // be defensive\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","sourceOld":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public void add(Term term, int position) {\n      term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes())); // be defensive\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n    }\n\n","bugFix":["e9e1499c5d26c936238506df90a3c02c76707722"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38b5bd3ae837751f57f363e9a41b833794222814","date":1445342257,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","sourceNew":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public Builder add(Term term, int position) {\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","sourceOld":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public Builder add(Term term, int position) {\n      term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes())); // be defensive\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"860d9cc0c963b5c0db351fb0473b6894b1d96020","date":1448302628,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","sourceNew":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly, but must be greater than\n     * or equal to that of the previously added term.\n     * A greater position allows phrases with gaps (e.g. in connection with stopwords).\n     * If the position is equal, you most likely should be using\n     * {@link MultiPhraseQuery} instead which only requires one term at each position to match; this class requires\n     * all of them.\n     */\n    public Builder add(Term term, int position) {\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","sourceOld":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly.\n     * This allows e.g. phrases with more than one term at the same position\n     * or phrases with gaps (e.g. in connection with stopwords).\n     * \n     */\n    public Builder add(Term term, int position) {\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","bugFix":["e9e1499c5d26c936238506df90a3c02c76707722"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e5512a32a3267c2258d80b01e5bca0e88f00b23","date":1563441036,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PhraseQuery.Builder#add(Term,int).mjava","sourceNew":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly, but must be greater than\n     * or equal to that of the previously added term.\n     * A greater position allows phrases with gaps (e.g. in connection with stopwords).\n     * If the position is equal, you most likely should be using\n     * {@link MultiPhraseQuery} instead which only requires one term at each position to match; this class requires\n     * all of them.\n     */\n    public Builder add(Term term, int position) {\n      Objects.requireNonNull(term, \"Cannot add a null term to PhraseQuery\");\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","sourceOld":"    /**\n     * Adds a term to the end of the query phrase.\n     * The relative position of the term within the phrase is specified explicitly, but must be greater than\n     * or equal to that of the previously added term.\n     * A greater position allows phrases with gaps (e.g. in connection with stopwords).\n     * If the position is equal, you most likely should be using\n     * {@link MultiPhraseQuery} instead which only requires one term at each position to match; this class requires\n     * all of them.\n     */\n    public Builder add(Term term, int position) {\n      if (position < 0) {\n        throw new IllegalArgumentException(\"Positions must be >= 0, got \" + position);\n      }\n      if (positions.isEmpty() == false) {\n        final int lastPosition = positions.get(positions.size() - 1);\n        if (position < lastPosition) {\n          throw new IllegalArgumentException(\"Positions must be added in order, got \" + position + \" after \" + lastPosition);\n        }\n      }\n      if (terms.isEmpty() == false && term.field().equals(terms.get(0).field()) == false) {\n        throw new IllegalArgumentException(\"All terms must be on the same field, got \" + term.field() + \" and \" + terms.get(0).field());\n      }\n      terms.add(term);\n      positions.add(position);\n      return this;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e5512a32a3267c2258d80b01e5bca0e88f00b23":["860d9cc0c963b5c0db351fb0473b6894b1d96020"],"e9e1499c5d26c936238506df90a3c02c76707722":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"38b5bd3ae837751f57f363e9a41b833794222814":["457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7"],"860d9cc0c963b5c0db351fb0473b6894b1d96020":["38b5bd3ae837751f57f363e9a41b833794222814"],"457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7":["e9e1499c5d26c936238506df90a3c02c76707722"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2e5512a32a3267c2258d80b01e5bca0e88f00b23"]},"commit2Childs":{"2e5512a32a3267c2258d80b01e5bca0e88f00b23":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9e1499c5d26c936238506df90a3c02c76707722":["457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9e1499c5d26c936238506df90a3c02c76707722"],"38b5bd3ae837751f57f363e9a41b833794222814":["860d9cc0c963b5c0db351fb0473b6894b1d96020"],"860d9cc0c963b5c0db351fb0473b6894b1d96020":["2e5512a32a3267c2258d80b01e5bca0e88f00b23"],"457d307af2d848ae3d2fa1f219e4f71bd8b4d7d7":["38b5bd3ae837751f57f363e9a41b833794222814"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}