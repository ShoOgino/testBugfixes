{"path":"lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","commits":[{"id":"f79c103683b18eae3b9f62a8c61e675d8984b092","date":1272893294,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fcbc12aa8147f5203ca283e7252ba4280d6ffd16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f080986da691a3bba7b757f43ab72cdc82b57ce","date":1273069619,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["f79c103683b18eae3b9f62a8c61e675d8984b092"],"f79c103683b18eae3b9f62a8c61e675d8984b092":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f080986da691a3bba7b757f43ab72cdc82b57ce"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f79c103683b18eae3b9f62a8c61e675d8984b092"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f79c103683b18eae3b9f62a8c61e675d8984b092":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}