{"path":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.numDocs());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.numDocs());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbf497fc92342be81ff184a144dfa7c96264116b","date":1275079529,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.maxDoc());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.numDocs());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":["259055feeba9afa10e21ab63032f3778bb1802f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"259055feeba9afa10e21ab63032f3778bb1802f1","date":1291199138,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.maxDoc());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":["052fac7830290bd38a04cddee1a121ee07656b56","cbf497fc92342be81ff184a144dfa7c96264116b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.maxDoc());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (nDocs <= 0) {\n      throw new IllegalArgumentException(\"nDocs must be > 0\");\n    }\n\n    nDocs = Math.min(nDocs, reader.maxDoc());\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b241ea5e635d896cc0af83cd96ffd0322e0aba7","date":1294226200,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link Searcher#search(Query,int)} or\n   * {@link Searcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":["e87ea9fb673e8638747af83477322f07ed5a8b95"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a1aa37d6135cf6c605c23e4ff9becf07f6049c7","date":1294253125,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link Searcher#search(Query,int)} or\n   * {@link Searcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"41c254de87d45aece543872ed3ed365ab7d3ad7f","date":1294255671,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, docStarts[i]));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link Searcher#search(Query,int)} or\n   * {@link Searcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, leafContexts[i].docBase));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, docStarts[i]));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, leafContexts[i].docBase));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  // inherit javadoc\n  @Override\n  public TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n    search(weight, filter, collector);\n    return collector.topDocs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30da203d7de68a87a16025523a483a96c24f4291","date":1296686055,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9f738d4503df21769bdbea97432f90df1d78747","date":1296724248,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        if(topDocs.totalHits != 0) {\n          totalHits += topDocs.totalHits;\n          maxScore = Math.max(maxScore, topDocs.getMaxScore());\n        }\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        if(topDocs.totalHits != 0) {\n          totalHits += topDocs.totalHits;\n          maxScore = Math.max(maxScore, topDocs.getMaxScore());\n        }\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link Searcher#search(Query,int)} or\n   * {@link Searcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subReaders.length; i++) { // search each sub\n        runner.submit(\n                      new MultiSearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq, i, docStarts));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        if(topDocs.totalHits != 0) {\n          totalHits += topDocs.totalHits;\n          maxScore = Math.max(maxScore, topDocs.getMaxScore());\n        }\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n\n    if (executor == null) {\n      // single thread\n      int limit = reader.maxDoc();\n      if (limit == 0) {\n        limit = 1;\n      }\n      nDocs = Math.min(nDocs, limit);\n      TopScoreDocCollector collector = TopScoreDocCollector.create(nDocs, !weight.scoresDocsOutOfOrder());\n      search(weight, filter, collector);\n      return collector.topDocs();\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < subSearchers.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, subSearchers[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        totalHits += topDocs.totalHits;\n        maxScore = Math.max(maxScore, topDocs.getMaxScore());\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15","date":1316561169,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,ScoreDoc,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,Filter,int).mjava","sourceNew":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, ScoreDoc after, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, after, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, after, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        if(topDocs.totalHits != 0) {\n          totalHits += topDocs.totalHits;\n          maxScore = Math.max(maxScore, topDocs.getMaxScore());\n        }\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","sourceOld":"  /** Expert: Low-level search implementation.  Finds the top <code>n</code>\n   * hits for <code>query</code>, applying <code>filter</code> if non-null.\n   *\n   * <p>Applications should usually call {@link IndexSearcher#search(Query,int)} or\n   * {@link IndexSearcher#search(Query,Filter,int)} instead.\n   * @throws BooleanQuery.TooManyClauses\n   */\n  protected TopDocs search(Weight weight, Filter filter, int nDocs) throws IOException {\n    if (executor == null) {\n      return search(leafContexts, weight, filter, nDocs);\n    } else {\n      final HitQueue hq = new HitQueue(nDocs, false);\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopDocs> runner = new ExecutionHelper<TopDocs>(executor);\n    \n      for (int i = 0; i < leafSlices.length; i++) { // search each sub\n        runner.submit(\n                      new SearcherCallableNoSort(lock, this, leafSlices[i], weight, filter, nDocs, hq));\n      }\n\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopDocs topDocs : runner) {\n        if(topDocs.totalHits != 0) {\n          totalHits += topDocs.totalHits;\n          maxScore = Math.max(maxScore, topDocs.getMaxScore());\n        }\n      }\n\n      final ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n      for (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n        scoreDocs[i] = hq.pop();\n\n      return new TopDocs(totalHits, scoreDocs, maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15":["c9f738d4503df21769bdbea97432f90df1d78747"],"70ad682703b8585f5d0a637efec044d57ec05efb":["3bb13258feba31ab676502787ab2e1779f129b7a","8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"c9f738d4503df21769bdbea97432f90df1d78747":["30da203d7de68a87a16025523a483a96c24f4291"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["cbf497fc92342be81ff184a144dfa7c96264116b","259055feeba9afa10e21ab63032f3778bb1802f1"],"cbf497fc92342be81ff184a144dfa7c96264116b":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["259055feeba9afa10e21ab63032f3778bb1802f1"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","c9f738d4503df21769bdbea97432f90df1d78747"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["41c254de87d45aece543872ed3ed365ab7d3ad7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"41c254de87d45aece543872ed3ed365ab7d3ad7f":["8a1aa37d6135cf6c605c23e4ff9becf07f6049c7"],"8a1aa37d6135cf6c605c23e4ff9becf07f6049c7":["8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"259055feeba9afa10e21ab63032f3778bb1802f1":["cbf497fc92342be81ff184a144dfa7c96264116b"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"30da203d7de68a87a16025523a483a96c24f4291":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","c9f738d4503df21769bdbea97432f90df1d78747"],"3bb13258feba31ab676502787ab2e1779f129b7a":["cbf497fc92342be81ff184a144dfa7c96264116b","259055feeba9afa10e21ab63032f3778bb1802f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"c9f738d4503df21769bdbea97432f90df1d78747":["c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"cbf497fc92342be81ff184a144dfa7c96264116b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","259055feeba9afa10e21ab63032f3778bb1802f1","3bb13258feba31ab676502787ab2e1779f129b7a"],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["70ad682703b8585f5d0a637efec044d57ec05efb","8a1aa37d6135cf6c605c23e4ff9becf07f6049c7"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"259055feeba9afa10e21ab63032f3778bb1802f1":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","8b241ea5e635d896cc0af83cd96ffd0322e0aba7","3bb13258feba31ab676502787ab2e1779f129b7a"],"41c254de87d45aece543872ed3ed365ab7d3ad7f":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"8a1aa37d6135cf6c605c23e4ff9becf07f6049c7":["41c254de87d45aece543872ed3ed365ab7d3ad7f"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["30da203d7de68a87a16025523a483a96c24f4291","868da859b43505d9d2a023bfeae6dd0c795f5295"],"30da203d7de68a87a16025523a483a96c24f4291":["c9f738d4503df21769bdbea97432f90df1d78747"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"3bb13258feba31ab676502787ab2e1779f129b7a":["70ad682703b8585f5d0a637efec044d57ec05efb"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cbf497fc92342be81ff184a144dfa7c96264116b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}