{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77855215e331ce146763531cb9b0c050726f6ae5","date":1338323851,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","b5a3548d95924aea5ee6d88499a7d166498a8e49","1509f151d7692d84fae414b2b799ac06ba60fcb4","97e30c53fd81463c6ccd52402c91a6548cf42acb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b538dc75c275415cfba029900b48590b36b3b68","date":1339713606,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(\"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"714058a3bd900646d4df5e21af2d4e109ed3e4bc","date":1341692336,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(\"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(\"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(\"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(\"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7e4907084808af8fdb14b9809e6dceaccf6867b","date":1343473006,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19f400d1b6b61e87efe596bd64726f080f9a29f0","date":1366027276,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newStringField(\"parentID\", \"\"+parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        parentJoinDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newStringField(\"childID\", \"\"+childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newStringField(\"blockID\", \"\"+parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49a8cbd66bc94e18d7b9087e42dbc6cc0ee0c161","date":1378462032,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d909c25727b571ebf2c8ed48fefd0f3d90f7a08","date":1400082127,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newStringField(\"parent\" + field, parentFields[field][random().nextInt(parentFields[field].length)], Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newStringField(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)], Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a16b40feb4e6e0d55c1716733bde48296bedd20","date":1400540388,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != parents.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != parents.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != parents.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != parents.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.shutdown();\n    final IndexReader joinR = joinW.getReader();\n    joinW.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      BytesRef term = new BytesRef();\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term));\n      joinW.deleteDocuments(new Term(\"blockID\", term));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b012914a8110b2ff1d075ed1ef72aa57084d4897","date":1414685177,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new FixedBitSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      DocsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe4b37941dda041ab19456b15412aacb9c657a26","date":1429449253,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ScoreMode agg;\n      if (x == 0) {\n        agg = ScoreMode.None;\n      } else if (x == 1) {\n        agg = ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ScoreMode.Total;\n      } else {\n        agg = ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new FilteredQuery(childJoinQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new FilteredQuery(childQuery2, random().nextBoolean()\n                  ? new BitDocIdSetCachingWrapperFilter(f): f);\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, null, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b3915945926c0bf7def01b0c504977709d3aed3","date":1436197708,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a67f37df79147ed4dd608300c2336c2979db98be","date":1436271524,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new IntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new IntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      NumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final StoredDocument doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final StoredDocument parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final StoredDocument doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          StoredDocument document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final StoredDocument doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final StoredDocument doc = joinS.doc(sd.doc);\n          final StoredDocument parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"651ed0c260e4184c8a85ae7e1c155a4415f2e6e2","date":1455407361,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCoded(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCodedBytes(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a8a6e8618a812308bce0a978e52ca5c453a112","date":1457444484,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      // TODO: we should add newSetQuery(String, Collection<T>) ? this is awkward.\n      int[] array = new int[toDelete.size()];\n      for (int i = 0; i < toDelete.size(); i++) {\n        array[i] = toDelete.get(i);\n      }\n      Query query = IntPoint.newSetQuery(\"blockID\", array);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new LegacyIntField(\"parentID\", parentDocID, Field.Store.YES);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        parentJoinDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new LegacyIntField(\"childID\", childDocID, Field.Store.YES);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new LegacyIntField(\"blockID\", parentDocID, Field.Store.NO));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    BytesRefBuilder term = new BytesRefBuilder();\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      LegacyNumericUtils.intToPrefixCoded(deleteID, 0, term);\n      w.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n      joinW.deleteDocuments(new Term(\"blockID\", term.toBytesRef()));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":["b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c","date":1457540737,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      // TODO: we should add newSetQuery(String, Collection<T>) ? this is awkward.\n      int[] array = new int[toDelete.size()];\n      for (int i = 0; i < toDelete.size(); i++) {\n        array[i] = toDelete.get(i);\n      }\n      Query query = IntPoint.newSetQuery(\"blockID\", array);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":["b5a3548d95924aea5ee6d88499a7d166498a8e49","37a8a6e8618a812308bce0a978e52ca5c453a112"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4","date":1457550664,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5c16d494b4cccbc6f3aa00f05421575bdb11da7","date":1464182657,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          assertEquals(String.format(Locale.ROOT, \"Score based on child doc range from %d to %d\", hit.doc - 1 - childId, hit.doc - 1), explanation.getDescription());\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d9452e13e015fa1187b0b1bed1a1d08b9c96241","date":1485723373,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c","date":1485769582,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","date":1514891219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiFields.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiFields.getTermDocsEnum(joinR, \"isParent\", new BytesRef(\"x\"));\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f625a75e1debd4c2bf7b827c6f8734582741d668","date":1554470649,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          if (agg == ScoreMode.None) {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"ConstantScore(\"));\n          } else {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n          }\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 10* RANDOM_MULTIPLIER, 30 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          if (agg == ScoreMode.None) {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"ConstantScore(\"));\n          } else {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n          }\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 100 * RANDOM_MULTIPLIER, 300 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          if (agg == ScoreMode.None) {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"ConstantScore(\"));\n          } else {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n          }\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 10* RANDOM_MULTIPLIER, 30 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200 * RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          if (agg == ScoreMode.None) {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"ConstantScore(\"));\n          } else {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n          }\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int maxNumChildrenPerParent = 20;\n    final int numParentDocs = TestUtil.nextInt(random(), 10* RANDOM_MULTIPLIER, 30 * RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = new StoredField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      id = new NumericDocValuesField(\"parentID\", parentDocID);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newStringField(\"isParent\", \"x\", Field.Store.NO));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          String s = parentFields[field][random().nextInt(parentFields[field].length)];\n          Field f = newStringField(\"parent\" + field, s, Field.Store.NO);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n\n          f = new SortedDocValuesField(\"parent\" + field, new BytesRef(s));\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(new IntPoint(\"blockID\", parentDocID));\n        parentJoinDoc.add(new IntPoint(\"blockID\", parentDocID));\n      }\n\n      final List<Document> joinDocs = new ArrayList<>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = TestUtil.nextInt(random(), 1, maxNumChildrenPerParent);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = new StoredField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n        childID = new NumericDocValuesField(\"childID\", childDocID);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            String s = childFields[childFieldID][random().nextInt(childFields[childFieldID].length)];\n            Field f = newStringField(\"child\" + childFieldID, s, Field.Store.NO);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n\n            f = new SortedDocValuesField(\"child\" + childFieldID, new BytesRef(s));\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(new IntPoint(\"blockID\", parentDocID));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    if (!toDelete.isEmpty()) {\n      Query query = IntPoint.newSetQuery(\"blockID\", toDelete);\n      w.deleteDocuments(query);\n      joinW.deleteDocuments(query);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      Bits liveDocs = MultiBits.getLiveDocs(joinR);\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX) + \" deleted?=\" + (liveDocs != null && liveDocs.get(docIDX) == false));\n      }\n      PostingsEnum parents = MultiTerms.getTermPostingsEnum(joinR, \"isParent\", new BytesRef(\"x\"), (int) PostingsEnum.FREQS);\n      System.out.println(\"parent docIDs:\");\n      while (parents.nextDoc() != PostingsEnum.NO_MORE_DOCS) {\n        System.out.println(\"  \" + parents.docID());\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r, false);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term(\"isParent\", \"x\")));\n    CheckJoinIndex.check(joinS.getIndexReader(), parentsFilter);\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        childQuery = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = TestUtil.nextInt(random(), 1, childFields.length - 1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        childQuery = bq.build();\n      }\n      if (random().nextBoolean()) {\n        childQuery = new RandomApproximationQuery(childQuery, random());\n      }\n\n\n      final ScoreMode agg = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n        parentJoinQuery = bq.build();\n        parentQuery = bq2.build();\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits.value + \" hits; sort=\" + parentAndChildSort);\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \" + fd.fields.length + \" sort values: \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      TopDocs joinedResults = joinS.search(parentJoinQuery, numParentDocs);\n      SortedMap<Integer, TopDocs> joinResults = new TreeMap<>();\n      for (ScoreDoc parentHit : joinedResults.scoreDocs) {\n        ParentChildrenBlockJoinQuery childrenQuery =\n            new ParentChildrenBlockJoinQuery(parentsFilter, childQuery, parentHit.doc);\n        TopDocs childTopDocs = joinS.search(childrenQuery, maxNumChildrenPerParent, childSort);\n        final Document parentDoc = joinS.doc(parentHit.doc);\n        joinResults.put(Integer.valueOf(parentDoc.get(\"parentID\")), childTopDocs);\n      }\n\n      final int hitsPerGroup = TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.size()) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          for (Map.Entry<Integer, TopDocs> entry : joinResults.entrySet()) {\n            System.out.println(\"  group parentID=\" + entry.getKey() + \" (docID=\" + entry.getKey() + \")\");\n            for(ScoreDoc childHit : entry.getValue().scoreDocs) {\n              final Document doc = joinS.doc(childHit.doc);\n//              System.out.println(\"    score=\" + childHit.score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + childHit.doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + childHit.doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits.value == 0) {\n        assertEquals(0, joinResults.size());\n      } else {\n        compareHits(r, joinR, results, joinResults);\n        TopDocs b = joinS.search(childJoinQuery, 10);\n        for (ScoreDoc hit : b.scoreDocs) {\n          Explanation explanation = joinS.explain(childJoinQuery, hit.doc);\n          Document document = joinS.doc(hit.doc - 1);\n          int childId = Integer.parseInt(document.get(\"childID\"));\n          //System.out.println(\"  hit docID=\" + hit.doc + \" childId=\" + childId + \" parentId=\" + document.get(\"parentID\"));\n          assertTrue(explanation.isMatch());\n          assertEquals(hit.score, explanation.getValue().doubleValue(), 0.0f);\n          Matcher m = Pattern.compile(\"Score based on ([0-9]+) child docs in range from ([0-9]+) to ([0-9]+), best match:\").matcher(explanation.getDescription());\n          assertTrue(\"Block Join description not matches\", m.matches());\n          assertTrue(\"Matched children not positive\", Integer.parseInt(m.group(1)) > 0);\n          assertEquals(\"Wrong child range start\", hit.doc - 1 - childId, Integer.parseInt(m.group(2)));\n          assertEquals(\"Wrong child range end\", hit.doc - 1, Integer.parseInt(m.group(3)));\n          Explanation childWeightExplanation = explanation.getDetails()[0];\n          if (\"sum of:\".equals(childWeightExplanation.getDescription())) {\n            childWeightExplanation = childWeightExplanation.getDetails()[0];\n          }\n          if (agg == ScoreMode.None) {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"ConstantScore(\"));\n          } else {\n            assertTrue(\"Wrong child weight description\", childWeightExplanation.getDescription().startsWith(\"weight(child\"));\n          }\n        }\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        final int numClauses = TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n        parentQuery2 = bq.build();\n      } else {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n\n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = TestUtil.nextInt(random(), 1, parentFields.length - 1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n        parentQuery2 = bq.build();\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter);\n\n      // To run against the block-join index:\n      Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      Query childQuery2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          childJoinQuery2 = new BooleanQuery.Builder()\n              .add(childJoinQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          // AND child field w/ parent query:\n          final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n          childJoinQuery2 = bq.build();\n        }\n\n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          childQuery2 = new BooleanQuery.Builder()\n              .add(childQuery2, Occur.MUST)\n              .add(new TermQuery(childTerm), Occur.FILTER)\n              .build();\n        } else {\n          final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n          childQuery2 = bq2.build();\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits.value + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":["97e30c53fd81463c6ccd52402c91a6548cf42acb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["19f400d1b6b61e87efe596bd64726f080f9a29f0","59a0020b413d44dd79d85d7a66ed5004265fb453"],"37a8a6e8618a812308bce0a978e52ca5c453a112":["651ed0c260e4184c8a85ae7e1c155a4415f2e6e2"],"fe4b37941dda041ab19456b15412aacb9c657a26":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"2acf500f78aa12b92e371fd89c719291986b6b90":["6b538dc75c275415cfba029900b48590b36b3b68","714058a3bd900646d4df5e21af2d4e109ed3e4bc"],"b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c":["37a8a6e8618a812308bce0a978e52ca5c453a112"],"4b3915945926c0bf7def01b0c504977709d3aed3":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["77855215e331ce146763531cb9b0c050726f6ae5"],"19f400d1b6b61e87efe596bd64726f080f9a29f0":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["fb17639909a369c1e64866842e5c213440acc17e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"f625a75e1debd4c2bf7b827c6f8734582741d668":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6b538dc75c275415cfba029900b48590b36b3b68":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"5c84485629d80d203608e8975a1139de9933cc38":["4d637064d608752565d4f9f41b2497dfdfdde50e","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"5d909c25727b571ebf2c8ed48fefd0f3d90f7a08":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"ef0d8a69209261514c5739c770bba706c2308450":["b89678825b68eccaf09e6ab71675fc0b0af1e099","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["770342641f7b505eaa8dccdc666158bff2419109"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["0e7bc21595222ae4f75509300fbb7726691f387f","e5c16d494b4cccbc6f3aa00f05421575bdb11da7"],"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c":["9d9452e13e015fa1187b0b1bed1a1d08b9c96241"],"83870855d82aba6819217abeff5a40779dbb28b4":["0e7bc21595222ae4f75509300fbb7726691f387f","0e121d43b5a10f2df530f406f935102656e9c4e8"],"51f5280f31484820499077f41fcdfe92d527d9dc":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"770342641f7b505eaa8dccdc666158bff2419109":["a67f37df79147ed4dd608300c2336c2979db98be"],"714058a3bd900646d4df5e21af2d4e109ed3e4bc":["6b538dc75c275415cfba029900b48590b36b3b68"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["1db68e96dd908fcd79ef809095822736aa601d08"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["6b538dc75c275415cfba029900b48590b36b3b68","2acf500f78aa12b92e371fd89c719291986b6b90"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4":["b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c"],"71da933d30aea361ccc224d6544c451cbf49916d":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"fb17639909a369c1e64866842e5c213440acc17e":["51f5280f31484820499077f41fcdfe92d527d9dc"],"a67f37df79147ed4dd608300c2336c2979db98be":["4b3915945926c0bf7def01b0c504977709d3aed3"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["1d028314cced5858683a1bb4741423d0f934257b"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"e5c16d494b4cccbc6f3aa00f05421575bdb11da7":["0e7bc21595222ae4f75509300fbb7726691f387f"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["fe4b37941dda041ab19456b15412aacb9c657a26"],"1d028314cced5858683a1bb4741423d0f934257b":["2acf500f78aa12b92e371fd89c719291986b6b90","a7e4907084808af8fdb14b9809e6dceaccf6867b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"49a8cbd66bc94e18d7b9087e42dbc6cc0ee0c161":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["19f400d1b6b61e87efe596bd64726f080f9a29f0"],"77855215e331ce146763531cb9b0c050726f6ae5":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"a7e4907084808af8fdb14b9809e6dceaccf6867b":["46d8ada1fff8d18cb197c38c7983225162599948"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["f625a75e1debd4c2bf7b827c6f8734582741d668"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["56572ec06f1407c066d6b7399413178b33176cd8"],"6613659748fe4411a7dcf85266e55db1f95f7315":["49a8cbd66bc94e18d7b9087e42dbc6cc0ee0c161"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4","0e121d43b5a10f2df530f406f935102656e9c4e8"],"651ed0c260e4184c8a85ae7e1c155a4415f2e6e2":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"46d8ada1fff8d18cb197c38c7983225162599948":["6b538dc75c275415cfba029900b48590b36b3b68","2acf500f78aa12b92e371fd89c719291986b6b90"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["93dd449115a9247533e44bab47e8429e5dccbc6d","0a16b40feb4e6e0d55c1716733bde48296bedd20"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","5d909c25727b571ebf2c8ed48fefd0f3d90f7a08"],"0e7bc21595222ae4f75509300fbb7726691f387f":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["5c84485629d80d203608e8975a1139de9933cc38"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71da933d30aea361ccc224d6544c451cbf49916d"]},"commit2Childs":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["51f5280f31484820499077f41fcdfe92d527d9dc"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"37a8a6e8618a812308bce0a978e52ca5c453a112":["b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c"],"fe4b37941dda041ab19456b15412aacb9c657a26":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"2acf500f78aa12b92e371fd89c719291986b6b90":["fe33227f6805edab2036cbb80645cc4e2d1fa424","1d028314cced5858683a1bb4741423d0f934257b","46d8ada1fff8d18cb197c38c7983225162599948"],"b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c":["8d3c6656a576996d73c1ac211d08e3f7a8fc02a4"],"4b3915945926c0bf7def01b0c504977709d3aed3":["a67f37df79147ed4dd608300c2336c2979db98be"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["6b538dc75c275415cfba029900b48590b36b3b68"],"19f400d1b6b61e87efe596bd64726f080f9a29f0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","59a0020b413d44dd79d85d7a66ed5004265fb453"],"1db68e96dd908fcd79ef809095822736aa601d08":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["fe4b37941dda041ab19456b15412aacb9c657a26"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"6b538dc75c275415cfba029900b48590b36b3b68":["2acf500f78aa12b92e371fd89c719291986b6b90","714058a3bd900646d4df5e21af2d4e109ed3e4bc","fe33227f6805edab2036cbb80645cc4e2d1fa424","46d8ada1fff8d18cb197c38c7983225162599948"],"f625a75e1debd4c2bf7b827c6f8734582741d668":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["5d909c25727b571ebf2c8ed48fefd0f3d90f7a08","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"5c84485629d80d203608e8975a1139de9933cc38":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"5d909c25727b571ebf2c8ed48fefd0f3d90f7a08":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"ef0d8a69209261514c5739c770bba706c2308450":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["651ed0c260e4184c8a85ae7e1c155a4415f2e6e2"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["9d9452e13e015fa1187b0b1bed1a1d08b9c96241","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"51f5280f31484820499077f41fcdfe92d527d9dc":["fb17639909a369c1e64866842e5c213440acc17e"],"770342641f7b505eaa8dccdc666158bff2419109":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"714058a3bd900646d4df5e21af2d4e109ed3e4bc":["2acf500f78aa12b92e371fd89c719291986b6b90"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["4b3915945926c0bf7def01b0c504977709d3aed3"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ef0d8a69209261514c5739c770bba706c2308450","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["f625a75e1debd4c2bf7b827c6f8734582741d668"],"8d3c6656a576996d73c1ac211d08e3f7a8fc02a4":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"71da933d30aea361ccc224d6544c451cbf49916d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb17639909a369c1e64866842e5c213440acc17e":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"a67f37df79147ed4dd608300c2336c2979db98be":["770342641f7b505eaa8dccdc666158bff2419109"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["19f400d1b6b61e87efe596bd64726f080f9a29f0"],"56572ec06f1407c066d6b7399413178b33176cd8":["0a16b40feb4e6e0d55c1716733bde48296bedd20"],"e5c16d494b4cccbc6f3aa00f05421575bdb11da7":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"1d028314cced5858683a1bb4741423d0f934257b":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","49a8cbd66bc94e18d7b9087e42dbc6cc0ee0c161"],"49a8cbd66bc94e18d7b9087e42dbc6cc0ee0c161":["6613659748fe4411a7dcf85266e55db1f95f7315"],"77855215e331ce146763531cb9b0c050726f6ae5":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a7e4907084808af8fdb14b9809e6dceaccf6867b":["1d028314cced5858683a1bb4741423d0f934257b"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["71da933d30aea361ccc224d6544c451cbf49916d"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"651ed0c260e4184c8a85ae7e1c155a4415f2e6e2":["37a8a6e8618a812308bce0a978e52ca5c453a112"],"46d8ada1fff8d18cb197c38c7983225162599948":["a7e4907084808af8fdb14b9809e6dceaccf6867b"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["ef0d8a69209261514c5739c770bba706c2308450","77855215e331ce146763531cb9b0c050726f6ae5"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","5c84485629d80d203608e8975a1139de9933cc38"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","4d637064d608752565d4f9f41b2497dfdfdde50e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"0e7bc21595222ae4f75509300fbb7726691f387f":["0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","e5c16d494b4cccbc6f3aa00f05421575bdb11da7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","ef0d8a69209261514c5739c770bba706c2308450","83870855d82aba6819217abeff5a40779dbb28b4","fe33227f6805edab2036cbb80645cc4e2d1fa424","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}