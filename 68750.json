{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","commits":[{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      * @param startPlaneIsInternal signals whether the startPlane is an internal edge\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e","date":1460121287,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look for the first point that isn't.\n          int checkPointIndex = -1;\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee","d0a9b63eb861882e7ed417be6aaf858910cad7e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aee30f7d7f332597ff2830aff7397d714ff7be42","date":1460489833,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend\n          double accumulatedDistance = 0.0;\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              final double actualDistance = pointList.get(getLegalIndex(startIndex-1, pointList.size())).arcDistance(pointList.get(index));\n              if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n                throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              }\n            }\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look for the first point that isn't.\n          int checkPointIndex = -1;\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee","d0a9b63eb861882e7ed417be6aaf858910cad7e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0a9b63eb861882e7ed417be6aaf858910cad7e0","date":1460530285,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look backwards for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend, so that we note backtracking when we see it\n          double accumulatedDistance = newPoint.arcDistance(pointList.get(startIndex));\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              final double actualDistance = newPoint.arcDistance(pointList.get(index));\n              if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n                throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              }\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend\n          double accumulatedDistance = 0.0;\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              final double actualDistance = pointList.get(getLegalIndex(startIndex-1, pointList.size())).arcDistance(pointList.get(index));\n              if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n                throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              }\n            }\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":["aee30f7d7f332597ff2830aff7397d714ff7be42","835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"414425421ced68c7064f08c9da6a2c95399226d9","date":1460921822,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look backwards for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend, so that we note backtracking when we see it\n          //double accumulatedDistance = newPoint.arcDistance(pointList.get(startIndex));\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              //accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              //final double actualDistance = newPoint.arcDistance(pointList.get(index));\n              //if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n              //  throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              //}\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look backwards for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend, so that we note backtracking when we see it\n          double accumulatedDistance = newPoint.arcDistance(pointList.get(startIndex));\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              final double actualDistance = newPoint.arcDistance(pointList.get(index));\n              if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n                throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              }\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Start plane index: \"+startPlaneStartIndex+\" End plane index: \"+startPlaneEndIndex+\" Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        /*\n        System.out.println(\"For plane \"+currentEdge.plane+\", the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(currentEdge.plane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        \n        // Check termination condition\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final GeoPoint pointToPresent = currentEdge.startPoint;\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n\n      // We need to detect backtracks, and also situations where someone has tried to stitch together multiple segments into one long arc (> 180 degrees).\n      // To do this, every time we extend by a coplanar segment, we compute the total arc distance to the new endpoint, as\n      // well as a sum of the arc distances we've accumulated as we march forward.  If these two numbers disagree, then\n      // we know there has been a backtrack or other anomaly.\n      \n      // extend the edge, we compute the distance along the \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        // We have to be sure that the point we use as a check does not lie on the plane.\n        // In order to meet that goal, we need to go hunting for a point that meets the criteria.  If we don't\n        // find one, we've got a linear \"polygon\" that we cannot use.\n        \n        // We need to know the sidedness of the new plane.  The point we're going to be presenting to it has\n        // a certain relationship with the sided plane we already have for the current edge.  If the current edge\n        // is colinear with the new edge, then we want to maintain the same relationship.  If the new edge\n        // is not colinear, then we can use the new point's relationship with the current edge as our guide.\n        \n        final boolean isNewPointWithin;\n        final GeoPoint pointToPresent;\n        if (currentEdge.plane.evaluateIsZero(newPoint)) {\n          // The new point is colinear with the current edge.  We'll have to look backwards for the first point that isn't.\n          int checkPointIndex = -1;\n          // Compute the arc distance before we try to extend, so that we note backtracking when we see it\n          //double accumulatedDistance = newPoint.arcDistance(pointList.get(startIndex));\n          final Plane checkPlane = new Plane(pointList.get(startIndex), newPoint);\n          for (int i = 0; i < pointList.size(); i++) {\n            final int index = getLegalIndex(startIndex - 1 - i, pointList.size());\n            if (!checkPlane.evaluateIsZero(pointList.get(index))) {\n              checkPointIndex = index;\n              break;\n            } else {\n              //accumulatedDistance += pointList.get(getLegalIndex(index+1, pointList.size())).arcDistance(pointList.get(index));\n              //final double actualDistance = newPoint.arcDistance(pointList.get(index));\n              //if (Math.abs(actualDistance - accumulatedDistance) >= Vector.MINIMUM_RESOLUTION) {\n              //  throw new IllegalArgumentException(\"polygon backtracks over itself\");\n              //}\n            }\n          }\n          if (checkPointIndex == -1) {\n            throw new IllegalArgumentException(\"polygon is illegal (linear)\");\n          }\n          pointToPresent = pointList.get(checkPointIndex);\n          isNewPointWithin = currentEdge.plane.isWithin(pointToPresent);\n        } else {\n          isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n          pointToPresent = currentEdge.startPoint;\n        }\n\n        final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":["aee30f7d7f332597ff2830aff7397d714ff7be42","414425421ced68c7064f08c9da6a2c95399226d9","835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e","40aa98241c87d86a0077beb8023713d93a0becfe","d0a9b63eb861882e7ed417be6aaf858910cad7e0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["414425421ced68c7064f08c9da6a2c95399226d9"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["a75c862521bb895a29958e7bc5cb188597205a08"],"414425421ced68c7064f08c9da6a2c95399226d9":["d0a9b63eb861882e7ed417be6aaf858910cad7e0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0a9b63eb861882e7ed417be6aaf858910cad7e0":["aee30f7d7f332597ff2830aff7397d714ff7be42"],"aee30f7d7f332597ff2830aff7397d714ff7be42":["835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"a75c862521bb895a29958e7bc5cb188597205a08":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["aee30f7d7f332597ff2830aff7397d714ff7be42"],"414425421ced68c7064f08c9da6a2c95399226d9":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a75c862521bb895a29958e7bc5cb188597205a08"],"d0a9b63eb861882e7ed417be6aaf858910cad7e0":["414425421ced68c7064f08c9da6a2c95399226d9"],"aee30f7d7f332597ff2830aff7397d714ff7be42":["d0a9b63eb861882e7ed417be6aaf858910cad7e0"],"a75c862521bb895a29958e7bc5cb188597205a08":["835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}