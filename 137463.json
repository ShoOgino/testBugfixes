{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random.nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random.nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random.nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedDeletes deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedDeletes.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random.nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random.nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random.nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedDeletes deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedDeletes.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedDeletes deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedDeletes.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random.nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random.nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random.nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedDeletes deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedDeletes.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedDeletes deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedDeletes.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<Term>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<Term>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      builder.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, builder.toBytesRef()));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      BytesRef bytesRef = new BytesRef();\n      bytesRef.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, bytesRef));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":["e6e919043fa85ee891123768dd655a98edbbf63c","3ca8f587a46da69f4b3ba9679411af9f7d7cb4ea"],"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    String field = null;\n    while (true) {\n      boolean newField = iter.next();\n      if (newField) {\n        field = iter.field;\n        if (field == null) {\n          break;\n        }\n      }\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(field, builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n    for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {\n      builder.copyBytes(t.bytes);\n      frozenSet.add(new Term(t.field, builder.toBytesRef()));\n    }\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","9fa5ed548a2e7179ad03d6dfef30e19b8c06a8e2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"258f227b48a4dbfc180f6ec70f172469d6a2bef8","date":1428687213,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    String field = null;\n    while (true) {\n      boolean newField = iter.next();\n      if (newField) {\n        field = iter.field;\n        if (field == null) {\n          break;\n        }\n      }\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(field, builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws InterruptedException {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue();\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.terms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).termIterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34067df01cbbefc83d0b316037fe4e10d89ba6a3","date":1559054674,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9","date":1559371943,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue#testStressDeleteQueue().mjava","sourceNew":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n  }\n\n","sourceOld":"  public void testStressDeleteQueue() throws Exception {\n    DocumentsWriterDeleteQueue queue = new DocumentsWriterDeleteQueue(null);\n    Set<Term> uniqueValues = new HashSet<>();\n    final int size = 10000 + random().nextInt(500) * RANDOM_MULTIPLIER;\n    Integer[] ids = new Integer[size];\n    for (int i = 0; i < ids.length; i++) {\n      ids[i] = random().nextInt();\n      uniqueValues.add(new Term(\"id\", ids[i].toString()));\n    }\n    CountDownLatch latch = new CountDownLatch(1);\n    AtomicInteger index = new AtomicInteger(0);\n    final int numThreads = 2 + random().nextInt(5);\n    UpdateThread[] threads = new UpdateThread[numThreads];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new UpdateThread(queue, index, ids, latch);\n      threads[i].start();\n    }\n    latch.countDown();\n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join();\n    }\n\n    for (UpdateThread updateThread : threads) {\n      DeleteSlice slice = updateThread.slice;\n      queue.updateSlice(slice);\n      BufferedUpdates deletes = updateThread.deletes;\n      slice.apply(deletes, BufferedUpdates.MAX_INT);\n      assertEquals(uniqueValues, deletes.deleteTerms.keySet());\n    }\n    queue.tryApplyGlobalSlice();\n    Set<Term> frozenSet = new HashSet<>();\n    BytesRefBuilder builder = new BytesRefBuilder();\n\n    TermIterator iter = queue.freezeGlobalBuffer(null).deleteTerms.iterator();\n    while (iter.next() != null) {\n      builder.copyBytes(iter.bytes);\n      frozenSet.add(new Term(iter.field(), builder.toBytesRef()));\n    }\n\n    assertEquals(\"num deletes must be 0 after freeze\", 0, queue\n        .numGlobalTermDeletes());\n    assertEquals(uniqueValues.size(), frozenSet.size());\n    assertEquals(uniqueValues, frozenSet);\n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["258f227b48a4dbfc180f6ec70f172469d6a2bef8"],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["28288370235ed02234a64753cdbf0c6ec096304a","34067df01cbbefc83d0b316037fe4e10d89ba6a3"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["258f227b48a4dbfc180f6ec70f172469d6a2bef8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["258f227b48a4dbfc180f6ec70f172469d6a2bef8","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"258f227b48a4dbfc180f6ec70f172469d6a2bef8":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7e4c214a1f904dde76f5611b56d4081533055b3b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9","34067df01cbbefc83d0b316037fe4e10d89ba6a3"],"258f227b48a4dbfc180f6ec70f172469d6a2bef8":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["258f227b48a4dbfc180f6ec70f172469d6a2bef8"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}