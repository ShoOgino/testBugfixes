{"path":"lucene/core/src/java/org/apache/lucene/index/IndexingChain#processField(int,IndexableField,long,int).mjava","commits":[{"id":"7a6f8af01d9b3067b143bbdc0a492720e2af97cf","date":1600157724,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexingChain#processField(int,IndexableField,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#processField(int,IndexableField,long,int).mjava","sourceNew":"  private int processField(int docID, IndexableField field, long fieldGen, int fieldCount) throws IOException {\n    String fieldName = field.name();\n    IndexableFieldType fieldType = field.fieldType();\n\n    PerField fp = null;\n\n    if (fieldType.indexOptions() == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + field.name() + \"\\\")\");\n    }\n\n    // Invert indexed fields:\n    if (fieldType.indexOptions() != IndexOptions.NONE) {\n      fp = getOrAddField(fieldName, fieldType, true);\n      boolean first = fp.fieldGen != fieldGen;\n      fp.invert(docID, field, first);\n\n      if (first) {\n        fields[fieldCount++] = fp;\n        fp.fieldGen = fieldGen;\n      }\n    } else {\n      verifyUnIndexedFieldType(fieldName, fieldType);\n    }\n\n    // Add stored fields:\n    if (fieldType.stored()) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      if (fieldType.stored()) {\n        String value = field.stringValue();\n        if (value != null && value.length() > IndexWriter.MAX_STORED_STRING_LENGTH) {\n          throw new IllegalArgumentException(\"stored field \\\"\" + field.name() + \"\\\" is too large (\" + value.length() + \" characters) to store\");\n        }\n        try {\n          storedFieldsConsumer.writeField(fp.fieldInfo, field);\n        } catch (Throwable th) {\n          onAbortingException(th);\n          throw th;\n        }\n      }\n    }\n\n    DocValuesType dvType = fieldType.docValuesType();\n    if (dvType == null) {\n      throw new NullPointerException(\"docValuesType must not be null (field: \\\"\" + fieldName + \"\\\")\");\n    }\n    if (dvType != DocValuesType.NONE) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexDocValue(docID, fp, dvType, field);\n    }\n    if (fieldType.pointDimensionCount() != 0) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexPoint(docID, fp, field);\n    }\n    \n    return fieldCount;\n  }\n\n","sourceOld":"  private int processField(int docID, IndexableField field, long fieldGen, int fieldCount) throws IOException {\n    String fieldName = field.name();\n    IndexableFieldType fieldType = field.fieldType();\n\n    PerField fp = null;\n\n    if (fieldType.indexOptions() == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + field.name() + \"\\\")\");\n    }\n\n    // Invert indexed fields:\n    if (fieldType.indexOptions() != IndexOptions.NONE) {\n      fp = getOrAddField(fieldName, fieldType, true);\n      boolean first = fp.fieldGen != fieldGen;\n      fp.invert(docID, field, first);\n\n      if (first) {\n        fields[fieldCount++] = fp;\n        fp.fieldGen = fieldGen;\n      }\n    } else {\n      verifyUnIndexedFieldType(fieldName, fieldType);\n    }\n\n    // Add stored fields:\n    if (fieldType.stored()) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      if (fieldType.stored()) {\n        String value = field.stringValue();\n        if (value != null && value.length() > IndexWriter.MAX_STORED_STRING_LENGTH) {\n          throw new IllegalArgumentException(\"stored field \\\"\" + field.name() + \"\\\" is too large (\" + value.length() + \" characters) to store\");\n        }\n        try {\n          storedFieldsConsumer.writeField(fp.fieldInfo, field);\n        } catch (Throwable th) {\n          onAbortingException(th);\n          throw th;\n        }\n      }\n    }\n\n    DocValuesType dvType = fieldType.docValuesType();\n    if (dvType == null) {\n      throw new NullPointerException(\"docValuesType must not be null (field: \\\"\" + fieldName + \"\\\")\");\n    }\n    if (dvType != DocValuesType.NONE) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexDocValue(docID, fp, dvType, field);\n    }\n    if (fieldType.pointDimensionCount() != 0) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexPoint(docID, fp, field);\n    }\n    \n    return fieldCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680b6449f09827f58fe987aff279e014c311d966","date":1600247985,"type":1,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexingChain#processField(int,IndexableField,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#processField(int,IndexableField,long,int).mjava","sourceNew":"  private int processField(int docID, IndexableField field, long fieldGen, int fieldCount) throws IOException {\n    String fieldName = field.name();\n    IndexableFieldType fieldType = field.fieldType();\n\n    PerField fp = null;\n\n    if (fieldType.indexOptions() == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + field.name() + \"\\\")\");\n    }\n\n    // Invert indexed fields:\n    if (fieldType.indexOptions() != IndexOptions.NONE) {\n      fp = getOrAddField(fieldName, fieldType, true);\n      boolean first = fp.fieldGen != fieldGen;\n      fp.invert(docID, field, first);\n\n      if (first) {\n        fields[fieldCount++] = fp;\n        fp.fieldGen = fieldGen;\n      }\n    } else {\n      verifyUnIndexedFieldType(fieldName, fieldType);\n    }\n\n    // Add stored fields:\n    if (fieldType.stored()) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      if (fieldType.stored()) {\n        String value = field.stringValue();\n        if (value != null && value.length() > IndexWriter.MAX_STORED_STRING_LENGTH) {\n          throw new IllegalArgumentException(\"stored field \\\"\" + field.name() + \"\\\" is too large (\" + value.length() + \" characters) to store\");\n        }\n        try {\n          storedFieldsConsumer.writeField(fp.fieldInfo, field);\n        } catch (Throwable th) {\n          onAbortingException(th);\n          throw th;\n        }\n      }\n    }\n\n    DocValuesType dvType = fieldType.docValuesType();\n    if (dvType == null) {\n      throw new NullPointerException(\"docValuesType must not be null (field: \\\"\" + fieldName + \"\\\")\");\n    }\n    if (dvType != DocValuesType.NONE) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexDocValue(docID, fp, dvType, field);\n    }\n    if (fieldType.pointDimensionCount() != 0) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexPoint(docID, fp, field);\n    }\n    \n    return fieldCount;\n  }\n\n","sourceOld":"  private int processField(int docID, IndexableField field, long fieldGen, int fieldCount) throws IOException {\n    String fieldName = field.name();\n    IndexableFieldType fieldType = field.fieldType();\n\n    PerField fp = null;\n\n    if (fieldType.indexOptions() == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + field.name() + \"\\\")\");\n    }\n\n    // Invert indexed fields:\n    if (fieldType.indexOptions() != IndexOptions.NONE) {\n      fp = getOrAddField(fieldName, fieldType, true);\n      boolean first = fp.fieldGen != fieldGen;\n      fp.invert(docID, field, first);\n\n      if (first) {\n        fields[fieldCount++] = fp;\n        fp.fieldGen = fieldGen;\n      }\n    } else {\n      verifyUnIndexedFieldType(fieldName, fieldType);\n    }\n\n    // Add stored fields:\n    if (fieldType.stored()) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      if (fieldType.stored()) {\n        String value = field.stringValue();\n        if (value != null && value.length() > IndexWriter.MAX_STORED_STRING_LENGTH) {\n          throw new IllegalArgumentException(\"stored field \\\"\" + field.name() + \"\\\" is too large (\" + value.length() + \" characters) to store\");\n        }\n        try {\n          storedFieldsConsumer.writeField(fp.fieldInfo, field);\n        } catch (Throwable th) {\n          onAbortingException(th);\n          throw th;\n        }\n      }\n    }\n\n    DocValuesType dvType = fieldType.docValuesType();\n    if (dvType == null) {\n      throw new NullPointerException(\"docValuesType must not be null (field: \\\"\" + fieldName + \"\\\")\");\n    }\n    if (dvType != DocValuesType.NONE) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexDocValue(docID, fp, dvType, field);\n    }\n    if (fieldType.pointDimensionCount() != 0) {\n      if (fp == null) {\n        fp = getOrAddField(fieldName, fieldType, false);\n      }\n      indexPoint(docID, fp, field);\n    }\n    \n    return fieldCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"680b6449f09827f58fe987aff279e014c311d966":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a6f8af01d9b3067b143bbdc0a492720e2af97cf"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["680b6449f09827f58fe987aff279e014c311d966"]},"commit2Childs":{"680b6449f09827f58fe987aff279e014c311d966":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["680b6449f09827f58fe987aff279e014c311d966"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["680b6449f09827f58fe987aff279e014c311d966","7a6f8af01d9b3067b143bbdc0a492720e2af97cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}