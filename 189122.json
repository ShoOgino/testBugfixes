{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(Bits,QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.bits.set(docID);\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(Bits acceptDocs, QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      if (acceptDocs != null) {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          if (acceptDocs.get(docID)) {\n            state.bits.set(docID);\n          }\n        }\n      } else {\n        for(int i=0;i<count;i++) {\n          int docID = state.in.readInt();\n          state.bits.set(docID);\n        }\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(acceptDocs, state, 2*nodeID);\n      count += addAll(acceptDocs, state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e91a2d9ed80172872da0f517870da6756289554","date":1436431140,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.docs.add(docID);\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.bits.set(docID);\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      state.in.seek(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.docs.add(docID);\n      }\n\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      //IndexInput in = leafDISI.in;\n      state.in.seek(fp);\n      //allLeafDISI.reset(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.docs.add(docID);\n      }\n\n      //bits.or(allLeafDISI);\n      //return allLeafDISI.getHitCount();\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c50cb1eca5629cac5b6702dd0f5e06157af61a","date":1445464748,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","sourceNew":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n    //System.out.println(\"  addAll nodeID=\" + nodeID);\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"    leaf\");\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      state.in.seek(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        //System.out.println(\"  docID=\" + docID);\n        assert accept(state, docID);\n        state.docs.add(docID);\n      }\n\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      state.in.seek(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.docs.add(docID);\n      }\n\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#addAll(QueryState,int).mjava","sourceNew":null,"sourceOld":"  /** Fast path: this is called when the query rect fully encompasses all cells under this node. */\n  private int addAll(QueryState state, int nodeID) throws IOException {\n    //System.out.println(\"  addAll nodeID=\" + nodeID);\n    //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"    leaf\");\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      // Leaf node\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"    leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n      state.in.seek(fp);\n      \n      //System.out.println(\"    seek to leafFP=\" + fp);\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        //System.out.println(\"  docID=\" + docID);\n        assert accept(state, docID);\n        state.docs.add(docID);\n      }\n\n      return count;\n    } else {\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      //System.out.println(\"  addAll: inner\");\n      int count = addAll(state, 2*nodeID);\n      count += addAll(state, 2*nodeID+1);\n      //System.out.println(\"  addAll: return count=\" + count);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f64b7098768253180859cd8faeae6b1a185b06ed":["0e91a2d9ed80172872da0f517870da6756289554"],"0e91a2d9ed80172872da0f517870da6756289554":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["0e91a2d9ed80172872da0f517870da6756289554"],"f64b7098768253180859cd8faeae6b1a185b06ed":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"0e91a2d9ed80172872da0f517870da6756289554":["f64b7098768253180859cd8faeae6b1a185b06ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}