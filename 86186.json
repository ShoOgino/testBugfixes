{"path":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n    \n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e511b092029d56e0d4e30204fba8509c1c2647b6","6198e18a87837d41cdd5df8c554e124619d99e4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n    \n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n    \n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6198e18a87837d41cdd5df8c554e124619d99e4c","date":1368737399,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n    \n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<Object>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6e1dc1bb4254226c8d7151b596cc1be40671751","date":1421876355,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        } catch (ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","date":1449051812,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n    try {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n          \n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll( recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    } finally {\n      recentUpdates.close();  // cache this somehow?\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e511b092029d56e0d4e30204fba8509c1c2647b6","date":1467838965,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8381eb1cd44d2e0defb52130de3295a576ac1e7b","date":1467840340,"type":3,"author":"Chris Hostetter","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","date":1471849333,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint.toObject());\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint.toObject());\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f1f31880696765d6aec499d3b01fa501129af45","date":1474287317,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint.toObject());\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint.toObject());\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    List<String> versions = StrUtils.splitSmart(versionsStr, \",\", true);\n\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (String versionStr : versions) {\n        long version = Long.parseLong(versionStr);\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      if (params.getBool(\"skipDbq\", false)) {\n        updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n      }\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      if (params.getBool(\"skipDbq\", false)) {\n        updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n      }\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#processGetUpdates(ResponseBuilder).mjava","sourceNew":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      if (params.getBool(\"skipDbq\", false)) {\n        updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n      }\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","sourceOld":"  public void processGetUpdates(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n\n    String versionsStr = params.get(\"getUpdates\");\n    if (versionsStr == null) return;\n\n    UpdateLog ulog = req.getCore().getUpdateHandler().getUpdateLog();\n    if (ulog == null) return;\n\n    // handle version ranges\n    List<Long> versions = null;\n    if (versionsStr.indexOf(\"...\") != -1) {\n      versions = resolveVersionRanges(versionsStr, ulog);\n    } else {\n      versions = StrUtils.splitSmart(versionsStr, \",\", true).stream().map(Long::parseLong)\n          .collect(Collectors.toList());\n    }\n\n    // find fingerprint for max version for which updates are requested\n    boolean doFingerprint = params.getBool(\"fingerprint\", false);\n    if (doFingerprint) {\n      long maxVersionForUpdate = Collections.min(versions, PeerSync.absComparator);\n      IndexFingerprint fingerprint = IndexFingerprint.getFingerprint(req.getCore(), Math.abs(maxVersionForUpdate));\n      rb.rsp.add(\"fingerprint\", fingerprint);\n    }\n\n    List<Object> updates = new ArrayList<>(versions.size());\n\n    long minVersion = Long.MAX_VALUE;\n\n    // TODO: get this from cache instead of rebuilding?\n    try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n      for (Long version : versions) {\n        try {\n          Object o = recentUpdates.lookup(version);\n          if (o == null) continue;\n\n          if (version > 0) {\n            minVersion = Math.min(minVersion, version);\n          }\n\n          // TODO: do any kind of validation here?\n          updates.add(o);\n\n        } catch (SolrException | ClassCastException e) {\n          log.warn(\"Exception reading log for updates\", e);\n        }\n      }\n\n      // Must return all delete-by-query commands that occur after the first add requested\n      // since they may apply.\n      updates.addAll(recentUpdates.getDeleteByQuery(minVersion));\n\n      rb.rsp.add(\"updates\", updates);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6e1dc1bb4254226c8d7151b596cc1be40671751":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"8381eb1cd44d2e0defb52130de3295a576ac1e7b":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","e511b092029d56e0d4e30204fba8509c1c2647b6"],"1f1f31880696765d6aec499d3b01fa501129af45":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e511b092029d56e0d4e30204fba8509c1c2647b6":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"6198e18a87837d41cdd5df8c554e124619d99e4c":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["8381eb1cd44d2e0defb52130de3295a576ac1e7b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","1f1f31880696765d6aec499d3b01fa501129af45"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["8381eb1cd44d2e0defb52130de3295a576ac1e7b","4c835cc1a7b07477a469cdb1bf6c67bc05b85c07"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"]},"commit2Childs":{"c6e1dc1bb4254226c8d7151b596cc1be40671751":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"8381eb1cd44d2e0defb52130de3295a576ac1e7b":["4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"1f1f31880696765d6aec499d3b01fa501129af45":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["8381eb1cd44d2e0defb52130de3295a576ac1e7b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e511b092029d56e0d4e30204fba8509c1c2647b6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e511b092029d56e0d4e30204fba8509c1c2647b6":["8381eb1cd44d2e0defb52130de3295a576ac1e7b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"6198e18a87837d41cdd5df8c554e124619d99e4c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","6198e18a87837d41cdd5df8c554e124619d99e4c"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["1f1f31880696765d6aec499d3b01fa501129af45","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}