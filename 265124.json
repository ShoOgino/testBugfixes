{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          scratchBytesRef.copy(termEnum.term().text());\n          return current = scratchBytesRef;\n        }\n      }\n      if (termEnum.next()) {\n        final Term t = termEnum.term();\n        if (t.field() == fieldInfo.name) {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n          return current;\n        } else {\n          assert !t.field().equals(fieldInfo.name);  // make sure field name is interned\n          // Crossed into new field\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          scratchBytesRef.copy(termEnum.term().text());\n          return current = scratchBytesRef;\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          scratchBytesRef.copy(termEnum.term().text());\n          return current = scratchBytesRef;\n        }\n      }\n      if (termEnum.next()) {\n        final Term t = termEnum.term();\n        if (t.field() == fieldInfo.name) {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n          return current;\n        } else {\n          assert !t.field().equals(fieldInfo.name);  // make sure field name is interned\n          // Crossed into new field\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          scratchBytesRef.copy(termEnum.term().text());\n          return current = scratchBytesRef;\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          scratchBytesRef.copy(termEnum.term().text());\n          return current = scratchBytesRef;\n        }\n      }\n      if (termEnum.next()) {\n        final Term t = termEnum.term();\n        if (t.field() == fieldInfo.name) {\n          scratchBytesRef.copy(t.text());\n          current = scratchBytesRef;\n          return current;\n        } else {\n          assert !t.field().equals(fieldInfo.name);  // make sure field name is interned\n          // Crossed into new field\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next() skipNext=\" + skipNext);\n      }\n      if (skipNext) {\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  set newSuffixStart=\" + newSuffixStart);\n        }\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force pop\");\n        }\n        // force pop\n        newSuffixStart = -1;\n        surrogatesDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        // PreFlex codec interns field names:\n        } else if (termEnum.term().field() != internedFieldName) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == internedFieldName) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        // PreFlex codec interns field names:\n        } else if (termEnum.term().field() != internedFieldName) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == internedFieldName) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        // PreFlex codec interns field names:\n        } else if (termEnum.term().field() != internedFieldName) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == internedFieldName) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        } else if (termEnum.term().field() != fieldInfo.name) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == fieldInfo.name) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != fieldInfo.name) {\n          assert t == null || !t.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#next().mjava","sourceNew":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        // PreFlex codec interns field names:\n        } else if (termEnum.term().field() != internedFieldName) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == internedFieldName) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public BytesRef next() throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.next()\");\n      }\n      if (skipNext) {\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  skipNext=true\");\n        }\n        skipNext = false;\n        if (termEnum.term() == null) {\n          return null;\n        // PreFlex codec interns field names:\n        } else if (termEnum.term().field() != internedFieldName) {\n          return null;\n        } else {\n          return current = termEnum.term().bytes();\n        }\n      }\n\n      // TODO: can we use STE's prevBuffer here?\n      prevTerm.copy(termEnum.term().bytes());\n\n      if (termEnum.next() && termEnum.term().field() == internedFieldName) {\n        newSuffixStart = termEnum.newSuffixStart;\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  newSuffixStart=\" + newSuffixStart);\n        }\n        surrogateDance();\n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          current = null;\n        } else {\n          current = t.bytes();\n        }\n        return current;\n      } else {\n        // This field is exhausted, but we have to give\n        // surrogateDance a chance to seek back:\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  force cont\");\n        }\n        //newSuffixStart = prevTerm.length;\n        newSuffixStart = 0;\n        surrogateDance();\n        \n        final Term t = termEnum.term();\n        if (t == null || t.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t == null || !t.field().equals(internedFieldName);\n          return null;\n        } else {\n          current = t.bytes();\n          return current;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["08932c793647a36953d1816b1060121f48820d3f"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"2553b00f699380c64959ccb27991289aae87be2e":["4b103252dee6afa1b6d7a622c773d178788eb85a","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["4b103252dee6afa1b6d7a622c773d178788eb85a","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"7b91922b55d15444d554721b352861d028eb8278":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"08932c793647a36953d1816b1060121f48820d3f":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57","5f4e87790277826a2aea119328600dfb07761f32"],"3242a09f703274d3b9283f2064a1a33064b53a1b":[],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","7b91922b55d15444d554721b352861d028eb8278"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","08932c793647a36953d1816b1060121f48820d3f"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08932c793647a36953d1816b1060121f48820d3f":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3242a09f703274d3b9283f2064a1a33064b53a1b","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}