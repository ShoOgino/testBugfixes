{"path":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(FSTCompiler.UnCompiledNode[T]).mjava","commits":[{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(FSTCompiler.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((FSTCompiler.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/NodeHash#hash(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(FSTCompiler.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((FSTCompiler.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","sourceOld":"  // hash code for an unfrozen node.  This must be identical\n  // to the frozen case (below)!!\n  private long hash(Builder.UnCompiledNode<T> node) {\n    final int PRIME = 31;\n    //System.out.println(\"hash unfrozen\");\n    long h = 0;\n    // TODO: maybe if number of arcs is high we can safely subsample?\n    for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = node.arcs[arcIdx];\n      //System.out.println(\"  label=\" + arc.label + \" target=\" + ((Builder.CompiledNode) arc.target).node + \" h=\" + h + \" output=\" + fst.outputs.outputToString(arc.output) + \" isFinal?=\" + arc.isFinal);\n      h = PRIME * h + arc.label;\n      long n = ((Builder.CompiledNode) arc.target).node;\n      h = PRIME * h + (int) (n^(n>>32));\n      h = PRIME * h + arc.output.hashCode();\n      h = PRIME * h + arc.nextFinalOutput.hashCode();\n      if (arc.isFinal) {\n        h += 17;\n      }\n    }\n    //System.out.println(\"  ret \" + (h&Integer.MAX_VALUE));\n    return h & Long.MAX_VALUE;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}