{"path":"lucene/core/src/test/org/apache/lucene/index/TestReaderWrapperDVTypeCheck#testNoDVFieldOnSegment().mjava","commits":[{"id":"f0764b2ccb75b631aac6dfbfaca0d91f78acd813","date":1438795032,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestReaderWrapperDVTypeCheck#testNoDVFieldOnSegment().mjava","pathOld":"/dev/null","sourceNew":"  public void testNoDVFieldOnSegment() throws IOException{\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random())).setCodec(TestUtil.alwaysDocValuesFormat(TestUtil.getDefaultDocValuesFormat()));\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    \n    boolean sdvExist = false;\n    boolean ssdvExist = false;\n    \n    final long seed = random().nextLong();\n    {\n      final Random indexRandom = new Random(seed);\n      final int docs;\n      docs = indexRandom.nextInt(4);\n     // System.out.println(\"docs:\"+docs);\n      \n      for(int i=0; i< docs; i++){\n        Document d = new Document();\n        d.add(newStringField(\"id\", \"\"+i, Store.NO));\n        if (rarely(indexRandom)) {\n         // System.out.println(\"on:\"+i+\" rarely: true\");\n          d.add(new SortedDocValuesField(\"sdv\", new BytesRef(\"\"+i)));\n          sdvExist = true;\n        }else{\n         // System.out.println(\"on:\"+i+\" rarely: false\");\n        }\n        final int numSortedSet = indexRandom.nextInt(5)-3;\n        for (int j = 0; j < numSortedSet; ++j) {\n         // System.out.println(\"on:\"+i+\" add ssdv:\"+j);\n          d.add(new SortedSetDocValuesField(\"ssdv\", new BytesRef(\"\"+j)));\n          ssdvExist = true;\n        }\n        iw.addDocument(d);\n        iw.commit();\n      }\n    }\n    final DirectoryReader reader = iw.getReader();\n    \n   // System.out.println(\"sdv:\"+ sdvExist+ \" ssdv:\"+ssdvExist+\", segs: \"+reader.leaves().size() +\", \"+reader.leaves());\n    \n    iw.close();\n    final LeafReader wrapper = SlowCompositeReaderWrapper.wrap(reader);\n    \n    {\n      //final Random indexRandom = new Random(seed);\n      final SortedDocValues sdv = wrapper.getSortedDocValues(\"sdv\");\n      final SortedSetDocValues ssdv = wrapper.getSortedSetDocValues(\"ssdv\");\n      \n      assertNull(\"confusing DV type\", wrapper.getSortedDocValues(\"ssdv\"));\n      assertNull(\"confusing DV type\", wrapper.getSortedSetDocValues(\"sdv\"));\n      \n      assertNull(\"absent field\", wrapper.getSortedDocValues(\"NOssdv\"));\n      assertNull(\"absent field\", wrapper.getSortedSetDocValues(\"NOsdv\"));\n      \n      assertTrue(\"optional sdv field\", sdvExist == (sdv!=null));\n      assertTrue(\"optional ssdv field\", ssdvExist == (ssdv!=null));\n    } \n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestReaderWrapperDVTypeCheck#testNoDVFieldOnSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestReaderWrapperDVTypeCheck#testNoDVFieldOnSegment().mjava","sourceNew":"  public void testNoDVFieldOnSegment() throws IOException{\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random())).setCodec(TestUtil.alwaysDocValuesFormat(TestUtil.getDefaultDocValuesFormat()));\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    \n    boolean sdvExist = false;\n    boolean ssdvExist = false;\n    \n    final long seed = random().nextLong();\n    {\n      final Random indexRandom = new Random(seed);\n      final int docs;\n      docs = TestUtil.nextInt(indexRandom, 1, 4);\n     // System.out.println(\"docs:\"+docs);\n      \n      for(int i=0; i< docs; i++){\n        Document d = new Document();\n        d.add(newStringField(\"id\", \"\"+i, Store.NO));\n        if (rarely(indexRandom)) {\n         // System.out.println(\"on:\"+i+\" rarely: true\");\n          d.add(new SortedDocValuesField(\"sdv\", new BytesRef(\"\"+i)));\n          sdvExist = true;\n        }else{\n         // System.out.println(\"on:\"+i+\" rarely: false\");\n        }\n        final int numSortedSet = indexRandom.nextInt(5)-3;\n        for (int j = 0; j < numSortedSet; ++j) {\n         // System.out.println(\"on:\"+i+\" add ssdv:\"+j);\n          d.add(new SortedSetDocValuesField(\"ssdv\", new BytesRef(\"\"+j)));\n          ssdvExist = true;\n        }\n        iw.addDocument(d);\n        iw.commit();\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    \n   // System.out.println(\"sdv:\"+ sdvExist+ \" ssdv:\"+ssdvExist+\", segs: \"+reader.leaves().size() +\", \"+reader.leaves());\n    \n    iw.close();\n    final LeafReader wrapper = getOnlyLeafReader(reader);\n    \n    {\n      //final Random indexRandom = new Random(seed);\n      final SortedDocValues sdv = wrapper.getSortedDocValues(\"sdv\");\n      final SortedSetDocValues ssdv = wrapper.getSortedSetDocValues(\"ssdv\");\n      \n      assertNull(\"confusing DV type\", wrapper.getSortedDocValues(\"ssdv\"));\n      assertNull(\"confusing DV type\", wrapper.getSortedSetDocValues(\"sdv\"));\n      \n      assertNull(\"absent field\", wrapper.getSortedDocValues(\"NOssdv\"));\n      assertNull(\"absent field\", wrapper.getSortedSetDocValues(\"NOsdv\"));\n      \n      assertTrue(\"optional sdv field\", sdvExist == (sdv!=null));\n      assertTrue(\"optional ssdv field\", ssdvExist == (ssdv!=null));\n    } \n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testNoDVFieldOnSegment() throws IOException{\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random())).setCodec(TestUtil.alwaysDocValuesFormat(TestUtil.getDefaultDocValuesFormat()));\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    \n    boolean sdvExist = false;\n    boolean ssdvExist = false;\n    \n    final long seed = random().nextLong();\n    {\n      final Random indexRandom = new Random(seed);\n      final int docs;\n      docs = indexRandom.nextInt(4);\n     // System.out.println(\"docs:\"+docs);\n      \n      for(int i=0; i< docs; i++){\n        Document d = new Document();\n        d.add(newStringField(\"id\", \"\"+i, Store.NO));\n        if (rarely(indexRandom)) {\n         // System.out.println(\"on:\"+i+\" rarely: true\");\n          d.add(new SortedDocValuesField(\"sdv\", new BytesRef(\"\"+i)));\n          sdvExist = true;\n        }else{\n         // System.out.println(\"on:\"+i+\" rarely: false\");\n        }\n        final int numSortedSet = indexRandom.nextInt(5)-3;\n        for (int j = 0; j < numSortedSet; ++j) {\n         // System.out.println(\"on:\"+i+\" add ssdv:\"+j);\n          d.add(new SortedSetDocValuesField(\"ssdv\", new BytesRef(\"\"+j)));\n          ssdvExist = true;\n        }\n        iw.addDocument(d);\n        iw.commit();\n      }\n    }\n    final DirectoryReader reader = iw.getReader();\n    \n   // System.out.println(\"sdv:\"+ sdvExist+ \" ssdv:\"+ssdvExist+\", segs: \"+reader.leaves().size() +\", \"+reader.leaves());\n    \n    iw.close();\n    final LeafReader wrapper = SlowCompositeReaderWrapper.wrap(reader);\n    \n    {\n      //final Random indexRandom = new Random(seed);\n      final SortedDocValues sdv = wrapper.getSortedDocValues(\"sdv\");\n      final SortedSetDocValues ssdv = wrapper.getSortedSetDocValues(\"ssdv\");\n      \n      assertNull(\"confusing DV type\", wrapper.getSortedDocValues(\"ssdv\"));\n      assertNull(\"confusing DV type\", wrapper.getSortedSetDocValues(\"sdv\"));\n      \n      assertNull(\"absent field\", wrapper.getSortedDocValues(\"NOssdv\"));\n      assertNull(\"absent field\", wrapper.getSortedSetDocValues(\"NOsdv\"));\n      \n      assertTrue(\"optional sdv field\", sdvExist == (sdv!=null));\n      assertTrue(\"optional ssdv field\", ssdvExist == (ssdv!=null));\n    } \n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":["f0764b2ccb75b631aac6dfbfaca0d91f78acd813"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["f0764b2ccb75b631aac6dfbfaca0d91f78acd813"],"f0764b2ccb75b631aac6dfbfaca0d91f78acd813":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"]},"commit2Childs":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0764b2ccb75b631aac6dfbfaca0d91f78acd813":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0764b2ccb75b631aac6dfbfaca0d91f78acd813"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}