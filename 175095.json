{"path":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","pathOld":"solr/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","sourceNew":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","sourceOld":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","pathOld":"solr/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","sourceNew":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","sourceOld":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","pathOld":"solr/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","sourceNew":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","sourceOld":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf383b090f66094eb20e23f13a7b9cf251b6b225","date":1572630056,"type":3,"author":"Chris Hennick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","sourceNew":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        if (parts.length == 0) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Operator < must be followed by a number\");\n        }\n        int upperBound = checkedParseInt(parts[0], \"Operator < must be followed by a number\");\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = checkedParseInt(spec,\n          \"% must be preceded by a number and not combined with other operators\");\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = checkedParseInt(spec, \"Input should be a number\");\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","sourceOld":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        int upperBound = Integer.parseInt(parts[0]);\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = Integer.parseInt(spec);\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = Integer.parseInt(spec);\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","bugFix":null,"bugIntro":["81c5ffe8a0562120e63faeb61dfb430c02506d89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"81c5ffe8a0562120e63faeb61dfb430c02506d89","date":1572648818,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils#calculateMinShouldMatch(int,String).mjava","sourceNew":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        if (parts.length < 2) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Invalid 'mm' spec: '\" + s + \"'. Expecting values before and after '<'\");\n        }\n        int upperBound = checkedParseInt(parts[0], \"Invalid 'mm' spec. Expecting an integer.\");\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = checkedParseInt(spec,\n          \"Invalid 'mm' spec. Expecting an integer.\");\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = checkedParseInt(spec, \"Invalid 'mm' spec. Expecting an integer.\");\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","sourceOld":"  /**\n   * helper exposed for UnitTests\n   * @see #setMinShouldMatch\n   */\n  static int calculateMinShouldMatch(int optionalClauseCount, String spec) {\n\n    int result = optionalClauseCount;\n    spec = spec.trim();\n\n    if (-1 < spec.indexOf(\"<\")) {\n      /* we have conditional spec(s) */\n      spec = spaceAroundLessThanPattern.matcher(spec).replaceAll(\"<\");\n      for (String s : spacePattern.split(spec)) {\n        String[] parts = lessThanPattern.split(s,0);\n        if (parts.length == 0) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Operator < must be followed by a number\");\n        }\n        int upperBound = checkedParseInt(parts[0], \"Operator < must be followed by a number\");\n        if (optionalClauseCount <= upperBound) {\n          return result;\n        } else {\n          result = calculateMinShouldMatch\n            (optionalClauseCount, parts[1]);\n        }\n      }\n      return result;\n    }\n\n    /* otherwise, simple expresion */\n\n    if (-1 < spec.indexOf('%')) {\n      /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */\n      spec = spec.substring(0,spec.length()-1);\n      int percent = checkedParseInt(spec,\n          \"% must be preceded by a number and not combined with other operators\");\n      float calc = (result * percent) * (1/100f);\n      result = calc < 0 ? result + (int)calc : (int)calc;\n    } else {\n      int calc = checkedParseInt(spec, \"Input should be a number\");\n      result = calc < 0 ? result + calc : calc;\n    }\n\n    return (optionalClauseCount < result ?\n            optionalClauseCount : (result < 0 ? 0 : result));\n\n  }\n\n","bugFix":["bf383b090f66094eb20e23f13a7b9cf251b6b225"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81c5ffe8a0562120e63faeb61dfb430c02506d89":["bf383b090f66094eb20e23f13a7b9cf251b6b225"],"bf383b090f66094eb20e23f13a7b9cf251b6b225":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["81c5ffe8a0562120e63faeb61dfb430c02506d89"]},"commit2Childs":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["bf383b090f66094eb20e23f13a7b9cf251b6b225"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"81c5ffe8a0562120e63faeb61dfb430c02506d89":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bf383b090f66094eb20e23f13a7b9cf251b6b225":["81c5ffe8a0562120e63faeb61dfb430c02506d89"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}