{"path":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","commits":[{"id":"d76cc03e194de1d38d6103ec919c69c6afb4a368","date":1197110551,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc6ab6902f8f70ae43365947ccf44c25986906d","date":1204603577,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01662594506f6ffb274ec1d73949d3293f33f833","date":1207693821,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2260eb06d096758775490c012567f349c9083af3","date":1207697722,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e044e8e87dc850b8892279a7618e1fe8fb2a3f4","date":1212110936,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.fine(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.fine(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3f722aaea0c06773a393c2b0d41079ba5cb8b0a","date":1216417422,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.fine(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.fine(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.fine(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.fine(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n\n          copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n        }\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.fine(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.fine(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warning(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"72cd269b00ce636078acda21f4b6f920b75dba13","date":1225131045,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(solrConfig.getResourceLoader(), \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = solrConfig.getResourceLoader().newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55883d09343e80968c5e44b9c14da13238544a0a","date":1228020380,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        registerCopyField(source, dest);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"136474862e64b544138ffcc13abd72e17d84b452","date":1250709916,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get an ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"349954f4394157816ec1ed15691a5f3e18638c0c","date":1259182074,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":["8f2c5389fcac652b2b765661515d7bc3e4e19937","8f2c5389fcac652b2b765661515d7bc3e4e19937","8f2c5389fcac652b2b765661515d7bc3e4e19937"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abec2fd822be07fc74ef5ba3609b9c5625a87d6d","date":1261659802,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.debug(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n  }\n\n","bugFix":null,"bugIntro":["9d62f72d1c60d2be239222de52d5e7b516da5f6f","9d62f72d1c60d2be239222de52d5e7b516da5f6f","9d62f72d1c60d2be239222de52d5e7b516da5f6f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["349954f4394157816ec1ed15691a5f3e18638c0c"],"2260eb06d096758775490c012567f349c9083af3":["01662594506f6ffb274ec1d73949d3293f33f833"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["d76cc03e194de1d38d6103ec919c69c6afb4a368"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["c3f722aaea0c06773a393c2b0d41079ba5cb8b0a"],"55883d09343e80968c5e44b9c14da13238544a0a":["72cd269b00ce636078acda21f4b6f920b75dba13"],"8e044e8e87dc850b8892279a7618e1fe8fb2a3f4":["2260eb06d096758775490c012567f349c9083af3"],"d76cc03e194de1d38d6103ec919c69c6afb4a368":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"349954f4394157816ec1ed15691a5f3e18638c0c":["136474862e64b544138ffcc13abd72e17d84b452"],"72cd269b00ce636078acda21f4b6f920b75dba13":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c3f722aaea0c06773a393c2b0d41079ba5cb8b0a":["8e044e8e87dc850b8892279a7618e1fe8fb2a3f4"],"01662594506f6ffb274ec1d73949d3293f33f833":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"ad94625fb8d088209f46650c8097196fec67f00c":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"136474862e64b544138ffcc13abd72e17d84b452":["55883d09343e80968c5e44b9c14da13238544a0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["ad94625fb8d088209f46650c8097196fec67f00c"],"2260eb06d096758775490c012567f349c9083af3":["8e044e8e87dc850b8892279a7618e1fe8fb2a3f4"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["01662594506f6ffb274ec1d73949d3293f33f833"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d76cc03e194de1d38d6103ec919c69c6afb4a368"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["72cd269b00ce636078acda21f4b6f920b75dba13"],"55883d09343e80968c5e44b9c14da13238544a0a":["136474862e64b544138ffcc13abd72e17d84b452"],"8e044e8e87dc850b8892279a7618e1fe8fb2a3f4":["c3f722aaea0c06773a393c2b0d41079ba5cb8b0a"],"d76cc03e194de1d38d6103ec919c69c6afb4a368":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"349954f4394157816ec1ed15691a5f3e18638c0c":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"72cd269b00ce636078acda21f4b6f920b75dba13":["55883d09343e80968c5e44b9c14da13238544a0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c3f722aaea0c06773a393c2b0d41079ba5cb8b0a":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"01662594506f6ffb274ec1d73949d3293f33f833":["2260eb06d096758775490c012567f349c9083af3"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"136474862e64b544138ffcc13abd72e17d84b452":["349954f4394157816ec1ed15691a5f3e18638c0c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}