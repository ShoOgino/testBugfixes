{"path":"contrib/extraction/src/main/java/org/apache/solr/handler/SolrContentHandler#newDocument().mjava","commits":[{"id":"868e0ed16bb29556f95c00e989da33ab5c9dfe56","date":1228568666,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/SolrContentHandler#newDocument().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dfcd540005e76a7db876d494ac74e82c476523","date":1229095104,"type":5,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"868e0ed16bb29556f95c00e989da33ab5c9dfe56":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"46dfcd540005e76a7db876d494ac74e82c476523":["868e0ed16bb29556f95c00e989da33ab5c9dfe56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["868e0ed16bb29556f95c00e989da33ab5c9dfe56"],"868e0ed16bb29556f95c00e989da33ab5c9dfe56":["46dfcd540005e76a7db876d494ac74e82c476523"],"46dfcd540005e76a7db876d494ac74e82c476523":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["46dfcd540005e76a7db876d494ac74e82c476523","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}