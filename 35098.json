{"path":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","commits":[{"id":"166170a424a34de012e5bfe2f46f82466c6c2f3f","date":1433621012,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  @BaseDistributedSearchTestCase.ShardsFixed(num = 3)\n  public void testRequestTracking() throws Exception {\n    waitForThingsToLevelOut(30);\n\n    List<String> nodeNames = new ArrayList<>(3);\n    for (CloudJettyRunner cloudJetty : cloudJettys) {\n      nodeNames.add(cloudJetty.nodeName);\n    }\n    assertEquals(3, nodeNames.size());\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState(true);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["95567ffebdd88fc5795f5e84677deec98fb23d02","791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  @Test\n  @BaseDistributedSearchTestCase.ShardsFixed(num = 3)\n  public void testRequestTracking() throws Exception {\n    waitForThingsToLevelOut(30);\n\n    List<String> nodeNames = new ArrayList<>(3);\n    for (CloudJettyRunner cloudJetty : cloudJettys) {\n      nodeNames.add(cloudJetty.nodeName);\n    }\n    assertEquals(3, nodeNames.size());\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BaseDistributedSearchTestCase.ShardsFixed(num = 3)\n  public void testRequestTracking() throws Exception {\n    waitForThingsToLevelOut(30);\n\n    List<String> nodeNames = new ArrayList<>(3);\n    for (CloudJettyRunner cloudJetty : cloudJettys) {\n      nodeNames.add(cloudJetty.nodeName);\n    }\n    assertEquals(3, nodeNames.size());\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState(true);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"791c4fb1ff970967cf1802cf4d4875ba12c2eb01","date":1446659977,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BaseDistributedSearchTestCase.ShardsFixed(num = 3)\n  public void testRequestTracking() throws Exception {\n    waitForThingsToLevelOut(30);\n\n    List<String> nodeNames = new ArrayList<>(3);\n    for (CloudJettyRunner cloudJetty : cloudJettys) {\n      nodeNames.add(cloudJetty.nodeName);\n    }\n    assertEquals(3, nodeNames.size());\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":["166170a424a34de012e5bfe2f46f82466c6c2f3f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1088b72b3b4cc45316b7595bd09023c859cd2327","date":1447150009,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) runner.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":["95567ffebdd88fc5795f5e84677deec98fb23d02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\");\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n    for (int i=0; i < 10; i++)  {\n      client.query(new SolrQuery(\"*:*\"));\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":["95567ffebdd88fc5795f5e84677deec98fb23d02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = new HttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":["95567ffebdd88fc5795f5e84677deec98fb23d02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) c);\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"a1x2\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"b1x1\")\n        .setNumShards(1)\n        .setReplicationFactor(1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"197bbedf08450ade98a11f4a0001448059666bec","date":1498534625,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":["95567ffebdd88fc5795f5e84677deec98fb23d02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\",1,1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY.standard\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\")) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95567ffebdd88fc5795f5e84677deec98fb23d02","date":1499722893,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already recieved some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":["859081acf00749f5dd462772c571d611d4a4d2db","166170a424a34de012e5bfe2f46f82466c6c2f3f","5ff704ef91e9ae30ca59babb23ece85720701b60","816521ebaad5add9cb96bb88c577394e2938c40b","1088b72b3b4cc45316b7595bd09023c859cd2327"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9a989a32a073c55e3aef6f807a3474184bbcf49","date":1499930209,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already recieved some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb569fd721c41eafc2a2d788499a7df490c7f1a5","date":1499930871,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already recieved some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      for (int i = 0; i < 10; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n      }\n    }\n\n    Map<String, Integer> shardVsCount = new HashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        String registry = core.getCoreMetricManager().getRegistryName();\n        Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n        SolrRequestHandler select = core.getRequestHandler(\"\");\n//        long c = (long) select.getStatistics().get(\"requests\");\n        shardVsCount.put(core.getName(), (int) cnt.getCount());\n      }\n    }\n\n    log.info(\"Shard count map = \" + shardVsCount);\n\n    for (Map.Entry<String, Integer> entry : shardVsCount.entrySet()) {\n      assertTrue(\"Shard \" + entry.getKey() + \" received all 10 requests\", entry.getValue() != 10);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaa02448ea938c1621e4568c32a47df8b1590926","date":1508327945,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already received some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already recieved some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testRequestTracking().mjava","sourceNew":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already received some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to {} a1x2\", baseUrl);\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: {}\", expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests aren't always sent to the same poor node. See SOLR-7493\n   */\n  private void testRequestTracking() throws Exception {\n\n    CollectionAdminRequest.createCollection(\"a1x2\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    CollectionAdminRequest.createCollection(\"b1x1\", \"conf1\", 1, 1)\n        .setCreateNodeSet(nodeNames.get(2))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"a1x2\", true);\n    waitForRecoveriesToFinish(\"b1x1\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"b1x1\");\n\n    // get direct access to the metrics counters for each core/replica we're interested to monitor them\n    final Map<String,Counter> counters = new LinkedHashMap<>();\n    for (JettySolrRunner runner : jettys) {\n      CoreContainer container = runner.getCoreContainer();\n      SolrMetricManager metricManager = container.getMetricManager();\n      for (SolrCore core : container.getCores()) {\n        if (\"a1x2\".equals(core.getCoreDescriptor().getCollectionName())) {\n          String registry = core.getCoreMetricManager().getRegistryName();\n          Counter cnt = metricManager.counter(null, registry, \"requests\", \"QUERY./select\");\n          // sanity check\n          assertEquals(core.getName() + \" has already received some requests?\",\n                       0, cnt.getCount());\n          counters.put(core.getName(), cnt);\n        }\n      }\n    }\n    assertEquals(\"Sanity Check: we know there should be 2 replicas\", 2, counters.size());\n\n    // send queries to the node that doesn't host any core/replica and see where it routes them\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection b1x1 = clusterState.getCollection(\"b1x1\");\n    Collection<Replica> replicas = b1x1.getSlice(\"shard1\").getReplicas();\n    assertEquals(1, replicas.size());\n    String baseUrl = replicas.iterator().next().getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    try (HttpSolrClient client = getHttpSolrClient(baseUrl + \"a1x2\", 2000, 5000)) {\n\n      long expectedTotalRequests = 0;\n      Set<String> uniqueCoreNames = new LinkedHashSet<>();\n      \n      log.info(\"Making requests to \" + baseUrl + \"a1x2\");\n      while (uniqueCoreNames.size() < counters.keySet().size() && expectedTotalRequests < 1000L) {\n        expectedTotalRequests++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long actualTotalRequests = 0;\n        for (Map.Entry<String,Counter> e : counters.entrySet()) {\n          final long coreCount = e.getValue().getCount();\n          actualTotalRequests += coreCount;\n          if (0 < coreCount) {\n            uniqueCoreNames.add(e.getKey());\n          }\n        }\n        assertEquals(\"Sanity Check: Num Queries So Far Doesn't Match Total????\",\n                     expectedTotalRequests, actualTotalRequests);\n      }\n      log.info(\"Total requests: \" + expectedTotalRequests);\n      assertEquals(\"either request randomization code is broken of this test seed is really unlucky, \" +\n                   \"Gave up waiting for requests to hit every core at least once after \" +\n                   expectedTotalRequests + \" requests\",\n                   uniqueCoreNames.size(), counters.size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"197bbedf08450ade98a11f4a0001448059666bec":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["859081acf00749f5dd462772c571d611d4a4d2db"],"791c4fb1ff970967cf1802cf4d4875ba12c2eb01":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["eaa02448ea938c1621e4568c32a47df8b1590926"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","95567ffebdd88fc5795f5e84677deec98fb23d02"],"95567ffebdd88fc5795f5e84677deec98fb23d02":["43d1e498704edd2bba13548a189eed4dfccff11b"],"43d1e498704edd2bba13548a189eed4dfccff11b":["28288370235ed02234a64753cdbf0c6ec096304a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["30c8e5574b55d57947e989443dfde611646530ee","43d1e498704edd2bba13548a189eed4dfccff11b"],"eaa02448ea938c1621e4568c32a47df8b1590926":["95567ffebdd88fc5795f5e84677deec98fb23d02"],"166170a424a34de012e5bfe2f46f82466c6c2f3f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["e9017cf144952056066919f1ebc7897ff9bd71b1","197bbedf08450ade98a11f4a0001448059666bec"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["166170a424a34de012e5bfe2f46f82466c6c2f3f"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["816521ebaad5add9cb96bb88c577394e2938c40b"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"30c8e5574b55d57947e989443dfde611646530ee":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","28288370235ed02234a64753cdbf0c6ec096304a"],"3217321f3e1d7922898c6c633d17acfa840d6875":["816521ebaad5add9cb96bb88c577394e2938c40b","ac97ea104d893f16aab430d9904473bc1f233f3c"],"816521ebaad5add9cb96bb88c577394e2938c40b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"28288370235ed02234a64753cdbf0c6ec096304a":["3217321f3e1d7922898c6c633d17acfa840d6875","5ff704ef91e9ae30ca59babb23ece85720701b60"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["816521ebaad5add9cb96bb88c577394e2938c40b","3217321f3e1d7922898c6c633d17acfa840d6875"],"859081acf00749f5dd462772c571d611d4a4d2db":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"1088b72b3b4cc45316b7595bd09023c859cd2327":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["859081acf00749f5dd462772c571d611d4a4d2db","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["197bbedf08450ade98a11f4a0001448059666bec"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"197bbedf08450ade98a11f4a0001448059666bec":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","5ff704ef91e9ae30ca59babb23ece85720701b60"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"791c4fb1ff970967cf1802cf4d4875ba12c2eb01":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["859081acf00749f5dd462772c571d611d4a4d2db"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"95567ffebdd88fc5795f5e84677deec98fb23d02":["f9a989a32a073c55e3aef6f807a3474184bbcf49","eaa02448ea938c1621e4568c32a47df8b1590926"],"43d1e498704edd2bba13548a189eed4dfccff11b":["95567ffebdd88fc5795f5e84677deec98fb23d02","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["f9a989a32a073c55e3aef6f807a3474184bbcf49","fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"eaa02448ea938c1621e4568c32a47df8b1590926":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"166170a424a34de012e5bfe2f46f82466c6c2f3f":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["166170a424a34de012e5bfe2f46f82466c6c2f3f"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["30c8e5574b55d57947e989443dfde611646530ee"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":[],"30c8e5574b55d57947e989443dfde611646530ee":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"3217321f3e1d7922898c6c633d17acfa840d6875":["28288370235ed02234a64753cdbf0c6ec096304a","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["197bbedf08450ade98a11f4a0001448059666bec","e9017cf144952056066919f1ebc7897ff9bd71b1"],"28288370235ed02234a64753cdbf0c6ec096304a":["43d1e498704edd2bba13548a189eed4dfccff11b","30c8e5574b55d57947e989443dfde611646530ee"],"816521ebaad5add9cb96bb88c577394e2938c40b":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"859081acf00749f5dd462772c571d611d4a4d2db":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"1088b72b3b4cc45316b7595bd09023c859cd2327":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fb569fd721c41eafc2a2d788499a7df490c7f1a5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}