{"path":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","commits":[{"id":"18d5909e20e4300fc5752d53c78ac5bb7d621da7","date":1463541567,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","pathOld":"/dev/null","sourceNew":"  public void testToStringISO8601() {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef21c3e4f7685689c910b82c419b8a462e3cf212","date":1463569645,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","pathOld":"/dev/null","sourceNew":"  public void testToStringISO8601() {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","pathOld":"/dev/null","sourceNew":"  public void testToStringISO8601() {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","pathOld":"/dev/null","sourceNew":"  public void testToStringISO8601() {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50aeb34a24c3517f5c50aa5020590923e82f584e","date":1548663274,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","pathOld":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTreeTest#testToStringISO8601().mjava","sourceNew":"  public void testToStringISO8601() throws ParseException {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n    assertEquals(cal, tree.parseCalendar(expectedISO8601));\n  }\n\n","sourceOld":"  public void testToStringISO8601() {\n    Calendar cal = tree.newCal();\n    cal.setTimeInMillis(random().nextLong());\n    //  create ZonedDateTime from the calendar, then get toInstant.toString which is the ISO8601 we emulate\n    //   note: we don't simply init off of millisEpoch because of possible GregorianChangeDate discrepancy.\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == 0) { // BC\n      year = -year + 1;\n    }\n    String expectedISO8601 =\n        ZonedDateTime.of(year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n          cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND),\n          cal.get(Calendar.MILLISECOND) * 1_000_000, ZoneOffset.UTC)\n            .toInstant().toString();\n    String resultToString = tree.toString(cal) + 'Z';\n    assertEquals(expectedISO8601, resultToString);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ef21c3e4f7685689c910b82c419b8a462e3cf212":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","18d5909e20e4300fc5752d53c78ac5bb7d621da7"],"18d5909e20e4300fc5752d53c78ac5bb7d621da7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"50aeb34a24c3517f5c50aa5020590923e82f584e":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50aeb34a24c3517f5c50aa5020590923e82f584e"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ef21c3e4f7685689c910b82c419b8a462e3cf212"]},"commit2Childs":{"ef21c3e4f7685689c910b82c419b8a462e3cf212":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"18d5909e20e4300fc5752d53c78ac5bb7d621da7":["ef21c3e4f7685689c910b82c419b8a462e3cf212"],"50aeb34a24c3517f5c50aa5020590923e82f584e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ef21c3e4f7685689c910b82c419b8a462e3cf212","18d5909e20e4300fc5752d53c78ac5bb7d621da7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["50aeb34a24c3517f5c50aa5020590923e82f584e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}