{"path":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","commits":[{"id":"0d8448be43e6bd7d69aa0227187fca146a1f2262","date":1338393518,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by breaking the passed-in term into multiple words.\n   * The scores returned are equal to the number of word breaks needed so a\n   * lower score is generally preferred over a higher score.\n   * </p>\n   * \n   * @param term\n   * @param maxSuggestions\n   * @param ir\n   * @param suggestMode\n   *          - default = {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}\n   * @param sortMethod\n   *          - default =\n   *          {@link BreakSuggestionSortMethod#NUM_CHANGES_THEN_MAX_FREQUENCY}\n   * @return one or more arrays of words formed by breaking up the original term\n   * @throws IOException\n   */\n  public SuggestWord[][] suggestWordBreaks(Term term, int maxSuggestions,\n      IndexReader ir, SuggestMode suggestMode,\n      BreakSuggestionSortMethod sortMethod) throws IOException {\n    if (maxSuggestions < 1) {\n      return new SuggestWord[0][0];\n    }\n    if (suggestMode == null) {\n      suggestMode = SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    }\n    if (sortMethod == null) {\n      sortMethod = BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY;\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<SuggestWordArrayWrapper> queueComparator = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? new LengthThenMaxFreqComparator()\n        : new LengthThenSumFreqComparator();\n    Queue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<SuggestWordArrayWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int origFreq = ir.docFreq(term);\n    if (origFreq > 0 && suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX) {\n      return new SuggestWord[0][];\n    }\n    \n    int useMinSuggestionFrequency = minSuggestionFrequency;\n    if (suggestMode == SuggestMode.SUGGEST_MORE_POPULAR) {\n      useMinSuggestionFrequency = (origFreq == 0 ? 1 : origFreq);\n    }\n    \n    generateBreakUpSuggestions(term, ir, 1, maxSuggestions,\n        useMinSuggestionFrequency, new SuggestWord[0], suggestions, 0,\n        sortMethod);\n    \n    SuggestWord[][] suggestionArray = new SuggestWord[suggestions.size()][];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      suggestionArray[i] = suggestions.remove().suggestWords;\n    }\n    \n    return suggestionArray;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by breaking the passed-in term into multiple words.\n   * The scores returned are equal to the number of word breaks needed so a\n   * lower score is generally preferred over a higher score.\n   * </p>\n   * \n   * @param suggestMode\n   *          - default = {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}\n   * @param sortMethod\n   *          - default =\n   *          {@link BreakSuggestionSortMethod#NUM_CHANGES_THEN_MAX_FREQUENCY}\n   * @return one or more arrays of words formed by breaking up the original term\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[][] suggestWordBreaks(Term term, int maxSuggestions,\n      IndexReader ir, SuggestMode suggestMode,\n      BreakSuggestionSortMethod sortMethod) throws IOException {\n    if (maxSuggestions < 1) {\n      return new SuggestWord[0][0];\n    }\n    if (suggestMode == null) {\n      suggestMode = SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    }\n    if (sortMethod == null) {\n      sortMethod = BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY;\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<SuggestWordArrayWrapper> queueComparator = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? new LengthThenMaxFreqComparator()\n        : new LengthThenSumFreqComparator();\n    Queue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<SuggestWordArrayWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int origFreq = ir.docFreq(term);\n    if (origFreq > 0 && suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX) {\n      return new SuggestWord[0][];\n    }\n    \n    int useMinSuggestionFrequency = minSuggestionFrequency;\n    if (suggestMode == SuggestMode.SUGGEST_MORE_POPULAR) {\n      useMinSuggestionFrequency = (origFreq == 0 ? 1 : origFreq);\n    }\n    \n    generateBreakUpSuggestions(term, ir, 1, maxSuggestions,\n        useMinSuggestionFrequency, new SuggestWord[0], suggestions, 0,\n        sortMethod);\n    \n    SuggestWord[][] suggestionArray = new SuggestWord[suggestions.size()][];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      suggestionArray[i] = suggestions.remove().suggestWords;\n    }\n    \n    return suggestionArray;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by breaking the passed-in term into multiple words.\n   * The scores returned are equal to the number of word breaks needed so a\n   * lower score is generally preferred over a higher score.\n   * </p>\n   * \n   * @param term\n   * @param maxSuggestions\n   * @param ir\n   * @param suggestMode\n   *          - default = {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}\n   * @param sortMethod\n   *          - default =\n   *          {@link BreakSuggestionSortMethod#NUM_CHANGES_THEN_MAX_FREQUENCY}\n   * @return one or more arrays of words formed by breaking up the original term\n   * @throws IOException\n   */\n  public SuggestWord[][] suggestWordBreaks(Term term, int maxSuggestions,\n      IndexReader ir, SuggestMode suggestMode,\n      BreakSuggestionSortMethod sortMethod) throws IOException {\n    if (maxSuggestions < 1) {\n      return new SuggestWord[0][0];\n    }\n    if (suggestMode == null) {\n      suggestMode = SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    }\n    if (sortMethod == null) {\n      sortMethod = BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY;\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<SuggestWordArrayWrapper> queueComparator = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? new LengthThenMaxFreqComparator()\n        : new LengthThenSumFreqComparator();\n    Queue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<SuggestWordArrayWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int origFreq = ir.docFreq(term);\n    if (origFreq > 0 && suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX) {\n      return new SuggestWord[0][];\n    }\n    \n    int useMinSuggestionFrequency = minSuggestionFrequency;\n    if (suggestMode == SuggestMode.SUGGEST_MORE_POPULAR) {\n      useMinSuggestionFrequency = (origFreq == 0 ? 1 : origFreq);\n    }\n    \n    generateBreakUpSuggestions(term, ir, 1, maxSuggestions,\n        useMinSuggestionFrequency, new SuggestWord[0], suggestions, 0,\n        sortMethod);\n    \n    SuggestWord[][] suggestionArray = new SuggestWord[suggestions.size()][];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      suggestionArray[i] = suggestions.remove().suggestWords;\n    }\n    \n    return suggestionArray;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordBreaks(Term,int,IndexReader,SuggestMode,BreakSuggestionSortMethod).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by breaking the passed-in term into multiple words.\n   * The scores returned are equal to the number of word breaks needed so a\n   * lower score is generally preferred over a higher score.\n   * </p>\n   * \n   * @param suggestMode\n   *          - default = {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}\n   * @param sortMethod\n   *          - default =\n   *          {@link BreakSuggestionSortMethod#NUM_CHANGES_THEN_MAX_FREQUENCY}\n   * @return one or more arrays of words formed by breaking up the original term\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[][] suggestWordBreaks(Term term, int maxSuggestions,\n      IndexReader ir, SuggestMode suggestMode,\n      BreakSuggestionSortMethod sortMethod) throws IOException {\n    if (maxSuggestions < 1) {\n      return new SuggestWord[0][0];\n    }\n    if (suggestMode == null) {\n      suggestMode = SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    }\n    if (sortMethod == null) {\n      sortMethod = BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY;\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<SuggestWordArrayWrapper> queueComparator = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? new LengthThenMaxFreqComparator()\n        : new LengthThenSumFreqComparator();\n    Queue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<>(\n        queueInitialCapacity, queueComparator);\n    \n    int origFreq = ir.docFreq(term);\n    if (origFreq > 0 && suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX) {\n      return new SuggestWord[0][];\n    }\n    \n    int useMinSuggestionFrequency = minSuggestionFrequency;\n    if (suggestMode == SuggestMode.SUGGEST_MORE_POPULAR) {\n      useMinSuggestionFrequency = (origFreq == 0 ? 1 : origFreq);\n    }\n    \n    generateBreakUpSuggestions(term, ir, 1, maxSuggestions,\n        useMinSuggestionFrequency, new SuggestWord[0], suggestions, 0,\n        sortMethod);\n    \n    SuggestWord[][] suggestionArray = new SuggestWord[suggestions.size()][];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      suggestionArray[i] = suggestions.remove().suggestWords;\n    }\n    \n    return suggestionArray;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by breaking the passed-in term into multiple words.\n   * The scores returned are equal to the number of word breaks needed so a\n   * lower score is generally preferred over a higher score.\n   * </p>\n   * \n   * @param suggestMode\n   *          - default = {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}\n   * @param sortMethod\n   *          - default =\n   *          {@link BreakSuggestionSortMethod#NUM_CHANGES_THEN_MAX_FREQUENCY}\n   * @return one or more arrays of words formed by breaking up the original term\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[][] suggestWordBreaks(Term term, int maxSuggestions,\n      IndexReader ir, SuggestMode suggestMode,\n      BreakSuggestionSortMethod sortMethod) throws IOException {\n    if (maxSuggestions < 1) {\n      return new SuggestWord[0][0];\n    }\n    if (suggestMode == null) {\n      suggestMode = SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    }\n    if (sortMethod == null) {\n      sortMethod = BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY;\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<SuggestWordArrayWrapper> queueComparator = sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY ? new LengthThenMaxFreqComparator()\n        : new LengthThenSumFreqComparator();\n    Queue<SuggestWordArrayWrapper> suggestions = new PriorityQueue<SuggestWordArrayWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int origFreq = ir.docFreq(term);\n    if (origFreq > 0 && suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX) {\n      return new SuggestWord[0][];\n    }\n    \n    int useMinSuggestionFrequency = minSuggestionFrequency;\n    if (suggestMode == SuggestMode.SUGGEST_MORE_POPULAR) {\n      useMinSuggestionFrequency = (origFreq == 0 ? 1 : origFreq);\n    }\n    \n    generateBreakUpSuggestions(term, ir, 1, maxSuggestions,\n        useMinSuggestionFrequency, new SuggestWord[0], suggestions, 0,\n        sortMethod);\n    \n    SuggestWord[][] suggestionArray = new SuggestWord[suggestions.size()][];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      suggestionArray[i] = suggestions.remove().suggestWords;\n    }\n    \n    return suggestionArray;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["0d8448be43e6bd7d69aa0227187fca146a1f2262"],"0d8448be43e6bd7d69aa0227187fca146a1f2262":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0d8448be43e6bd7d69aa0227187fca146a1f2262":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d8448be43e6bd7d69aa0227187fca146a1f2262"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}