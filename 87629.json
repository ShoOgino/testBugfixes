{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    pointCount++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecf331f9d7bdd234863d2df2bb5c1f019979422f","date":1452250335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    pointCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b84d416bbd661ae4b2a28d103bdfccb851e00de","date":1458041762,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        switchToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, minPackedValue, offset) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (StringHelper.compare(bytesPerDim, packedValue, offset, maxPackedValue, offset) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedBytesLength);\n    } else {\n      for(int dim=0;dim<numDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, pointCount, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, pointCount, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76a51551f05a6c96a115b5a656837ecc8fd0b1ff","date":1551422476,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n\n    if (pointCount >= maxPointsSortInHeap) {\n      if (offlinePointWriter == null) {\n        spillToOffline();\n      }\n      offlinePointWriter.append(packedValue, docID);\n    } else {\n      // Not too many points added yet, continue using heap:\n      heapPointWriter.append(packedValue, docID);\n    }\n\n    // TODO: we could specialize for the 1D case:\n    if (pointCount == 0) {\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n\n    pointCount++;\n    if (pointCount > totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + pointCount + \" values\");\n    }\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (FutureArrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0f206e78bea6261260b24c406e920d05c7ca2f3","date":1570809619,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        }\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#add(byte[],int).mjava","sourceNew":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != config.packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + config.packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, config.packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<config.numIndexDims;dim++) {\n        int offset = dim*config.bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + config.bytesPerDim, minPackedValue, offset, offset + config.bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, config.bytesPerDim);\n        } else if (Arrays.compareUnsigned(packedValue, offset, offset + config.bytesPerDim, maxPackedValue, offset, offset + config.bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, config.bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","sourceOld":"  public void add(byte[] packedValue, int docID) throws IOException {\n    if (packedValue.length != packedBytesLength) {\n      throw new IllegalArgumentException(\"packedValue should be length=\" + packedBytesLength + \" (got: \" + packedValue.length + \")\");\n    }\n    if (pointCount >= totalPointCount) {\n      throw new IllegalStateException(\"totalPointCount=\" + totalPointCount + \" was passed when we were created, but we just hit \" + (pointCount + 1) + \" values\");\n    }\n    if (pointCount == 0) {\n      initPointWriter();\n      System.arraycopy(packedValue, 0, minPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(packedValue, 0, maxPackedValue, 0, packedIndexBytesLength);\n    } else {\n      for(int dim=0;dim<numIndexDims;dim++) {\n        int offset = dim*bytesPerDim;\n        if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) < 0) {\n          System.arraycopy(packedValue, offset, minPackedValue, offset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) > 0) {\n          System.arraycopy(packedValue, offset, maxPackedValue, offset, bytesPerDim);\n        }\n      }\n    }\n    pointWriter.append(packedValue, docID);\n    pointCount++;\n    docsSeen.set(docID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d0f206e78bea6261260b24c406e920d05c7ca2f3"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["ecf331f9d7bdd234863d2df2bb5c1f019979422f","251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b88a121b875f9ae2ac50f85cf46dcb680f126357","d0f206e78bea6261260b24c406e920d05c7ca2f3"]},"commit2Childs":{"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["251c5b33f0a2c8988550b63c78ed22b0e84524e5","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["d0f206e78bea6261260b24c406e920d05c7ca2f3","b0b597c65628ca9e73913a07e81691f8229bae35"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9","b0b597c65628ca9e73913a07e81691f8229bae35"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}