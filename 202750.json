{"path":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","commits":[{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","pathOld":"/dev/null","sourceNew":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(logPrefix + \"raw update record \" + o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"add \" + cmd + \" id \" + sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"delete \" + cmd + \" \" + new BytesRef(idBytes).utf8ToString());\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"deleteByQuery \" + cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"inplace update \" + cmd + \" prevVersion=\" + cmd.prevVersion + \", doc=\" + cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,finish()\", e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","pathOld":"/dev/null","sourceNew":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(logPrefix + \"raw update record \" + o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"add \" + cmd + \" id \" + sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"delete \" + cmd + \" \" + new BytesRef(idBytes).utf8ToString());\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"deleteByQuery \" + cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"inplace update \" + cmd + \" prevVersion=\" + cmd.prevVersion + \", doc=\" + cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,finish()\", e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","pathOld":"/dev/null","sourceNew":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(logPrefix + \"raw update record \" + o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"add \" + cmd + \" id \" + sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"delete \" + cmd + \" \" + new BytesRef(idBytes).utf8ToString());\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"deleteByQuery \" + cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"inplace update \" + cmd + \" prevVersion=\" + cmd.prevVersion + \", doc=\" + cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,finish()\", e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","sourceNew":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(\"{} raw update record {}\", logPrefix, o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} add {} id {}\", logPrefix, cmd, sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"{} delete {} {}\", logPrefix, cmd, new BytesRef(idBytes).utf8ToString());\n                }\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} deleteByQuery {}\", logPrefix, cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} inplace update {} prevVersion={} doc={}\", logPrefix, cmd, cmd.prevVersion, cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(\"{} Error applying updates from {}, update={}\", logPrefix, updateFrom, o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(\"{} Error applying updates from {}, update={} \", logPrefix, updateFrom,  o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(\"{} Error applying updates from {}, finish()\", logPrefix, updateFrom, e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","sourceOld":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(logPrefix + \"raw update record \" + o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"add \" + cmd + \" id \" + sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"delete \" + cmd + \" \" + new BytesRef(idBytes).utf8ToString());\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"deleteByQuery \" + cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"inplace update \" + cmd + \" prevVersion=\" + cmd.prevVersion + \", doc=\" + cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,finish()\", e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync.Updater#applyUpdates(List[Object],Object).mjava","sourceNew":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          @SuppressWarnings({\"unchecked\"})\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(\"{} raw update record {}\", logPrefix, o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} add {} id {}\", logPrefix, cmd, sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"{} delete {} {}\", logPrefix, cmd, new BytesRef(idBytes).utf8ToString());\n                }\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} deleteByQuery {}\", logPrefix, cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} inplace update {} prevVersion={} doc={}\", logPrefix, cmd, cmd.prevVersion, cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(\"{} Error applying updates from {}, update={}\", logPrefix, updateFrom, o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(\"{} Error applying updates from {}, update={} \", logPrefix, updateFrom,  o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(\"{} Error applying updates from {}, finish()\", logPrefix, updateFrom, e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","sourceOld":"    void applyUpdates(List<Object> updates, Object updateFrom) throws Exception {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(\"peersync\",true); // debugging\n      SolrQueryRequest req = new LocalSolrQueryRequest(solrCore, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n\n      UpdateRequestProcessorChain processorChain = req.getCore().getUpdateProcessingChain(null);\n      UpdateRequestProcessor proc = processorChain.createProcessor(req, rsp);\n\n      updates.sort(updateRecordComparator);\n\n      Object o = null;\n      long lastVersion = 0;\n      try {\n        // Apply oldest updates first\n        for (Object obj : updates) {\n          // should currently be a List<Oper,Ver,Doc/Id>\n          o = obj;\n          List<Object> entry = (List<Object>)o;\n\n          if (debug) {\n            log.debug(\"{} raw update record {}\", logPrefix, o);\n          }\n\n          int oper = (Integer)entry.get(0) & UpdateLog.OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (version == lastVersion && version != 0) continue;\n          lastVersion = version;\n\n          switch (oper) {\n            case UpdateLog.ADD:\n            {\n              // byte[] idBytes = (byte[]) entry.get(2);\n              SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n              AddUpdateCommand cmd = new AddUpdateCommand(req);\n              // cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.solrDoc = sdoc;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} add {} id {}\", logPrefix, cmd, sdoc.getField(ID));\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            case UpdateLog.DELETE:\n            {\n              byte[] idBytes = (byte[]) entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.setIndexedId(new BytesRef(idBytes));\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"{} delete {} {}\", logPrefix, cmd, new BytesRef(idBytes).utf8ToString());\n                }\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n\n            case UpdateLog.DELETE_BY_QUERY:\n            {\n              String query = (String)entry.get(2);\n              DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n              cmd.query = query;\n              cmd.setVersion(version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} deleteByQuery {}\", logPrefix, cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(\"{} inplace update {} prevVersion={} doc={}\", logPrefix, cmd, cmd.prevVersion, cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n\n        }\n\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(\"{} Error applying updates from {}, update={}\", logPrefix, updateFrom, o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(\"{} Error applying updates from {}, update={} \", logPrefix, updateFrom,  o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(\"{} Error applying updates from {}, finish()\", logPrefix, updateFrom, e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","740d649f013f07efbeb73ca854f106c60166e7c0","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}