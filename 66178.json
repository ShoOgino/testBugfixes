{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","commits":[{"id":"33861a7dcb2e09155c04cd7507f0ab74d5d102b6","date":1461397689,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    // MHL\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8530f74e75c82997f2372fff25f63aeaf7c78345","date":1461534280,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    Plane p = Plane.constructNormalizedZPlane(testPoint.x, testPoint.y);\n    if (p == null) {\n      p = new Plane(1.0, 0.0, 0.0, 0.0);\n    }\n    this.testPointVerticalPlane = p;\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = pointsList.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xtree.add(edge);\n        ytree.add(edge);\n        ztree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    // MHL\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09149ac46adf9772db58c67d18f37b1c5e109b34","date":1461566431,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    Plane p = Plane.constructNormalizedZPlane(testPoint.x, testPoint.y);\n    if (p == null) {\n      p = new Plane(1.0, 0.0, 0.0, 0.0);\n    }\n    this.testPointVerticalPlane = p;\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = pointsList.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xtree.add(edge);\n        ytree.add(edge);\n        ztree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointXZPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointYZPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointXYPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6f1382358fb94a408ebd8bbb00135f2a83f4d66","date":1461613845,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointXZPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointYZPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointXYPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointXZAbovePlane = new Plane(testPointXZPlane, true);\n    this.testPointXZBelowPlane = new Plane(testPointXZPlane, false);\n    this.testPointYZAbovePlane = new Plane(testPointYZPlane, true);\n    this.testPointYZBelowPlane = new Plane(testPointYZPlane, false);\n    this.testPointXYAbovePlane = new Plane(testPointXYPlane, true);\n    this.testPointXYBelowPlane = new Plane(testPointXYPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointXZPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointYZPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointXYPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414d7bcd2f513d7e7162dae022e9a9f3cd930277","date":1461885603,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointXZPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointYZPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointXYPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointXZAbovePlane = new Plane(testPointXZPlane, true);\n    this.testPointXZBelowPlane = new Plane(testPointXZPlane, false);\n    this.testPointYZAbovePlane = new Plane(testPointYZPlane, true);\n    this.testPointYZBelowPlane = new Plane(testPointYZPlane, false);\n    this.testPointXYAbovePlane = new Plane(testPointXYPlane, true);\n    this.testPointXYBelowPlane = new Plane(testPointXYPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40ed02185d30689c656882e95985219485a6bec2","date":1462295737,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        xTree.add(edge);\n        yTree.add(edge);\n        zTree.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4fb8b37902dbdd7832727cccdd1d3c5441074fa5","date":1503643931,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c9c955664ed32e2bf97b3da26467354673ea18","date":1522944427,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e872ee16caf3bf386b6a55f3654fabb2840d8fc9","date":1523529572,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYAbovePlane.D > 0.0) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > 0.0 ||  planetModel.getMinimumYValue() - fixedYBelowPlane.D > 0.0) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXAbovePlane.D > 0.0) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXBelowPlane.D > 0.0) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > 0.0 ||planetModel.getMinimumZValue() - fixedZAbovePlane.D > 0.0) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZBelowPlane.D > 0.0) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a31f543c55a8dd122ed8676510a9c6d8000fa214","date":1524142014,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYAbovePlane.D > 0.0) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > 0.0 ||  planetModel.getMinimumYValue() - fixedYBelowPlane.D > 0.0) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXAbovePlane.D > 0.0) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXBelowPlane.D > 0.0) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > 0.0 ||planetModel.getMinimumZValue() - fixedZAbovePlane.D > 0.0) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZBelowPlane.D > 0.0) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"039615f2ceafe5881c61222281f45a0631b90174","date":1524725949,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    if (testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    this.pointsList = pointsList;  // For serialization\n    this.testPointInSet = testPointInSet;\n    this.testPoint = testPoint;\n    \n    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);\n    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);\n    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);\n    \n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n  }\n\n","bugFix":null,"bugIntro":["3cd25c083a7199445f2db6f32d322eeac1afc99e","824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","date":1524832766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        assert planetModel.pointOnSurface(thisGeoPoint) : \"Polygon edge point must be on surface; \"+thisGeoPoint+\" is not\";\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n    \n    assert planetModel.pointOnSurface(testPoint2.x, testPoint2.y, testPoint2.z) : \"Test point 2 is off of ellipsoid\";\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    if (testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    //System.out.println(\"Determining in-set-ness of test point2 (\"+testPoint2+\"):\");\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    \n    //System.out.println(\"\\n... done.  Checking against test point1 (\"+testPoint1+\"):\");\n    \n    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,\n      testPoint2,\n      testPoint2InSet,\n      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : \"Test point1 not correctly in/out of set according to test point2\";\n\n    //System.out.println(\"\\n... done\");\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    if (testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n  }\n\n","bugFix":null,"bugIntro":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cd25c083a7199445f2db6f32d322eeac1afc99e","date":1527642183,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        assert planetModel.pointOnSurface(thisGeoPoint) : \"Polygon edge point must be on surface; \"+thisGeoPoint+\" is not\";\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n    \n    assert planetModel.pointOnSurface(testPoint2.x, testPoint2.y, testPoint2.z) : \"Test point 2 is off of ellipsoid\";\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    \n    // We compare the plane's Y value (etc), which is -D, with the planet's maximum and minimum Y poles.\n    \n    if (-testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (-testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() + testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (-testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (-testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (-testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() + testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (-testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (-testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (-testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() + testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (-testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (-testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (-testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() + testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (-testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    //System.out.println(\"Determining in-set-ness of test point2 (\"+testPoint2+\"):\");\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    \n    //System.out.println(\"\\n... done.  Checking against test point1 (\"+testPoint1+\"):\");\n    \n    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,\n      testPoint2,\n      testPoint2InSet,\n      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : \"Test point1 not correctly in/out of set according to test point2\";\n\n    //System.out.println(\"\\n... done\");\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        assert planetModel.pointOnSurface(thisGeoPoint) : \"Polygon edge point must be on surface; \"+thisGeoPoint+\" is not\";\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n    \n    assert planetModel.pointOnSurface(testPoint2.x, testPoint2.y, testPoint2.z) : \"Test point 2 is off of ellipsoid\";\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    if (testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    //System.out.println(\"Determining in-set-ness of test point2 (\"+testPoint2+\"):\");\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    \n    //System.out.println(\"\\n... done.  Checking against test point1 (\"+testPoint1+\"):\");\n    \n    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,\n      testPoint2,\n      testPoint2InSet,\n      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : \"Test point1 not correctly in/out of set according to test point2\";\n\n    //System.out.println(\"\\n... done\");\n  }\n\n","bugFix":["039615f2ceafe5881c61222281f45a0631b90174"],"bugIntro":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"824fea352f6fabb3a66e7d4df5c72c2ff9511359","date":1537699526,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#GeoComplexPolygon(PlanetModel,List[List[GeoPoint]],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        assert planetModel.pointOnSurface(thisGeoPoint) : \"Polygon edge point must be on surface; \"+thisGeoPoint+\" is not\";\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        if (edge.isWithin(testPoint.x, testPoint.y, testPoint.z)) {\n          throw new IllegalArgumentException(\"Test point is on polygon edge: not allowed\");\n        }\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    \n    // We compare the plane's Y value (etc), which is -D, with the planet's maximum and minimum Y poles.\n    \n    if (-testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (-testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() + testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (-testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (-testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (-testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() + testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (-testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n  }\n\n","sourceOld":"  /**\n   * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of\n   * set.\n   *@param planetModel is the planet model.\n   *@param pointsList is the list of lists of edge points.  The edge points describe edges, and have an implied\n   *  return boundary, so that N edges require N points.  These points have furthermore been filtered so that\n   *  no adjacent points are identical (within the bounds of the definition used by this package).  It is assumed\n   *  that no edges intersect, but the structure can contain both outer rings as well as holes.\n   *@param testPoint is the point whose in/out of setness is known.\n   *@param testPointInSet is true if the test point is considered \"within\" the polygon.\n   */\n  public GeoComplexPolygon(final PlanetModel planetModel, final List<List<GeoPoint>> pointsList, final GeoPoint testPoint, final boolean testPointInSet) {\n    super(planetModel);\n    \n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n    \n    this.pointsList = pointsList;  // For serialization\n\n    // Construct and index edges\n    this.edgePoints = new GeoPoint[pointsList.size()];\n    this.shapeStartEdges = new Edge[pointsList.size()];\n    final ArrayList<Edge> allEdges = new ArrayList<>();\n    int edgePointIndex = 0;\n    for (final List<GeoPoint> shapePoints : pointsList) {\n      allEdges.ensureCapacity(allEdges.size() + shapePoints.size());\n      GeoPoint lastGeoPoint = shapePoints.get(shapePoints.size()-1);\n      edgePoints[edgePointIndex] = lastGeoPoint;\n      Edge lastEdge = null;\n      Edge firstEdge = null;\n      for (final GeoPoint thisGeoPoint : shapePoints) {\n        assert planetModel.pointOnSurface(thisGeoPoint) : \"Polygon edge point must be on surface; \"+thisGeoPoint+\" is not\";\n        final Edge edge = new Edge(planetModel, lastGeoPoint, thisGeoPoint);\n        allEdges.add(edge);\n        // Now, link\n        if (firstEdge == null) {\n          firstEdge = edge;\n        }\n        if (lastEdge != null) {\n          lastEdge.next = edge;\n          edge.previous = lastEdge;\n        }\n        lastEdge = edge;\n        lastGeoPoint = thisGeoPoint;\n      }\n      firstEdge.previous = lastEdge;\n      lastEdge.next = firstEdge;\n      shapeStartEdges[edgePointIndex] = firstEdge;\n      edgePointIndex++;\n    }\n\n    xTree = new XTree(allEdges);\n    yTree = new YTree(allEdges);\n    zTree = new ZTree(allEdges);\n\n    // Record testPoint1 as-is\n    this.testPoint1 = testPoint;\n    // Pick the antipodes for testPoint2\n    this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\n    \n    assert planetModel.pointOnSurface(testPoint2.x, testPoint2.y, testPoint2.z) : \"Test point 2 is off of ellipsoid\";\n\n    // Construct fixed planes for testPoint1\n    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);\n    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);\n    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);\n    \n    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);\n    \n    // We compare the plane's Y value (etc), which is -D, with the planet's maximum and minimum Y poles.\n    \n    if (-testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYAbovePlane = null;\n    }\n    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;\n    \n    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);\n    if (-testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() + testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedYBelowPlane = null;\n    }\n    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;\n    \n    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);\n    if (-testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXAbovePlane = null;\n    }\n    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;\n    \n    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);\n    if (-testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedXBelowPlane = null;\n    }\n    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;\n    \n    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);\n    if (-testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() + testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZAbovePlane = null;\n    }\n    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;\n    \n    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);\n    if (-testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint1FixedZBelowPlane = null;\n    }\n    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;\n\n    // Construct fixed planes for testPoint2\n    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);\n    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);\n    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);\n    \n    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);\n    if (-testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYAbovePlane = null;\n    }\n    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;\n    \n    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);\n    if (-testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() + testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedYBelowPlane = null;\n    }\n    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;\n    \n    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);\n    if (-testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXAbovePlane = null;\n    }\n    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;\n    \n    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);\n    if (-testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedXBelowPlane = null;\n    }\n    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;\n    \n    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);\n    if (-testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() + testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZAbovePlane = null;\n    }\n    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;\n    \n    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);\n    if (-testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n        testPoint2FixedZBelowPlane = null;\n    }\n    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;\n\n    // We know inset/out-of-set for testPoint1 only right now\n    this.testPoint1InSet = testPointInSet;\n\n    //System.out.println(\"Determining in-set-ness of test point2 (\"+testPoint2+\"):\");\n    // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out\n    this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,\n      testPoint1, \n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    \n    //System.out.println(\"\\n... done.  Checking against test point1 (\"+testPoint1+\"):\");\n    \n    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,\n      testPoint2,\n      testPoint2InSet,\n      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : \"Test point1 not correctly in/out of set according to test point2\";\n\n    //System.out.println(\"\\n... done\");\n  }\n\n","bugFix":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","3cd25c083a7199445f2db6f32d322eeac1afc99e","039615f2ceafe5881c61222281f45a0631b90174"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a31f543c55a8dd122ed8676510a9c6d8000fa214":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["8530f74e75c82997f2372fff25f63aeaf7c78345"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["039615f2ceafe5881c61222281f45a0631b90174"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"039615f2ceafe5881c61222281f45a0631b90174":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"e6f1382358fb94a408ebd8bbb00135f2a83f4d66":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"4fb8b37902dbdd7832727cccdd1d3c5441074fa5":["40ed02185d30689c656882e95985219485a6bec2"],"40ed02185d30689c656882e95985219485a6bec2":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40ed02185d30689c656882e95985219485a6bec2"],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"d3c9c955664ed32e2bf97b3da26467354673ea18":["4fb8b37902dbdd7832727cccdd1d3c5441074fa5"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["40ed02185d30689c656882e95985219485a6bec2","4fb8b37902dbdd7832727cccdd1d3c5441074fa5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8530f74e75c82997f2372fff25f63aeaf7c78345":["33861a7dcb2e09155c04cd7507f0ab74d5d102b6"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["e6f1382358fb94a408ebd8bbb00135f2a83f4d66"],"824fea352f6fabb3a66e7d4df5c72c2ff9511359":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"]},"commit2Childs":{"a31f543c55a8dd122ed8676510a9c6d8000fa214":["039615f2ceafe5881c61222281f45a0631b90174"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"039615f2ceafe5881c61222281f45a0631b90174":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"e6f1382358fb94a408ebd8bbb00135f2a83f4d66":["414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"4fb8b37902dbdd7832727cccdd1d3c5441074fa5":["d3c9c955664ed32e2bf97b3da26467354673ea18","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"40ed02185d30689c656882e95985219485a6bec2":["4fb8b37902dbdd7832727cccdd1d3c5441074fa5","55b50463286869f584cf849d1587a0fcd54d1dfa","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"55b50463286869f584cf849d1587a0fcd54d1dfa":[],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["8530f74e75c82997f2372fff25f63aeaf7c78345"],"d3c9c955664ed32e2bf97b3da26467354673ea18":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55b50463286869f584cf849d1587a0fcd54d1dfa","33861a7dcb2e09155c04cd7507f0ab74d5d102b6","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"8530f74e75c82997f2372fff25f63aeaf7c78345":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["40ed02185d30689c656882e95985219485a6bec2"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"824fea352f6fabb3a66e7d4df5c72c2ff9511359":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["e6f1382358fb94a408ebd8bbb00135f2a83f4d66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55b50463286869f584cf849d1587a0fcd54d1dfa","3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}