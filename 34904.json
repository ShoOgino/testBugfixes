{"path":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","commits":[{"id":"6d7001ba0a3ddc786d0edd8cb60ec5e813920396","date":1489580117,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","pathOld":"/dev/null","sourceNew":"  // When an non-indexed field gets merged, it exhibit the old behavior\n  // The field will be merged, docvalues headers updated, but no docvalues for this field\n  public void testNonIndexedFieldDoesNonFail() throws Exception {\n    // Remove Indexed from fieldType\n    removeIndexFrom(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(1), TEST_FIELD, String.valueOf(1)));\n    assertU(commit());\n    \n    addDocValuesTo(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(2), TEST_FIELD, String.valueOf(2)));\n    assertU(commit());\n    \n    assertU(optimize(\"maxSegments\", \"1\"));\n    \n    withNewRawReader(h, topReader -> {\n      // Assert merged into one segment \n      assertEquals(2, topReader.numDocs());\n      assertEquals(1, topReader.leaves().size());\n      \n\n      final FieldInfos infos = MultiFields.getMergedFieldInfos(topReader);\n      // The global field type should have docValues because a document with dvs was added\n      assertEquals(DocValuesType.SORTED, infos.fieldInfo(TEST_FIELD).getDocValuesType());\n      \n      for (LeafReaderContext ctx : topReader.leaves()) {\n        LeafReader r = ctx.reader();\n        SortedDocValues docvalues = r.getSortedDocValues(TEST_FIELD);\n        for(int i = 0; i < r.numDocs(); ++i) {\n          Document doc = r.document(i);\n          String v = doc.getField(TEST_FIELD).stringValue();\n          String id = doc.getField(ID_FIELD).stringValue();\n          assertEquals(DocValuesType.SORTED, r.getFieldInfos().fieldInfo(TEST_FIELD).getDocValuesType());\n          assertEquals(DocValuesType.NONE, r.getFieldInfos().fieldInfo(ID_FIELD).getDocValuesType());\n          \n         \n          if(id.equals(\"2\")) {\n            assertTrue(docvalues.advanceExact(i));\n            assertEquals(v, docvalues.binaryValue().utf8ToString());\n          } else {\n            assertFalse(docvalues.advanceExact(i));\n          }\n          \n        }\n      }  \n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cb3a881440e661c981ce1f36d1533b359463aa","date":1489651910,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","pathOld":"/dev/null","sourceNew":"  // When an non-indexed field gets merged, it exhibit the old behavior\n  // The field will be merged, docvalues headers updated, but no docvalues for this field\n  public void testNonIndexedFieldDoesNonFail() throws Exception {\n    // Remove Indexed from fieldType\n    removeIndexFrom(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(1), TEST_FIELD, String.valueOf(1)));\n    assertU(commit());\n    \n    addDocValuesTo(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(2), TEST_FIELD, String.valueOf(2)));\n    assertU(commit());\n    \n    assertU(optimize(\"maxSegments\", \"1\"));\n    \n    withNewRawReader(h, topReader -> {\n      // Assert merged into one segment \n      assertEquals(2, topReader.numDocs());\n      assertEquals(1, topReader.leaves().size());\n      \n\n      final FieldInfos infos = MultiFields.getMergedFieldInfos(topReader);\n      // The global field type should have docValues because a document with dvs was added\n      assertEquals(DocValuesType.SORTED, infos.fieldInfo(TEST_FIELD).getDocValuesType());\n      \n      for (LeafReaderContext ctx : topReader.leaves()) {\n        LeafReader r = ctx.reader();\n        SortedDocValues docvalues = r.getSortedDocValues(TEST_FIELD);\n        for(int i = 0; i < r.numDocs(); ++i) {\n          Document doc = r.document(i);\n          String v = doc.getField(TEST_FIELD).stringValue();\n          String id = doc.getField(ID_FIELD).stringValue();\n          assertEquals(DocValuesType.SORTED, r.getFieldInfos().fieldInfo(TEST_FIELD).getDocValuesType());\n          assertEquals(DocValuesType.NONE, r.getFieldInfos().fieldInfo(ID_FIELD).getDocValuesType());\n          \n         \n          if(id.equals(\"2\")) {\n            assertTrue(docvalues.advanceExact(i));\n            assertEquals(v, docvalues.binaryValue().utf8ToString());\n          } else {\n            assertFalse(docvalues.advanceExact(i));\n          }\n          \n        }\n      }  \n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","pathOld":"/dev/null","sourceNew":"  // When an non-indexed field gets merged, it exhibit the old behavior\n  // The field will be merged, docvalues headers updated, but no docvalues for this field\n  public void testNonIndexedFieldDoesNonFail() throws Exception {\n    // Remove Indexed from fieldType\n    removeIndexFrom(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(1), TEST_FIELD, String.valueOf(1)));\n    assertU(commit());\n    \n    addDocValuesTo(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(2), TEST_FIELD, String.valueOf(2)));\n    assertU(commit());\n    \n    assertU(optimize(\"maxSegments\", \"1\"));\n    \n    withNewRawReader(h, topReader -> {\n      // Assert merged into one segment \n      assertEquals(2, topReader.numDocs());\n      assertEquals(1, topReader.leaves().size());\n      \n\n      final FieldInfos infos = MultiFields.getMergedFieldInfos(topReader);\n      // The global field type should have docValues because a document with dvs was added\n      assertEquals(DocValuesType.SORTED, infos.fieldInfo(TEST_FIELD).getDocValuesType());\n      \n      for (LeafReaderContext ctx : topReader.leaves()) {\n        LeafReader r = ctx.reader();\n        SortedDocValues docvalues = r.getSortedDocValues(TEST_FIELD);\n        for(int i = 0; i < r.numDocs(); ++i) {\n          Document doc = r.document(i);\n          String v = doc.getField(TEST_FIELD).stringValue();\n          String id = doc.getField(ID_FIELD).stringValue();\n          assertEquals(DocValuesType.SORTED, r.getFieldInfos().fieldInfo(TEST_FIELD).getDocValuesType());\n          assertEquals(DocValuesType.NONE, r.getFieldInfos().fieldInfo(ID_FIELD).getDocValuesType());\n          \n         \n          if(id.equals(\"2\")) {\n            assertTrue(docvalues.advanceExact(i));\n            assertEquals(v, docvalues.binaryValue().utf8ToString());\n          } else {\n            assertFalse(docvalues.advanceExact(i));\n          }\n          \n        }\n      }  \n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/index/UninvertDocValuesMergePolicyTest#testNonIndexedFieldDoesNonFail().mjava","sourceNew":"  // When an non-indexed field gets merged, it exhibit the old behavior\n  // The field will be merged, docvalues headers updated, but no docvalues for this field\n  public void testNonIndexedFieldDoesNonFail() throws Exception {\n    // Remove Indexed from fieldType\n    removeIndexFrom(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(1), TEST_FIELD, String.valueOf(1)));\n    assertU(commit());\n    \n    addDocValuesTo(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(2), TEST_FIELD, String.valueOf(2)));\n    assertU(commit());\n    \n    assertU(optimize(\"maxSegments\", \"1\"));\n    \n    withNewRawReader(h, topReader -> {\n      // Assert merged into one segment \n      assertEquals(2, topReader.numDocs());\n      assertEquals(1, topReader.leaves().size());\n      \n\n      final FieldInfos infos = FieldInfos.getMergedFieldInfos(topReader);\n      // The global field type should have docValues because a document with dvs was added\n      assertEquals(DocValuesType.SORTED, infos.fieldInfo(TEST_FIELD).getDocValuesType());\n      \n      for (LeafReaderContext ctx : topReader.leaves()) {\n        LeafReader r = ctx.reader();\n        SortedDocValues docvalues = r.getSortedDocValues(TEST_FIELD);\n        for(int i = 0; i < r.numDocs(); ++i) {\n          Document doc = r.document(i);\n          String v = doc.getField(TEST_FIELD).stringValue();\n          String id = doc.getField(ID_FIELD).stringValue();\n          assertEquals(DocValuesType.SORTED, r.getFieldInfos().fieldInfo(TEST_FIELD).getDocValuesType());\n          assertEquals(DocValuesType.NONE, r.getFieldInfos().fieldInfo(ID_FIELD).getDocValuesType());\n          \n         \n          if(id.equals(\"2\")) {\n            assertTrue(docvalues.advanceExact(i));\n            assertEquals(v, docvalues.binaryValue().utf8ToString());\n          } else {\n            assertFalse(docvalues.advanceExact(i));\n          }\n          \n        }\n      }  \n    });\n  }\n\n","sourceOld":"  // When an non-indexed field gets merged, it exhibit the old behavior\n  // The field will be merged, docvalues headers updated, but no docvalues for this field\n  public void testNonIndexedFieldDoesNonFail() throws Exception {\n    // Remove Indexed from fieldType\n    removeIndexFrom(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(1), TEST_FIELD, String.valueOf(1)));\n    assertU(commit());\n    \n    addDocValuesTo(h, TEST_FIELD);\n    \n    assertU(adoc(ID_FIELD, String.valueOf(2), TEST_FIELD, String.valueOf(2)));\n    assertU(commit());\n    \n    assertU(optimize(\"maxSegments\", \"1\"));\n    \n    withNewRawReader(h, topReader -> {\n      // Assert merged into one segment \n      assertEquals(2, topReader.numDocs());\n      assertEquals(1, topReader.leaves().size());\n      \n\n      final FieldInfos infos = MultiFields.getMergedFieldInfos(topReader);\n      // The global field type should have docValues because a document with dvs was added\n      assertEquals(DocValuesType.SORTED, infos.fieldInfo(TEST_FIELD).getDocValuesType());\n      \n      for (LeafReaderContext ctx : topReader.leaves()) {\n        LeafReader r = ctx.reader();\n        SortedDocValues docvalues = r.getSortedDocValues(TEST_FIELD);\n        for(int i = 0; i < r.numDocs(); ++i) {\n          Document doc = r.document(i);\n          String v = doc.getField(TEST_FIELD).stringValue();\n          String id = doc.getField(ID_FIELD).stringValue();\n          assertEquals(DocValuesType.SORTED, r.getFieldInfos().fieldInfo(TEST_FIELD).getDocValuesType());\n          assertEquals(DocValuesType.NONE, r.getFieldInfos().fieldInfo(ID_FIELD).getDocValuesType());\n          \n         \n          if(id.equals(\"2\")) {\n            assertTrue(docvalues.advanceExact(i));\n            assertEquals(v, docvalues.binaryValue().utf8ToString());\n          } else {\n            assertFalse(docvalues.advanceExact(i));\n          }\n          \n        }\n      }  \n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["6d7001ba0a3ddc786d0edd8cb60ec5e813920396"],"6d7001ba0a3ddc786d0edd8cb60ec5e813920396":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab68488225b6a6c357dda72ed11dedca9914a192":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b7cb3a881440e661c981ce1f36d1533b359463aa"],"b7cb3a881440e661c981ce1f36d1533b359463aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6d7001ba0a3ddc786d0edd8cb60ec5e813920396","ab68488225b6a6c357dda72ed11dedca9914a192","b7cb3a881440e661c981ce1f36d1533b359463aa"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d7001ba0a3ddc786d0edd8cb60ec5e813920396":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"ab68488225b6a6c357dda72ed11dedca9914a192":[],"b7cb3a881440e661c981ce1f36d1533b359463aa":["ab68488225b6a6c357dda72ed11dedca9914a192"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ab68488225b6a6c357dda72ed11dedca9914a192","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}