{"path":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","commits":[{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"/dev/null","sourceNew":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, offset == -1 ? 0 : (int) offset, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ea187884f51c148cb86509b1ee7705026b8c7b94"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"/dev/null","sourceNew":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, offset == -1 ? 0 : (int) offset, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea187884f51c148cb86509b1ee7705026b8c7b94","date":1354053918,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, offset == -1 ? 0 : (int) offset, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, offset == -1 ? 0 : (int) offset, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a2d81cf6955f09cda03ed448bb9bb397d4b9742","date":1411570057,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        \n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      String fileName = params.get(FILE);\n      String cfileName = params.get(CONF_FILE_SHORT);\n      String sOffset = params.get(OFFSET);\n      String sLen = params.get(LEN);\n      String compress = params.get(COMPRESSION);\n      String sChecksum = params.get(CHECKSUM);\n      String sGen = params.get(GENERATION);\n      if (sGen != null) indexGen = Long.parseLong(sGen);\n      if (Boolean.parseBoolean(compress)) {\n        fos = new FastOutputStream(new DeflaterOutputStream(out));\n      } else {\n        fos = new FastOutputStream(out);\n      }\n\n      int packetsWritten = 0;\n      IndexInput in = null;\n      try {\n        long offset = -1;\n        int len = -1;\n        // check if checksum is requested\n        boolean useChecksum = Boolean.parseBoolean(sChecksum);\n        if (sOffset != null) offset = Long.parseLong(sOffset);\n        if (sLen != null) len = Integer.parseInt(sLen);\n        if (fileName == null && cfileName == null) {\n          // no filename do nothing\n          writeNothing();\n        }\n        \n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        byte[] buf = new byte[(len == -1 || len > PACKET_SZ) ? PACKET_SZ : len];\n        Checksum checksum = null;\n        if (useChecksum) checksum = new Adler32();\n        \n        long filelen = dir.fileLength(fileName);\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n          \n          fos.writeInt((int) read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          if (indexGen != null && (packetsWritten % 5 == 0)) {\n            // after every 5 packets reserve the commitpoint for some time\n            delPolicy.setReserveDuration(indexGen, reserveCommitDuration);\n          }\n          packetsWritten++;\n          if (read != buf.length) {\n            writeNothing();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dea8e36e8c36d610840396c282a5affe3f722f4e","date":1422297045,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        \n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        \n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n        \n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"016b6925925785877da3496ebb08189655bbc9e6","date":1433994025,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        releaseCommitPointAndExtendReserve();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac35531329b1809368fb0780bcf1e72d0add3c21","date":1525474926,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close();\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ab833f2b623042c834458d4cbcad05073a93793","date":1527625631,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2138c838f1c8052d94d61eb1e205dce7fa6932ef","date":1527642223,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        RefCounted<SolrIndexSearcher> sref = core.getSearcher();\n        Directory dir;\n        try {\n          SolrIndexSearcher searcher = sref.get();\n          dir = searcher.getIndexReader().directory();\n        } finally {\n          sref.decref();\n        }\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          log.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        log.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          LOG.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          log.debug(\"Wrote {} bytes for file {}\", offset + read, fileName); // logOK\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        log.warn(\"Exception while writing response for params: {}\", params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          log.debug(\"Wrote {} bytes for file {}\", offset + read, fileName);\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        log.warn(\"Exception while writing response for params: \" + params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler.DirectoryFileStream#write(OutputStream).mjava","sourceNew":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          log.debug(\"Wrote {} bytes for file {}\", offset + read, fileName); // nowarn\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        log.warn(\"Exception while writing response for params: {}\", params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","sourceOld":"    public void write(OutputStream out) throws IOException {\n      createOutputStream(out);\n\n      IndexInput in = null;\n      try {\n        initWrite();\n\n        Directory dir = core.withSearcher(searcher -> searcher.getIndexReader().directory());\n        in = dir.openInput(fileName, IOContext.READONCE);\n        // if offset is mentioned move the pointer to that point\n        if (offset != -1) in.seek(offset);\n\n        long filelen = dir.fileLength(fileName);\n        long maxBytesBeforePause = 0;\n\n        while (true) {\n          offset = offset == -1 ? 0 : offset;\n          int read = (int) Math.min(buf.length, filelen - offset);\n          in.readBytes(buf, 0, read);\n\n          fos.writeInt(read);\n          if (useChecksum) {\n            checksum.reset();\n            checksum.update(buf, 0, read);\n            fos.writeLong(checksum.getValue());\n          }\n          fos.write(buf, 0, read);\n          fos.flush();\n          log.debug(\"Wrote {} bytes for file {}\", offset + read, fileName); // logOK\n\n          //Pause if necessary\n          maxBytesBeforePause += read;\n          if (maxBytesBeforePause >= rateLimiter.getMinPauseCheckBytes()) {\n            rateLimiter.pause(maxBytesBeforePause);\n            maxBytesBeforePause = 0;\n          }\n          if (read != buf.length) {\n            writeNothingAndFlush();\n            fos.close(); // we close because DeflaterOutputStream requires a close call, but but the request outputstream is protected\n            break;\n          }\n          offset += read;\n          in.seek(offset);\n        }\n      } catch (IOException e) {\n        log.warn(\"Exception while writing response for params: {}\", params, e);\n      } finally {\n        if (in != null) {\n          in.close();\n        }\n        extendReserveAndReleaseCommitPoint();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","ea187884f51c148cb86509b1ee7705026b8c7b94"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["016b6925925785877da3496ebb08189655bbc9e6"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4ab833f2b623042c834458d4cbcad05073a93793":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"ea187884f51c148cb86509b1ee7705026b8c7b94":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["5a2d81cf6955f09cda03ed448bb9bb397d4b9742"],"5a2d81cf6955f09cda03ed448bb9bb397d4b9742":["ea187884f51c148cb86509b1ee7705026b8c7b94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b2d19164145b2a65acf62a657c75f4a249b649c0":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"016b6925925785877da3496ebb08189655bbc9e6":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"2138c838f1c8052d94d61eb1e205dce7fa6932ef":["ac35531329b1809368fb0780bcf1e72d0add3c21","4ab833f2b623042c834458d4cbcad05073a93793"]},"commit2Childs":{"407687e67faf6e1f02a211ca078d8e3eed631027":[],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["407687e67faf6e1f02a211ca078d8e3eed631027","ea187884f51c148cb86509b1ee7705026b8c7b94","f2126b84bd093fa3d921582a109a0ee578c28126"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["4ab833f2b623042c834458d4cbcad05073a93793","2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"4ab833f2b623042c834458d4cbcad05073a93793":["2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"ea187884f51c148cb86509b1ee7705026b8c7b94":["407687e67faf6e1f02a211ca078d8e3eed631027","5a2d81cf6955f09cda03ed448bb9bb397d4b9742"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["016b6925925785877da3496ebb08189655bbc9e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"5a2d81cf6955f09cda03ed448bb9bb397d4b9742":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"016b6925925785877da3496ebb08189655bbc9e6":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2138c838f1c8052d94d61eb1e205dce7fa6932ef":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}