{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","commits":[{"id":"95bf9c30ed04bd202c0161831dc06decc6670b73","date":1200828698,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"/dev/null","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    err = null;\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbd0e8fef7999fa0d948a876724808ca2131cc79","date":1200951763,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    err = null;\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    err = null;\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edbc02bad7b5b2634d0cf080d93d96fc03b901f8","date":1246037214,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    err = null;\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13eaef7d286f35b5c850a1c2eb7b337679aa6453","date":1249118545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).getConstructor(new Class[] { IndexWriter.class }).newInstance(new Object[] { writer }));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    RuntimeException err = null;\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergeScheduler + \"' as merge scheduler\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).newInstance());\n    } catch (IllegalAccessException iae) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(iae);\n    } catch (InstantiationException ie) {\n      err = new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(ie);\n    } catch (ClassNotFoundException cnfe) {\n      err = new RuntimeException(\"unable to load class '\" + mergePolicy + \"' as merge policy\");\n      err.initCause(cnfe);\n    }\n    if (err != null)\n      throw err;\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffdf794cee8d43eb612df752c592cef2dc3e75ae","date":1256465578,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler((MergeScheduler) Class.forName(mergeScheduler).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy((MergePolicy) Class.forName(mergePolicy).getConstructor(new Class[] { IndexWriter.class }).newInstance(new Object[] { writer }));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa","date":1261431504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriter.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask#setIndexWriterConfig(IndexWriter,Config).mjava","sourceNew":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","sourceOld":"  public static void setIndexWriterConfig(IndexWriter writer, Config config) throws IOException {\n\n    final String mergeScheduler = config.get(\"merge.scheduler\",\n                                             \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    try {\n      writer.setMergeScheduler(Class.forName(mergeScheduler).asSubclass(MergeScheduler.class).newInstance());\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergeScheduler + \"' as merge scheduler\", e);\n    }\n\n    if (mergeScheduler.equals(\"org.apache.lucene.index.ConcurrentMergeScheduler\")) {\n      ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getMergeScheduler();\n      int v = config.get(\"concurrent.merge.scheduler.max.thread.count\", -1);\n      if (v != -1) {\n        cms.setMaxThreadCount(v);\n      }\n      v = config.get(\"concurrent.merge.scheduler.max.merge.count\", -1);\n      if (v != -1) {\n        cms.setMaxMergeCount(v);\n      }\n    }\n\n    final String mergePolicy = config.get(\"merge.policy\",\n                                          \"org.apache.lucene.index.LogByteSizeMergePolicy\");\n    try {\n      writer.setMergePolicy(Class.forName(mergePolicy).asSubclass(MergePolicy.class).getConstructor(IndexWriter.class).newInstance(writer));\n    } catch (Exception e) {\n      throw new RuntimeException(\"unable to instantiate class '\" + mergePolicy + \"' as merge policy\", e);\n    }\n\n    writer.setUseCompoundFile(config.get(\"compound\",true));\n    writer.setMergeFactor(config.get(\"merge.factor\",OpenIndexTask.DEFAULT_MERGE_PFACTOR));\n    writer.setMaxFieldLength(config.get(\"max.field.length\",OpenIndexTask.DEFAULT_MAX_FIELD_LENGTH));\n\n    final double ramBuffer = config.get(\"ram.flush.mb\",OpenIndexTask.DEFAULT_RAM_FLUSH_MB);\n    final int maxBuffered = config.get(\"max.buffered\",OpenIndexTask.DEFAULT_MAX_BUFFERED);\n    if (maxBuffered == IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      writer.setRAMBufferSizeMB(ramBuffer);\n      writer.setMaxBufferedDocs(maxBuffered);\n    } else {\n      writer.setMaxBufferedDocs(maxBuffered);\n      writer.setRAMBufferSizeMB(ramBuffer);\n    }\n    \n    String infoStreamVal = config.get(\"writer.info.stream\", null);\n    if (infoStreamVal != null) {\n      if (infoStreamVal.equals(\"SystemOut\")) {\n        writer.setInfoStream(System.out);\n      } else if (infoStreamVal.equals(\"SystemErr\")) {\n        writer.setInfoStream(System.err);\n      } else {\n        File f = new File(infoStreamVal).getAbsoluteFile();\n        writer.setInfoStream(new PrintStream(new BufferedOutputStream(new FileOutputStream(f))));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ffdf794cee8d43eb612df752c592cef2dc3e75ae":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"95bf9c30ed04bd202c0161831dc06decc6670b73":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"bbd0e8fef7999fa0d948a876724808ca2131cc79":["95bf9c30ed04bd202c0161831dc06decc6670b73"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["ffdf794cee8d43eb612df752c592cef2dc3e75ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edbc02bad7b5b2634d0cf080d93d96fc03b901f8":["bbd0e8fef7999fa0d948a876724808ca2131cc79"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["edbc02bad7b5b2634d0cf080d93d96fc03b901f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"ffdf794cee8d43eb612df752c592cef2dc3e75ae":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"],"95bf9c30ed04bd202c0161831dc06decc6670b73":["bbd0e8fef7999fa0d948a876724808ca2131cc79"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"bbd0e8fef7999fa0d948a876724808ca2131cc79":["edbc02bad7b5b2634d0cf080d93d96fc03b901f8"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["95bf9c30ed04bd202c0161831dc06decc6670b73"],"edbc02bad7b5b2634d0cf080d93d96fc03b901f8":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["ffdf794cee8d43eb612df752c592cef2dc3e75ae"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}