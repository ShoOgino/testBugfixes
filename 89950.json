{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[],boolean).mjava","commits":[{"id":"110125c995236a7f61057dd04b039ed2d267f3a1","date":1521014987,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates, boolean enforceFieldExistence) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (enforceFieldExistence && !globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36d13f271b6649357e07f71f7e46559479f69b5b","date":1523888226,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#buildDocValuesUpdate(Term,Field[],boolean).mjava","sourceNew":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType) && f.name().equals(config.softDeletesField) == false) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","sourceOld":"  private DocValuesUpdate[] buildDocValuesUpdate(Term term, Field[] updates, boolean enforceFieldExistence) {\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (enforceFieldExistence && !globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    return dvUpdates;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"36d13f271b6649357e07f71f7e46559479f69b5b":["110125c995236a7f61057dd04b039ed2d267f3a1"],"110125c995236a7f61057dd04b039ed2d267f3a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36d13f271b6649357e07f71f7e46559479f69b5b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["110125c995236a7f61057dd04b039ed2d267f3a1"],"36d13f271b6649357e07f71f7e46559479f69b5b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"110125c995236a7f61057dd04b039ed2d267f3a1":["36d13f271b6649357e07f71f7e46559479f69b5b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}