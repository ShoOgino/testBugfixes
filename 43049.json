{"path":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","commits":[{"id":"b8b1e3cb6d0a81993a229bb7c59dcb45b5297b53","date":1447426018,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(2);\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      stopAndStartAllReplicas();\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(300000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(2);\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      stopAndStartAllReplicas();\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fee387208fa3376c4facaa9115e8750312e299e","date":1520093349,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(300000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab2f54aa3920f7b4a9b92e45334237f6427b20d3","date":1522384863,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f5c62b9f642a9bf5f606fbda74b01ea22d35f00","date":1549589252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RestartWhileUpdatingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320, TimeUnit.SECONDS);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // start a couple indexing threads\n    \n    int[] maxDocList = new int[] {5000, 10000};\n \n    \n    int maxDoc = maxDocList[random().nextInt(maxDocList.length - 1)];\n    \n    int numThreads = random().nextInt(4) + 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    Thread expireThread = new Thread() {\n      public void run() {\n        while (!stopExpire) {\n          try {\n            Thread.sleep(random().nextInt(15000));\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        \n//          try {\n//            chaosMonkey.expireRandomSession();\n//          } catch (KeeperException e) {\n//            throw new RuntimeException(e);\n//          } catch (InterruptedException e) {\n//            throw new RuntimeException(e);\n//          }\n        }\n      }\n    };\n\n//  Currently unused\n//  expireThread.start();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxDoc, 1, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    int restartTimes = 1;//random().nextInt(4) + 1;;\n    for (int i = 0; i < restartTimes; i++) {\n      Thread.sleep(random().nextInt(30000));\n      stopAndStartAllReplicas();\n      Thread.sleep(random().nextInt(30000));\n    }\n    \n    Thread.sleep(2000);\n    \n    // stop indexing threads\n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    stopExpire = true;\n    expireThread.join();\n    \n    Thread.sleep(1000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(30);\n    \n    Thread.sleep(5000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n\n    for (StoppableIndexingThread thread : threads) {\n      thread.join();\n    }\n    \n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["43ad790248d7f7daee5d9cced548c546f37c7218"],"536b47681314488eb94706248be6047a3f142841":["b8b1e3cb6d0a81993a229bb7c59dcb45b5297b53"],"7f5c62b9f642a9bf5f606fbda74b01ea22d35f00":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["7f5c62b9f642a9bf5f606fbda74b01ea22d35f00"],"8fee387208fa3376c4facaa9115e8750312e299e":["536b47681314488eb94706248be6047a3f142841"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["8fee387208fa3376c4facaa9115e8750312e299e","ab2f54aa3920f7b4a9b92e45334237f6427b20d3"],"43ad790248d7f7daee5d9cced548c546f37c7218":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"b8b1e3cb6d0a81993a229bb7c59dcb45b5297b53":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab2f54aa3920f7b4a9b92e45334237f6427b20d3":["8fee387208fa3376c4facaa9115e8750312e299e"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"536b47681314488eb94706248be6047a3f142841":["8fee387208fa3376c4facaa9115e8750312e299e"],"7f5c62b9f642a9bf5f606fbda74b01ea22d35f00":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8b1e3cb6d0a81993a229bb7c59dcb45b5297b53"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8fee387208fa3376c4facaa9115e8750312e299e":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d","ab2f54aa3920f7b4a9b92e45334237f6427b20d3"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["43ad790248d7f7daee5d9cced548c546f37c7218"],"43ad790248d7f7daee5d9cced548c546f37c7218":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"b8b1e3cb6d0a81993a229bb7c59dcb45b5297b53":["536b47681314488eb94706248be6047a3f142841"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["7f5c62b9f642a9bf5f606fbda74b01ea22d35f00"],"ab2f54aa3920f7b4a9b92e45334237f6427b20d3":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}