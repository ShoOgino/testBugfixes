{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","commits":[{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,String).mjava","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeString String}.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  // nocommit: fix javadocs, add segmentLength()\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, String segmentID) throws IOException {\n    writeHeader(out, codec, version);\n    // nocommit: improve encoding of this ID\n    out.writeString(segmentID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78b813d9350cc28625598f6dbbb49b586a40618","date":1412073147,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[], String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID,SegmentSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>SegmentID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>SegmentSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #segmentHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param segmentSuffix auxiliary suffix for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid,\n   *         or if the segmentSuffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID, String segmentSuffix) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n    BytesRef suffixBytes = new BytesRef(segmentSuffix);\n    if (suffixBytes.length != segmentSuffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + segmentSuffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[], String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID,SegmentSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>SegmentID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>SegmentSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #segmentHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param segmentSuffix auxiliary suffix for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid,\n   *         or if the segmentSuffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID, String segmentSuffix) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n    BytesRef suffixBytes = new BytesRef(segmentSuffix);\n    if (suffixBytes.length != segmentSuffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + segmentSuffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a78b813d9350cc28625598f6dbbb49b586a40618":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9bb9a29a5e71a90295f175df8919802993142c9a":["5f6bd27530a2846413fe2d00030493c0e2d3a072","a78b813d9350cc28625598f6dbbb49b586a40618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9bb9a29a5e71a90295f175df8919802993142c9a"]},"commit2Childs":{"a78b813d9350cc28625598f6dbbb49b586a40618":["9bb9a29a5e71a90295f175df8919802993142c9a"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["a78b813d9350cc28625598f6dbbb49b586a40618","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"9bb9a29a5e71a90295f175df8919802993142c9a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["9bb9a29a5e71a90295f175df8919802993142c9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}