{"path":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","commits":[{"id":"7cefb6c0aa217f293070c43e7a77682dd56e0a33","date":1416928878,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"/dev/null","sourceNew":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        fs = new WindowsFS(fs).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f26ca208d257c1aab942fa766374731b62328b8a","date":1417011743,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        fs = new WindowsFS(fs).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        fs = new WindowsFS(fs).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9717993718e6ff1ba8239294f736cf51c0daac3c","date":1417303435,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        fs = new WindowsFS(fs).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b185840df853cd910fb9ef34e8ad534560d3ce5a","date":1424440830,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      fs = new DisableFsyncFS(fs).getFileSystem(null);\n      fs = new LeakFS(fs).getFileSystem(null);\n      fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22989c36ff05c657df26dd3377b37c9ad35859bc","date":1424477375,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, new Random(random.nextLong())).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc497136b1e0f10fecf39a1cd3c7ed55bb2e9677","date":1429385277,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, new Random(random.nextLong())).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    // sometimes just use a bare filesystem\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, new Random(random.nextLong())).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0570a6b8fbda74e4718ba36c70fd1953103a3dcb","date":1429616032,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, new Random(random.nextLong())).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      // nocommit true:\n      if (allowed(avoid, VirusCheckingFS.class) && (true || random.nextInt(10) == 1)) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random);\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44a0466296f4b2d9deac60e3e524628c97aa5191","date":1454532248,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      // nocommit true:\n      if (allowed(avoid, VirusCheckingFS.class) && (true || random.nextInt(10) == 1)) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random.nextLong());\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      // nocommit true:\n      if (allowed(avoid, VirusCheckingFS.class) && (true || random.nextInt(10) == 1)) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random);\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2feb34d5a2e6551d6099d3050d0da19573c4fc9","date":1454532470,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      if (allowed(avoid, VirusCheckingFS.class) && random.nextInt(10) == 1) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random.nextLong());\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      // nocommit true:\n      if (allowed(avoid, VirusCheckingFS.class) && (true || random.nextInt(10) == 1)) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random.nextLong());\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n      if (allowed(avoid, VirusCheckingFS.class) && random.nextInt(10) == 1) {\n        // 10% of the time we swap in virus checking (acts-like-windows) FS:    \n        virusCheckingFS = new VirusCheckingFS(fs, random.nextLong());\n        fs = virusCheckingFS.getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup#initializeFileSystem().mjava","sourceNew":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","sourceOld":"  private FileSystem initializeFileSystem() {\n    Class<?> targetClass = RandomizedContext.current().getTargetClass();\n    Set<String> avoid = new HashSet<>();\n    if (targetClass.isAnnotationPresent(SuppressFileSystems.class)) {\n      SuppressFileSystems a = targetClass.getAnnotation(SuppressFileSystems.class);\n      avoid.addAll(Arrays.asList(a.value()));\n    }\n    FileSystem fs = FileSystems.getDefault();\n    if (LuceneTestCase.VERBOSE && allowed(avoid, VerboseFS.class)) {\n      fs = new VerboseFS(fs, new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out)).getFileSystem(null);\n    }\n    \n    Random random = RandomizedContext.current().getRandom();\n    \n    // speed up tests by omitting actual fsync calls to the hardware most of the time.\n    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {\n      if (allowed(avoid, DisableFsyncFS.class)) {\n        fs = new DisableFsyncFS(fs).getFileSystem(null);\n      }\n    }\n    \n    // impacts test reproducibility across platforms.\n    if (random.nextInt(100) > 0) {\n      if (allowed(avoid, ShuffleFS.class)) {\n        fs = new ShuffleFS(fs, random.nextLong()).getFileSystem(null);\n      }\n    }\n    \n    // otherwise, wrap with mockfilesystems for additional checks. some \n    // of these have side effects (e.g. concurrency) so it doesn't always happen.\n    if (random.nextInt(10) > 0) {\n      if (allowed(avoid, LeakFS.class)) {\n        fs = new LeakFS(fs).getFileSystem(null);\n      }\n      if (allowed(avoid, HandleLimitFS.class)) {\n        fs = new HandleLimitFS(fs, MAX_OPEN_FILES).getFileSystem(null);\n      }\n      // windows is currently slow\n      if (random.nextInt(10) == 0) {\n        // don't try to emulate windows on windows: they don't get along\n        if (!Constants.WINDOWS && allowed(avoid, WindowsFS.class)) {\n          fs = new WindowsFS(fs).getFileSystem(null);\n        }\n      }\n      if (allowed(avoid, ExtrasFS.class)) {\n        fs = new ExtrasFS(fs, random.nextInt(4) == 0, random.nextBoolean()).getFileSystem(null);\n      }\n    }\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"filesystem: \" + fs.provider());\n    }\n    return fs.provider().getFileSystem(URI.create(\"file:///\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["e2feb34d5a2e6551d6099d3050d0da19573c4fc9"],"0570a6b8fbda74e4718ba36c70fd1953103a3dcb":["fc497136b1e0f10fecf39a1cd3c7ed55bb2e9677"],"5a207d19eac354d649c3f0e2cce070017c78125e":["0570a6b8fbda74e4718ba36c70fd1953103a3dcb","b470f36a9372c97283360b1304eacbde22df6c0d"],"f26ca208d257c1aab942fa766374731b62328b8a":["7cefb6c0aa217f293070c43e7a77682dd56e0a33"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0570a6b8fbda74e4718ba36c70fd1953103a3dcb","b470f36a9372c97283360b1304eacbde22df6c0d"],"7cefb6c0aa217f293070c43e7a77682dd56e0a33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9717993718e6ff1ba8239294f736cf51c0daac3c":["f26ca208d257c1aab942fa766374731b62328b8a"],"fc497136b1e0f10fecf39a1cd3c7ed55bb2e9677":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"b185840df853cd910fb9ef34e8ad534560d3ce5a":["9717993718e6ff1ba8239294f736cf51c0daac3c"],"b470f36a9372c97283360b1304eacbde22df6c0d":["0570a6b8fbda74e4718ba36c70fd1953103a3dcb","34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2feb34d5a2e6551d6099d3050d0da19573c4fc9":["44a0466296f4b2d9deac60e3e524628c97aa5191"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["0570a6b8fbda74e4718ba36c70fd1953103a3dcb"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["b185840df853cd910fb9ef34e8ad534560d3ce5a"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a207d19eac354d649c3f0e2cce070017c78125e"]},"commit2Childs":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["b470f36a9372c97283360b1304eacbde22df6c0d"],"0570a6b8fbda74e4718ba36c70fd1953103a3dcb":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f26ca208d257c1aab942fa766374731b62328b8a":["9717993718e6ff1ba8239294f736cf51c0daac3c"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"7cefb6c0aa217f293070c43e7a77682dd56e0a33":["f26ca208d257c1aab942fa766374731b62328b8a"],"9717993718e6ff1ba8239294f736cf51c0daac3c":["b185840df853cd910fb9ef34e8ad534560d3ce5a"],"fc497136b1e0f10fecf39a1cd3c7ed55bb2e9677":["0570a6b8fbda74e4718ba36c70fd1953103a3dcb"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"b185840df853cd910fb9ef34e8ad534560d3ce5a":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7cefb6c0aa217f293070c43e7a77682dd56e0a33"],"e2feb34d5a2e6551d6099d3050d0da19573c4fc9":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["44a0466296f4b2d9deac60e3e524628c97aa5191"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["fc497136b1e0f10fecf39a1cd3c7ed55bb2e9677"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["e2feb34d5a2e6551d6099d3050d0da19573c4fc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}