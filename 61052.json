{"path":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#handleMergeFields(ResponseBuilder,SolrIndexSearcher).mjava","commits":[{"id":"bd81b9f1e22432a668756e938bfb0835c1abb11b","date":1546254331,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#handleMergeFields(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy1#handleMergeFields(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n      // currently have an option to return sort field values.  Because of this, we\n      // take the documents given and re-derive the sort values.\n      //\n      // TODO: See SOLR-5595\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          // if there is a single segment, use that subReader and avoid looking up each time\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        // sort ids from lowest to highest so we can access them in order\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        // sort ids and scores together\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          // :TODO: would be simpler to always serialize every position of SortField[]\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                // we switched segments.  invalidate comparator.\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  // adjust for what segment this is in\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n\n","sourceOld":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n      // currently have an option to return sort field values.  Because of this, we\n      // take the documents given and re-derive the sort values.\n      //\n      // TODO: See SOLR-5595\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          // if there is a single segment, use that subReader and avoid looking up each time\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        // sort ids from lowest to highest so we can access them in order\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        // sort ids and scores together\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          // :TODO: would be simpler to always serialize every position of SortField[]\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                // we switched segments.  invalidate comparator.\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  // adjust for what segment this is in\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd81b9f1e22432a668756e938bfb0835c1abb11b"]},"commit2Childs":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd81b9f1e22432a668756e938bfb0835c1abb11b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}