{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","commits":[{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"/dev/null","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId(); \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["22859cb40e09867e7da8de84a31956c07259f82f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aea1d78da2c058b98e64569bcd37981c733b52a8","date":1400551646,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      \n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId(); \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      \n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId(); \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c824e7f6927860d366e4888be45e4db8c9e03b","date":1405193679,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, it was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      \n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCore : replicas) {\n          \n          if (coreName.equals(replicaCore))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCore);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After \"+coreName+\" was elected leader, found \"+\n               replicaCore+\" as \"+lirState+\" and needing recovery.\");\n            \n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(\n                    collection, shardId, coreName, replicaCore, null, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCore)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, replicaCore, coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":["dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc","10ee1aa2755e028d54c34bd648d7a6b11037f1f5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039","date":1405209123,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, it was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, it was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName, null);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e568c41898fe51e779879e5c3c531440ef797d1","date":1405324019,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, it was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10ee1aa2755e028d54c34bd648d7a6b11037f1f5","date":1405328010,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (p.getCoreName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e36353d7461af8d2329a78a71457cf8e3c1e88f","date":1411572107,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":["22859cb40e09867e7da8de84a31956c07259f82f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc","date":1426444850,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, false, coreNodeName);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0932eb10135843758b2ca508d5aa2b4798aa07f9","date":1426947197,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */, true /* retryOnConnLoss */);\n\n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, false, coreNodeName);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":["22859cb40e09867e7da8de84a31956c07259f82f","3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */, true /* retryOnConnLoss */);\n\n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps.getCoreUrl(), coreNodeProps, false);\n              \n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */, true /* retryOnConnLoss */);\n\n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          String lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERY_FAILED.equals(lirState)) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps = \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */, true /* retryOnConnLoss */);\n\n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22859cb40e09867e7da8de84a31956c07259f82f","date":1441822065,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              LeaderInitiatedRecoveryThread lirThread = \n                  new LeaderInitiatedRecoveryThread(zkController,\n                                                    cc,\n                                                    collection,\n                                                    shardId,\n                                                    coreNodeProps,\n                                                    120,\n                                                    coreNodeName);\n              zkController.ensureReplicaInLeaderInitiatedRecovery(\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */, true /* retryOnConnLoss */);\n\n              ExecutorService executor = cc.getUpdateShardHandler().getUpdateExecutor();\n              executor.execute(lirThread);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":["14d5815ecbef89580f5c48990bcd433f04f8563a","6e36353d7461af8d2329a78a71457cf8e3c1e88f","0932eb10135843758b2ca508d5aa2b4798aa07f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e0300d1df37d7e9662d491269e91b6f66dca8bd","date":1443011762,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                  false /* forcePublishState */);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, coreNodeName,\n                  false /* forcePublishState */);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":["0932eb10135843758b2ca508d5aa2b4798aa07f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  @Deprecated\n  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n            coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n\n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n\n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n\n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n\n          if (zkController.getShardTerms(collection, shardId).registered(replicaCoreNodeName)) {\n            // the replica registered its term so it is running with the new LIR implementation\n            // we can put this replica into recovery by increase our terms\n            zkController.getShardTerms(collection, shardId).ensureTermsIsHigher(coreNodeName, Collections.singleton(replicaCoreNodeName));\n            continue;\n          }\n\n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =\n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n\n            if (replicaProps != null && replicaProps.size() > 0) {\n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n\n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                  false /* forcePublishState */);\n            }\n          }\n        }\n      }\n    } // core gets closed automagically\n  }\n\n","sourceOld":"  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n           coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n      \n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n      \n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n          \n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n          \n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =  \n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n            \n            if (replicaProps != null && replicaProps.size() > 0) {                \n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n              \n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                  false /* forcePublishState */);\n            }              \n          }\n        }\n      }\n    } // core gets closed automagically    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":"  @Deprecated\n  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n            coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n\n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n\n      if (replicas != null && replicas.size() > 0) {\n        // set of replicas which is running in new LIR but lirState=DOWN\n        Set<String> replicasMustBeInLowerTerm = new HashSet<>();\n        for (String replicaCoreNodeName : replicas) {\n\n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n\n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<Replica> replicasProps =\n                zkController.getZkStateReader().getClusterState().getCollection(collection)\n                    .getSlice(shardId).getReplicas(EnumSet.of(Replica.Type.NRT, Replica.Type.TLOG));\n\n            if (replicasProps != null && replicasProps.size() > 0) {\n              ZkCoreNodeProps coreNodeProps = null;\n              for (Replica p : replicasProps) {\n                if (p.getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = new ZkCoreNodeProps(p);\n                  break;\n                }\n              }\n\n              if (zkController.getShardTerms(collection, shardId).registered(replicaCoreNodeName)) {\n                replicasMustBeInLowerTerm.add(replicaCoreNodeName);\n              } else {\n                zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                    collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                    false /* forcePublishState */);\n              }\n            }\n          }\n        }\n        // these replicas registered their terms so it is running with the new LIR implementation\n        // we can put this replica into recovery by increase our terms\n        zkController.getShardTerms(collection, shardId).ensureTermsIsHigher(coreNodeName, replicasMustBeInLowerTerm);\n      }\n    } // core gets closed automagically\n  }\n\n","sourceOld":"  @Deprecated\n  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n            coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n\n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n\n      if (replicas != null && replicas.size() > 0) {\n        for (String replicaCoreNodeName : replicas) {\n\n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n\n          if (zkController.getShardTerms(collection, shardId).registered(replicaCoreNodeName)) {\n            // the replica registered its term so it is running with the new LIR implementation\n            // we can put this replica into recovery by increase our terms\n            zkController.getShardTerms(collection, shardId).ensureTermsIsHigher(coreNodeName, Collections.singleton(replicaCoreNodeName));\n            continue;\n          }\n\n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<ZkCoreNodeProps> replicaProps =\n                zkController.getZkStateReader().getReplicaProps(collection, shardId, coreNodeName);\n\n            if (replicaProps != null && replicaProps.size() > 0) {\n              ZkCoreNodeProps coreNodeProps = null;\n              for (ZkCoreNodeProps p : replicaProps) {\n                if (((Replica)p.getNodeProps()).getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = p;\n                  break;\n                }\n              }\n\n              zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                  collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                  false /* forcePublishState */);\n            }\n          }\n        }\n      }\n    } // core gets closed automagically\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#startLeaderInitiatedRecoveryOnReplicas(String).mjava","sourceNew":null,"sourceOld":"  @Deprecated\n  private void startLeaderInitiatedRecoveryOnReplicas(String coreName) throws Exception {\n    try (SolrCore core = cc.getCore(coreName)) {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      String coll = cloudDesc.getCollectionName();\n      String shardId = cloudDesc.getShardId();\n      String coreNodeName = cloudDesc.getCoreNodeName();\n\n      if (coll == null || shardId == null) {\n        log.error(\"Cannot start leader-initiated recovery on new leader (core=\"+\n            coreName+\",coreNodeName=\" + coreNodeName + \") because collection and/or shard is null!\");\n        return;\n      }\n\n      String znodePath = zkController.getLeaderInitiatedRecoveryZnodePath(coll, shardId);\n      List<String> replicas = null;\n      try {\n        replicas = zkClient.getChildren(znodePath, null, false);\n      } catch (NoNodeException nne) {\n        // this can be ignored\n      }\n\n      if (replicas != null && replicas.size() > 0) {\n        // set of replicas which is running in new LIR but lirState=DOWN\n        Set<String> replicasMustBeInLowerTerm = new HashSet<>();\n        for (String replicaCoreNodeName : replicas) {\n\n          if (coreNodeName.equals(replicaCoreNodeName))\n            continue; // added safe-guard so we don't mark this core as down\n\n          final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(coll, shardId, replicaCoreNodeName);\n          if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERY_FAILED) {\n            log.info(\"After core={} coreNodeName={} was elected leader, a replica coreNodeName={} was found in state: \"\n                + lirState.toString() + \" and needing recovery.\", coreName, coreNodeName, replicaCoreNodeName);\n            List<Replica> replicasProps =\n                zkController.getZkStateReader().getClusterState().getCollection(collection)\n                    .getSlice(shardId).getReplicas(EnumSet.of(Replica.Type.NRT, Replica.Type.TLOG));\n\n            if (replicasProps != null && replicasProps.size() > 0) {\n              ZkCoreNodeProps coreNodeProps = null;\n              for (Replica p : replicasProps) {\n                if (p.getName().equals(replicaCoreNodeName)) {\n                  coreNodeProps = new ZkCoreNodeProps(p);\n                  break;\n                }\n              }\n\n              if (zkController.getShardTerms(collection, shardId).registered(replicaCoreNodeName)) {\n                replicasMustBeInLowerTerm.add(replicaCoreNodeName);\n              } else {\n                zkController.ensureReplicaInLeaderInitiatedRecovery(cc,\n                    collection, shardId, coreNodeProps, core.getCoreDescriptor(),\n                    false /* forcePublishState */);\n              }\n            }\n          }\n        }\n        // these replicas registered their terms so it is running with the new LIR implementation\n        // we can put this replica into recovery by increase our terms\n        zkController.getShardTerms(collection, shardId).ensureTermsIsHigher(coreNodeName, replicasMustBeInLowerTerm);\n      }\n    } // core gets closed automagically\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["22859cb40e09867e7da8de84a31956c07259f82f"],"84f20f331d8001864545c7021812d8c6509c7593":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"b7605579001505896d48b07160075a5c8b8e128e":["14d5815ecbef89580f5c48990bcd433f04f8563a","aea1d78da2c058b98e64569bcd37981c733b52a8"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["84f20f331d8001864545c7021812d8c6509c7593"],"7e568c41898fe51e779879e5c3c531440ef797d1":["a81e7d9c7ad18b6ec658ebdb132dd51a2164f039"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["0932eb10135843758b2ca508d5aa2b4798aa07f9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6e36353d7461af8d2329a78a71457cf8e3c1e88f","0932eb10135843758b2ca508d5aa2b4798aa07f9"],"22859cb40e09867e7da8de84a31956c07259f82f":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"10ee1aa2755e028d54c34bd648d7a6b11037f1f5":["7e568c41898fe51e779879e5c3c531440ef797d1"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["aea1d78da2c058b98e64569bcd37981c733b52a8"],"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"14d5815ecbef89580f5c48990bcd433f04f8563a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc"],"aea1d78da2c058b98e64569bcd37981c733b52a8":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["10ee1aa2755e028d54c34bd648d7a6b11037f1f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"]},"commit2Childs":{"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc":["0932eb10135843758b2ca508d5aa2b4798aa07f9"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["84f20f331d8001864545c7021812d8c6509c7593"],"84f20f331d8001864545c7021812d8c6509c7593":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"b7605579001505896d48b07160075a5c8b8e128e":[],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"7e568c41898fe51e779879e5c3c531440ef797d1":["10ee1aa2755e028d54c34bd648d7a6b11037f1f5"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["22859cb40e09867e7da8de84a31956c07259f82f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"22859cb40e09867e7da8de84a31956c07259f82f":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"10ee1aa2755e028d54c34bd648d7a6b11037f1f5":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["a81e7d9c7ad18b6ec658ebdb132dd51a2164f039"],"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039":["7e568c41898fe51e779879e5c3c531440ef797d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["b7605579001505896d48b07160075a5c8b8e128e","aea1d78da2c058b98e64569bcd37981c733b52a8"],"aea1d78da2c058b98e64569bcd37981c733b52a8":["b7605579001505896d48b07160075a5c8b8e128e","07c824e7f6927860d366e4888be45e4db8c9e03b"],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}