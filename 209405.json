{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor#refineFacets().mjava","commits":[{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#refineFacets().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    //\n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    //\n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should probably be refactored to share more code.\n\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n\n      // NOTE: we're re-using this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.BEFORE.toString(),\n            refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.AFTER.toString(),\n            refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetParams.FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetParams.FacetRangeOther.BETWEEN.toString(),\n            refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    // this refineFacets method is patterned after FacetFieldProcessor.refineFacets such that\n    // the same \"_s\" skip bucket syntax is used and FacetRangeMerger can subclass FacetRequestSortedMerger\n    // for dealing with them & the refinement requests.\n    // \n    // But range faceting does *NOT* use the \"leaves\" and \"partial\" syntax\n    // \n    // If/When range facet becomes more like field facet in it's ability to sort and limit the \"range buckets\"\n    // FacetRangeProcessor and FacetFieldProcessor should probably be refactored to share more code.\n    \n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n    List<List> skip = FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n\n    // sanity check our merger's super class didn't send us something we can't handle ...\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_l\")).size();\n    assert 0 == FacetFieldProcessor.asList(fcontext.facetInfo.get(\"_p\")).size();\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( skip.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    { // refine the special \"other\" buckets\n      \n      // NOTE: we're re-using this variable for each special we look for...\n      Map<String,Object> specialFacetInfo;\n\n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BEFORE.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BEFORE.toString(),\n                refineRange(buildBeforeRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.AFTER.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.AFTER.toString(),\n                refineRange(buildAfterRange(), skipThisFacet, specialFacetInfo));\n      }\n      \n      specialFacetInfo = (Map<String, Object>) fcontext.facetInfo.get(FacetRangeOther.BETWEEN.toString());\n      if (null != specialFacetInfo) {\n        res.add(FacetRangeOther.BETWEEN.toString(),\n                refineRange(buildBetweenRange(), skipThisFacet, specialFacetInfo));\n      }\n    }\n      \n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"]},"commit2Childs":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}