{"path":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","commits":[{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"/dev/null","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10307c7cc22e7e4087990972985e1d1043f01442","date":1376933032,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      if (rand.nextBoolean()) {\n        params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 10) {\n        params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\", null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  _TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<String>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3802d95c3a31be21ea2971945049b711d95ef8d5","date":1455055616,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"uif\") && params.get(\"facet.prefix\")!=null) {\n          continue; // it's not supported there\n        }\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c64189697927b548f74ba66dfa5051548662938","date":1455059336,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"uif\") && params.get(\"facet.prefix\")!=null) {\n          continue; // it's not supported there\n        }\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<methods.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"550bbe5ffcdb614551686767f4d5a6ee38ef3e85","date":1457221653,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"uif\") && params.get(\"facet.prefix\")!=null) {\n          continue; // it's not supported there\n        }\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":["3802d95c3a31be21ea2971945049b711d95ef8d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumericType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\", \"rows\",\"0\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      int limit = 100;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n        }\n        params.add(\"facet.limit\", Integer.toString(limit));\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomDVFaceting#doFacetTests(FldType).mjava","sourceNew":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: {}\\n expected ={}\\n response = {}\\n request = {}\"\n                , err, responses.get(0), responses.get(i), params);\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","sourceOld":"  void doFacetTests(FldType ftype) throws Exception {\n    SolrQueryRequest req = req();\n    try {\n      Random rand = random();\n      boolean validate = validateResponses;\n      ModifiableSolrParams params = params(\"facet\",\"true\", \"wt\",\"json\", \"indent\",\"true\", \"omitHeader\",\"true\");\n      params.add(\"q\",\"*:*\");  // TODO: select subsets\n      params.add(\"rows\",\"0\");\n\n      SchemaField sf = req.getSchema().getField(ftype.fname);\n      boolean multiValued = sf.getType().multiValuedFieldCache();\n      boolean indexed = sf.indexed();\n      boolean numeric = sf.getType().getNumberType() != null;\n\n      int offset = 0;\n      if (rand.nextInt(100) < 20) {\n        if (rand.nextBoolean()) {\n          offset = rand.nextInt(100) < 10 ? rand.nextInt(indexSize*2) : rand.nextInt(indexSize/3+1);\n        }\n        params.add(\"facet.offset\", Integer.toString(offset));\n      }\n\n      if (rand.nextInt(100) < 20) {\n        if(rarely()) {\n          params.add(\"facet.limit\", \"-1\");\n        } else {\n          int limit = 100;\n          if (rand.nextBoolean()) {\n            limit = rand.nextInt(100) < 10 ? rand.nextInt(indexSize/2+1) : rand.nextInt(indexSize*2);\n          }\n          params.add(\"facet.limit\", Integer.toString(limit));\n        }\n      }\n\n      // the following two situations cannot work for unindexed single-valued numerics:\n      // (currently none of the dv fields in this test config)\n      //     facet.sort = index\n      //     facet.minCount = 0\n      if (!numeric || sf.multiValued()) {\n        if (rand.nextBoolean()) {\n          params.add(\"facet.sort\", rand.nextBoolean() ? \"index\" : \"count\");\n        }\n        \n        if (rand.nextInt(100) < 10) {\n          params.add(\"facet.mincount\", Integer.toString(rand.nextInt(5)));\n        }\n      } else {\n        params.add(\"facet.sort\", \"count\");\n        params.add(\"facet.mincount\", Integer.toString(1+rand.nextInt(5)));\n      }\n\n      if ((ftype.vals instanceof SVal) && rand.nextInt(100) < 20) {\n        // validate = false;\n        String prefix = ftype.createValue().toString();\n        if (rand.nextInt(100) < 5) prefix =  TestUtil.randomUnicodeString(rand);\n        else if (rand.nextInt(100) < 10) prefix = Character.toString((char)rand.nextInt(256));\n        else if (prefix.length() > 0) prefix = prefix.substring(0, rand.nextInt(prefix.length()));\n        params.add(\"facet.prefix\", prefix);\n      }\n\n      if (rand.nextInt(100) < 20) {\n        params.add(\"facet.missing\", \"true\");\n      }\n\n      // TODO: randomly add other facet params\n      String facet_field = ftype.fname;\n\n      List<String> methods = multiValued ? multiValuedMethods : singleValuedMethods;\n      List<String> responses = new ArrayList<>(methods.size());\n      for (String method : methods) {\n        if (method.equals(\"dv\")) {\n          params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_dv\");\n          params.set(\"facet.method\",(String) null);\n        } else {\n          params.set(\"facet.field\", facet_field);\n          params.set(\"facet.method\", method);\n        }\n\n        // if (random().nextBoolean()) params.set(\"facet.mincount\", \"1\");  // uncomment to test that validation fails\n\n        String strResponse = h.query(req(params));\n        // Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        // System.out.println(strResponse);\n\n        responses.add(strResponse);\n      }\n      // If there is a PointField option for this test, also test it\n      // Don't check points if facet.mincount=0\n      if (h.getCore().getLatestSchema().getFieldOrNull(facet_field + \"_p\") != null\n          && params.get(\"facet.mincount\") != null\n          && params.getInt(\"facet.mincount\").intValue() > 0) {\n        params.set(\"facet.field\", \"{!key=\"+facet_field+\"}\"+facet_field+\"_p\");\n        String strResponse = h.query(req(params));\n        responses.add(strResponse);\n      }\n\n      /**\n      String strResponse = h.query(req(params));\n      Object realResponse = ObjectBuilder.fromJSON(strResponse);\n      **/\n\n      if (validate) {\n        for (int i=1; i<responses.size(); i++) {\n          String err = JSONTestUtil.match(\"/\", responses.get(i), responses.get(0), 0.0);\n          if (err != null) {\n            log.error(\"ERROR: mismatch facet response: \" + err +\n                \"\\n expected =\" + responses.get(0) +\n                \"\\n response = \" + responses.get(i) +\n                \"\\n request = \" + params\n            );\n            fail(err);\n          }\n        }\n      }\n\n\n    } finally {\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"10307c7cc22e7e4087990972985e1d1043f01442":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"46dc9ac8b3e748407baaef82453138ff3974480c":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85"],"6613659748fe4411a7dcf85266e55db1f95f7315":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","10307c7cc22e7e4087990972985e1d1043f01442"],"3c64189697927b548f74ba66dfa5051548662938":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3802d95c3a31be21ea2971945049b711d95ef8d5"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"550bbe5ffcdb614551686767f4d5a6ee38ef3e85":["3c64189697927b548f74ba66dfa5051548662938"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85","46dc9ac8b3e748407baaef82453138ff3974480c"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"022a4de90e0479b604264ca9c2e134c996454ab3":["3d81baa64023bbb9b43f6d929ee168b105940d30","744b111b17d15d490a648eb021bfa240e7f11556"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["46dc9ac8b3e748407baaef82453138ff3974480c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"744b111b17d15d490a648eb021bfa240e7f11556":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["10307c7cc22e7e4087990972985e1d1043f01442","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3c64189697927b548f74ba66dfa5051548662938","3802d95c3a31be21ea2971945049b711d95ef8d5"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"10307c7cc22e7e4087990972985e1d1043f01442":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"46dc9ac8b3e748407baaef82453138ff3974480c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","3d81baa64023bbb9b43f6d929ee168b105940d30"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"3c64189697927b548f74ba66dfa5051548662938":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85"],"550bbe5ffcdb614551686767f4d5a6ee38ef3e85":["46dc9ac8b3e748407baaef82453138ff3974480c","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["6613659748fe4411a7dcf85266e55db1f95f7315"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["3c64189697927b548f74ba66dfa5051548662938"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}